<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>放肆的青春</title>
  
  <subtitle>要变得和大叔一样强</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xym-loveit.github.io/"/>
  <updated>2018-03-29T03:09:43.791Z</updated>
  <id>http://xym-loveit.github.io/</id>
  
  <author>
    <name>xym</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用工具</title>
    <link href="http://xym-loveit.github.io/2018/03/29/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <id>http://xym-loveit.github.io/2018/03/29/常用工具/</id>
    <published>2018-03-29T01:43:38.000Z</published>
    <updated>2018-03-29T03:09:43.791Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、Grepcode"><a href="#1、Grepcode" class="headerlink" title="1、Grepcode"></a>1、<a href="http://grepcode.com/" target="_blank" rel="noopener">Grepcode</a></h3><p>这是一个面向于java开发人员的网站，在这里你可以通过java的projects、classes等各种关键字在线查看它对应的源码，知道对应的project、classes等信息</p><h3 id="2、SearchCode"><a href="#2、SearchCode" class="headerlink" title="2、SearchCode"></a>2、<a href="https://searchcode.com/" target="_blank" rel="noopener">SearchCode</a></h3><p>SearchCode 是一个源码搜索引擎，目前支持从 Github、Bitbucket、Google Code、CodePlex、SourceForge 和 Fedora Project 平台搜索公开的源码。</p><h3 id="3、ProcessOn"><a href="#3、ProcessOn" class="headerlink" title="3、ProcessOn"></a>3、<a href="https://www.processon.com/" target="_blank" rel="noopener">ProcessOn</a></h3><p>ProcessOn是一个在线作图工具的聚合平台，它可以在线画流程图、思维导图、UI原型图、UML、网络拓扑图、组织结构图等等。</p><h3 id="4、json-cn"><a href="#4、json-cn" class="headerlink" title="4、json.cn"></a>4、<a href="https://www.json.cn/" target="_blank" rel="noopener">json.cn</a></h3><p>json在线解析及格式化</p><h3 id="5、bejson"><a href="#5、bejson" class="headerlink" title="5、bejson"></a>5、<a href="http://www.bejson.com/jsonviewernew/" target="_blank" rel="noopener">bejson</a></h3><p>json在线解析及格式化</p><h3 id="6、MaHua-、马克飞象-、Cmd"><a href="#6、MaHua-、马克飞象-、Cmd" class="headerlink" title="6、MaHua 、马克飞象 、Cmd"></a>6、<a href="http://mahua.jser.me/" target="_blank" rel="noopener">MaHua 、马克飞象 、Cmd</a></h3><p>一个在线编辑markdown文档的编辑器</p><h3 id="7、mvnrepository"><a href="#7、mvnrepository" class="headerlink" title="7、mvnrepository"></a>7、<a href="http://mvnrepository.com/" target="_blank" rel="noopener">mvnrepository</a></h3><p>maven依赖地址库</p><h3 id="8、代码在线运行"><a href="#8、代码在线运行" class="headerlink" title="8、代码在线运行"></a>8、<a href="https://tool.lu/coderunner/" target="_blank" rel="noopener">代码在线运行</a></h3><h3 id="9、Google翻译-百度翻译-有道翻译-爱词霸翻译"><a href="#9、Google翻译-百度翻译-有道翻译-爱词霸翻译" class="headerlink" title="9、Google翻译 百度翻译 有道翻译 爱词霸翻译"></a>9、<a href="https://translate.google.cn/" target="_blank" rel="noopener">Google翻译</a> <a href="http://fanyi.baidu.com/" target="_blank" rel="noopener">百度翻译</a> <a href="http://fanyi.youdao.com/" target="_blank" rel="noopener">有道翻译</a> <a href="http://fy.iciba.com/" target="_blank" rel="noopener">爱词霸翻译</a></h3><h3 id="10、AutoJCode"><a href="#10、AutoJCode" class="headerlink" title="10、AutoJCode"></a>10、<a href="http://www.autojcode.com/code/sql2class.jsp" target="_blank" rel="noopener">AutoJCode</a></h3><p>SQL和Java代码互相生成</p><h3 id="11、sql在线美化，格式化，压缩"><a href="#11、sql在线美化，格式化，压缩" class="headerlink" title="11、sql在线美化，格式化，压缩"></a>11、<a href="https://tool.lu/sql/" target="_blank" rel="noopener">sql在线美化，格式化，压缩</a></h3><h3 id="12、编码转换"><a href="#12、编码转换" class="headerlink" title="12、编码转换"></a>12、<a href="http://tool.chinaz.com/tools/unicode.aspx" target="_blank" rel="noopener">编码转换</a></h3><h3 id="13、Cron-常用Cron生成"><a href="#13、Cron-常用Cron生成" class="headerlink" title="13、Cron 常用Cron生成"></a>13、<a href="https://zh.wikipedia.org/zh-sg/Cron" target="_blank" rel="noopener">Cron</a> <a href="http://www.pppet.net/" target="_blank" rel="noopener">常用Cron生成</a></h3><h3 id="14、正则验证"><a href="#14、正则验证" class="headerlink" title="14、正则验证"></a>14、<a href="http://tool.chinaz.com/regex" target="_blank" rel="noopener">正则验证</a></h3><h3 id="15、正在代码生成"><a href="#15、正在代码生成" class="headerlink" title="15、正在代码生成"></a>15、<a href="http://tool.chinaz.com/tools/regexgenerate" target="_blank" rel="noopener">正在代码生成</a></h3><h3 id="16、时间戳转换"><a href="#16、时间戳转换" class="headerlink" title="16、时间戳转换"></a>16、<a href="http://tool.chinaz.com/Tools/unixtime.aspx" target="_blank" rel="noopener">时间戳转换</a></h3><h3 id="17、北美东部时间与北京时间换算"><a href="#17、北美东部时间与北京时间换算" class="headerlink" title="17、北美东部时间与北京时间换算"></a>17、<a href="http://tool.chinaz.com/Tools/unixtime.aspx" target="_blank" rel="noopener">北美东部时间与北京时间换算</a></h3><h3 id="18、加密解密"><a href="#18、加密解密" class="headerlink" title="18、加密解密"></a>18、<a href="http://tool.chinaz.com/tools/textencrypt.aspx" target="_blank" rel="noopener">加密解密</a></h3><h3 id="19、查看网页源代码"><a href="#19、查看网页源代码" class="headerlink" title="19、查看网页源代码"></a>19、<a href="http://s.tool.chinaz.com/tools/pagecode.aspx" target="_blank" rel="noopener">查看网页源代码</a></h3><h3 id="20、单位转换"><a href="#20、单位转换" class="headerlink" title="20、单位转换"></a>20、<a href="https://www.convertworld.com/zh-hans/" target="_blank" rel="noopener">单位转换</a></h3><h3 id="21、在线调色板"><a href="#21、在线调色板" class="headerlink" title="21、在线调色板"></a>21、<a href="http://tool.chinaz.com/Tools/OnlineColor.aspx" target="_blank" rel="noopener">在线调色板</a></h3><h3 id="22、ASCII码对照表"><a href="#22、ASCII码对照表" class="headerlink" title="22、ASCII码对照表"></a>22、<a href="http://tool.oschina.net/commons?type=4" target="_blank" rel="noopener">ASCII码对照表</a></h3><h3 id="24、HTTP状态码"><a href="#24、HTTP状态码" class="headerlink" title="24、HTTP状态码"></a>24、<a href="http://tool.oschina.net/commons?type=5" target="_blank" rel="noopener">HTTP状态码</a></h3><h3 id="25、HTTP-Content-type"><a href="#25、HTTP-Content-type" class="headerlink" title="25、HTTP Content-type"></a>25、<a href="http://tool.oschina.net/commons" target="_blank" rel="noopener">HTTP Content-type</a></h3><h3 id="26、TCP-UDP常见端口参考"><a href="#26、TCP-UDP常见端口参考" class="headerlink" title="26、TCP/UDP常见端口参考"></a>26、<a href="http://tool.oschina.net/commons?type=7" target="_blank" rel="noopener">TCP/UDP常见端口参考</a></h3><h3 id="27、HTML转义字符"><a href="#27、HTML转义字符" class="headerlink" title="27、HTML转义字符"></a>27、<a href="http://tool.oschina.net/commons?type=2" target="_blank" rel="noopener">HTML转义字符</a></h3><h3 id="28、RGB颜色对照表"><a href="#28、RGB颜色对照表" class="headerlink" title="28、RGB颜色对照表"></a>28、<a href="http://tool.oschina.net/commons?type=3" target="_blank" rel="noopener">RGB颜色对照表</a></h3><h3 id="29、对称非对称加解密算法"><a href="#29、对称非对称加解密算法" class="headerlink" title="29、对称非对称加解密算法"></a>29、<a href="http://web.chacuo.net/netrsakeypair" target="_blank" rel="noopener">对称非对称加解密算法</a></h3><h3 id="30、银行联行号查询"><a href="#30、银行联行号查询" class="headerlink" title="30、银行联行号查询"></a>30、<a href="http://lianhanghao.com/index.php" target="_blank" rel="noopener">银行联行号查询</a></h3><h3 id="31、字符生成1-字符生成2-字符生成3"><a href="#31、字符生成1-字符生成2-字符生成3" class="headerlink" title="31、字符生成1  字符生成2  字符生成3"></a>31、<a href="http://patorjk.com/software/taag" target="_blank" rel="noopener">字符生成1</a>  <a href="http://www.network-science.de/ascii/" target="_blank" rel="noopener">字符生成2</a>  <a href="http://www.degraeve.com/img2txt.w" target="_blank" rel="noopener">字符生成3</a></h3><h3 id="32、jdk1-8-api文档"><a href="#32、jdk1-8-api文档" class="headerlink" title="32、jdk1.8 api文档"></a>32、<a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">jdk1.8 api文档</a></h3><h3 id="33、a6"><a href="#33、a6" class="headerlink" title="33、a6"></a>33、<a href="http://www.a6a6.org/" target="_blank" rel="noopener">a6</a></h3><h3 id="34、身份证号码生成器"><a href="#34、身份证号码生成器" class="headerlink" title="34、身份证号码生成器"></a>34、<a href="http://www.welefen.com/lab/identify" target="_blank" rel="noopener">身份证号码生成器</a></h3><h3 id="35、NIO入门，讲的超级好"><a href="#35、NIO入门，讲的超级好" class="headerlink" title="35、NIO入门，讲的超级好"></a>35、<a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">NIO入门，讲的超级好</a></h3><h3 id="36、不死鸟-分享为王"><a href="#36、不死鸟-分享为王" class="headerlink" title="36、不死鸟,分享为王"></a>36、<a href="https://lai.yuweining.cn/" target="_blank" rel="noopener">不死鸟,分享为王</a></h3><h3 id="37、分享-GitHub-上有趣、入门级的开源项目"><a href="#37、分享-GitHub-上有趣、入门级的开源项目" class="headerlink" title="37、分享 GitHub 上有趣、入门级的开源项目"></a>37、<a href="https://hellogithub.com/" target="_blank" rel="noopener">分享 GitHub 上有趣、入门级的开源项目</a></h3><h3 id="38、斗图网"><a href="#38、斗图网" class="headerlink" title="38、斗图网"></a>38、<a href="https://www.doutula.com/" target="_blank" rel="noopener">斗图网</a></h3><h3 id="39、在线电子书柜"><a href="#39、在线电子书柜" class="headerlink" title="39、在线电子书柜"></a>39、<a href="https://love2.io/" target="_blank" rel="noopener">在线电子书柜</a></h3><h3 id="40、mybatis-3中文文档"><a href="#40、mybatis-3中文文档" class="headerlink" title="40、mybatis-3中文文档"></a>40、<a href="http://www.mybatis.org/mybatis-3/zh/java-api.html" target="_blank" rel="noopener">mybatis-3中文文档</a></h3><h3 id="41、Hexo文档"><a href="#41、Hexo文档" class="headerlink" title="41、Hexo文档"></a>41、<a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">Hexo文档</a></h3>]]></content>
    
    <summary type="html">
    
      常用工具地址存档，方便使用
    
    </summary>
    
      <category term="常用工具" scheme="http://xym-loveit.github.io/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="常用工具" scheme="http://xym-loveit.github.io/tags/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>redis入门指南之管理</title>
    <link href="http://xym-loveit.github.io/2017/06/09/redis%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E4%B9%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://xym-loveit.github.io/2017/06/09/redis入门指南之管理/</id>
    <published>2017-06-09T09:22:22.000Z</published>
    <updated>2018-03-29T01:27:48.646Z</updated>
    
    <content type="html"><![CDATA[<h6 id="重要星级-★★★"><a href="#重要星级-★★★" class="headerlink" title="重要星级 ★★★"></a>重要星级 ★★★</h6><hr><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>Redis的作者Salvatore Sanfilippo曾经发表过Redis宣言，其中提到了Redis以简洁为美。同样在安全层面Redis也没有做太多的工作。  </p><h3 id="1、可信的环境"><a href="#1、可信的环境" class="headerlink" title="1、可信的环境"></a>1、可信的环境</h3><p>Redis的安全设计是在“Redis运行在可信环境”这个前提下做出的。在生产环境运行时不能允许外界直接连接到Redis服务器上，而应该通过应用程序进行中转，运行在可信的环境中是保证Redis安全的最重要方法。<br>Redis的默认配置会接受来自任何地址发送来的请求，即在任何一个拥有公网IP的服务器上启动Redis服务器，都可以被外界直接访问到。要更改这一设置，在配置文件中修改bind参数，如只允许本机应用连接Redis，可以将bind参数改成：  </p><pre><code>bind 127.0.0.1</code></pre><p>如果想要绑定多个地址，中间采用空格隔开，配置多个即可。  </p><pre><code>bind 127.0.0.1 192.168.100.238</code></pre><h3 id="2、数据库密码"><a href="#2、数据库密码" class="headerlink" title="2、数据库密码"></a>2、数据库密码</h3><p>除此之外，还可以通过配置文件中的<code>requirepass</code>参数为Redis设置一个密码。例如：  </p><pre><code>requirepass 12345678</code></pre><p>客户端每次连接到Redis时都需要发送密码，否则Redis会拒绝执行客户端发来的命令。<br>例如：  </p><pre><code>127.0.0.1:6379&gt; info defaultNOAUTH Authentication required.127.0.0.1:6379&gt; keys *(error) NOAUTH Authentication required.</code></pre><p>发送密码需要使用AUTH命令，就像这样：  </p><pre><code>127.0.0.1:6379&gt; auth 123456OK127.0.0.1:6379&gt; client listid=145 addr=127.0.0.1:55057 fd=5 name= age=9 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free=32768 obl=0 oll=0 omem=0 events=r cmd=client</code></pre><p>由于Redis的性能极高，并且输入错误密码后Redis并不会进行主动延迟（考虑到Redis的单线程模型），所以攻击者可以通过穷举法破解Redis的密码，因此设置密码时一定要选择复杂的密码。<br><strong>提示：配置Redis复制的时候如果主数据库设置了密码，需要在从数据库的配置文件中通过masterauth参数设置主数据库的密码，以使从数据库连接主数据库时自动使用AUTH命令认证。</strong>  </p><h3 id="3、重命名命令"><a href="#3、重命名命令" class="headerlink" title="3、重命名命令"></a>3、重命名命令</h3><p>Redis支持在配置文件中将命令重命名，比如将FLUSHALL 命令重命名成一个比较复杂的名字，以保证只有自己的应用可以使用该命令。就像下面这样：  </p><pre><code>rename-command FLUSHALL QKSYSJK</code></pre><p>如果希望直接禁用某个命令可以将命令重命名成空字符串：  </p><pre><code>rename-command FLUSHALL &quot;&quot;</code></pre><p>无论设置密码还是重命名命令，都需要保证配置文件的安全性，否则就没有任何意义了。  </p><h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><p>Redis通信协议是Redis客户端与Redis之间交流的语言，通信协议规定了命令和返回值的格式。了解Redis通信协议后不仅可以理解AOF文件的格式和主从复制时主数据库向从数据库发送的内容等，还可以开发自己的客户端。<br>Redis支持两种通信协议，一种是二进制安全的统一请求协议（unified request protocol），另一种是比较直观的便于在telnet程序中输入的简单协议。这两种协议只是命令格式有区别，命令返回值的格式是一样的。  </p><h3 id="1、简单协议"><a href="#1、简单协议" class="headerlink" title="1、简单协议"></a>1、简单协议</h3><p>简单协议适合在telnet程序中和Redis通信。简单协议的命令格式就是将命令和各个参数使用空格分隔开，如“EXISTS foo ”、“SET foo bar”等。由于Redis解析简单协议时只是简单地以空格分隔参数，所以无法输入二进制字符。我们可以通过telnet程序测试：  </p><pre><code>[admin@KFCS2 redis-stable]$ telnet  127.0.0.1 6379Trying 127.0.0.1...Connected to 127.0.0.1.Escape character is &apos;^]&apos;.set foo bar-NOAUTH Authentication required.auth 123456+OKset foo bar +OKget foo$3barlpush plist 1 2 3          :3lrange plist 0 -1*3$13$12$11errorcommand-ERR unknown command &apos;errorcommand&apos;</code></pre><p>我们在telnet程序中输入的5条命令恰好展示了Redis5种返回类型的格式，上面章节介绍了这5种返回值类型在redis-cli中的展现形式，这些展现形式是经过了redis-cli封装的，而上面的内容才是Redis真正返回的格式。下面分别介绍。<br>1、错误回复<br>错误回复（error reply）以-开头，并在后面跟上错误信息，最后以\r\n结尾：<br>-ERR unknown command ‘errorcommand’\r\n</p><p>2、状态回复<br>状态回复（status reply）以+开头，并在后面跟上状态信息，最后以\r\n结尾：<br>+OK\r\n</p><p>3、整数回复<br>整数回复（integer reply）以：开头，并在后面跟上数字，最后以\r\n结尾：<br>:3\r\n</p><p>4、字符串回复<br>字符串回复（bulk reply）以$开头，并在后面跟上字符串的长度，并以以\r\n分隔，接着是字符串的内容和\r\n：<br>$3\r\nbar\r\n<br>如果返回值是空结果nil，则会返回$-1以和空字符串相区别。</p><p>5、多行字符串回复<br>多行字符串回复（multi-bulk reply）以<em>开头，并在后面跟上字符串回复的组数，并以\r\n分隔。接着后面跟的就是字符串回复的具体内容了：  </em>3\r\n$1\r\n3\r\n$1\r\n2\r\n$1\r\n1\r\n</p><h3 id="2、统一请求协议"><a href="#2、统一请求协议" class="headerlink" title="2、统一请求协议"></a>2、统一请求协议</h3><p>统一请求协议是从Redis1.2开始加入的，其命令格式和多行字符串回复的格式很类似，如 SET foo bar 的统一请求协议写法是*3\r\n$3\r\nSET\r\n$3\r\nfoo\r\n$3\r\nbar\r\n。还是使用telnet进行演示：  </p><pre><code>[admin@KFCS2 redis-stable]$ telnet  127.0.0.1 6379Trying 127.0.0.1...Connected to 127.0.0.1.Escape character is &apos;^]&apos;.*3$3  SET$3    foo$3bar-NOAUTH Authentication required.auth 123456+OK</code></pre><p>同样发送命令时指定了后面字符串的长度，所以命令的每个参数都可以包含二进制的字符。统一请求协议的返回值格式和简单协议一样。<br>Redis的AOF文件和主从复制时主数据库向从数据库发送的内容都是用了统一请求协议。如果要开发一个和Redis直接通信的客户端，推荐使用此协议。如果只是想通过telnet向Redis服务器发送命令则使用简单协议就可以了。  </p><h2 id="管理工具"><a href="#管理工具" class="headerlink" title="管理工具"></a>管理工具</h2><p>工欲善其事必先利其器。在使用Redis的时候如果能够有效利用Redis的各种管理工具，将会大大方便开发和管理。  </p><h3 id="1、redis-cli"><a href="#1、redis-cli" class="headerlink" title="1、redis-cli"></a>1、redis-cli</h3><p>作为Redis自带的命令行客户端，你可以从任何安装有Redis的服务器中找到它，所以对于管理Redis而言redis-cli是最简单实用的工具。<br>redis-cli可以执行大部分的Redis命令，包括查看数据库信息的INFO命令，更改数据库设置的CONFIG命令和强制进行RDB快照的SAVE命令等。下面介绍几个管理Redis时非常有用的命令。<br>1、耗时命令日志<br>当一条命令执行时间超时限制时，Redis会将该命令的执行时间等信息加入耗时命令日志（slow log）以供开发者查看。可以通过配置文件<code>slowlog-log-slower-than</code> 参数设置这一限制，要注意单位是微妙（1000 000微妙相当于1秒），默认值是10 000。耗时命令日志存储在内存中，可以通过配置文件的<code>slowlog-max-len</code>参数来限制记录的条数。为了产生一些耗时命令日志作为演示，这里将<code>slowlog-log-slower-than</code>参数值设置为0，即记录所有命令。如果设置为负数则会关闭耗时命令日志。如：  </p><pre><code>127.0.0.1:6379&gt; slowlog get 1) 1) (integer) 16    2) (integer) 1497011605    3) (integer) 52    4) 1) &quot;set&quot;       2) &quot;foo&quot;       3) &quot;bar&quot; 2) 1) (integer) 15    2) (integer) 1497011599    3) (integer) 6    4) 1) &quot;get&quot;       2) &quot;foo&quot;</code></pre><p>每条日志都由以下4个部分组成：<br>（1）改日志唯一ID<br>（2）改命令执行的UNIX时间<br>（3）改命令的耗时时间，单位是微妙<br>（4）命令及其参数  </p><p>2、命令监控<br>Redis提供了MONITOR命令来监控Redis执行的所有命令，redis-cli同样支持这个命令，如在redis-cli中执行MONITOR： </p><pre><code>127.0.0.1:6379&gt; monitorOK</code></pre><p>这时Redis执行的任何命令都会在redis-cli中打印出来，如我们打开另一个redis-cli执行SET foo bar命令，在之前的redis-cli中会输出如下内容：  </p><pre><code>1497012041.878429 [0 127.0.0.1:55062] &quot;auth&quot; &quot;123456&quot;1497012053.311366 [0 127.0.0.1:55062] &quot;set&quot; &quot;foo&quot; &quot;bar&quot;</code></pre><p>MONITOR命令非常影响Redis的性能，一个客户端使用MONITOR命令会降低Redis将近一半的负载能力。所以MONITOR命令只适合用来调试和纠错。</p><h3 id="2、采用phpRedisAdmin"><a href="#2、采用phpRedisAdmin" class="headerlink" title="2、采用phpRedisAdmin"></a>2、采用phpRedisAdmin</h3><p>Redis有一款使用PHP开发的网页管理工具phpRedisAdmin。phpRedisAdmin支持以树结构查看键列表，编辑键值，导入/导出数据库数据，查看数据库信息和查看键信息等功能。  </p><h3 id="3、Rdbtools"><a href="#3、Rdbtools" class="headerlink" title="3、Rdbtools"></a>3、Rdbtools</h3><p>Rdbtools是一个Redis快照文件解析器，它可以根据快照文件导出JSON数据文件、分析Redis中每个键的占用空间情况等。</p>]]></content>
    
    <summary type="html">
    
      Redis管理知识，包括协议和安全等内容，及其第三方管理工具。
    
    </summary>
    
      <category term="redis系列" scheme="http://xym-loveit.github.io/categories/redis%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="redis安全" scheme="http://xym-loveit.github.io/tags/redis%E5%AE%89%E5%85%A8/"/>
    
      <category term="redis数据库密码" scheme="http://xym-loveit.github.io/tags/redis%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%86%E7%A0%81/"/>
    
      <category term="redis命令重命名" scheme="http://xym-loveit.github.io/tags/redis%E5%91%BD%E4%BB%A4%E9%87%8D%E5%91%BD%E5%90%8D/"/>
    
      <category term="redis通信协议" scheme="http://xym-loveit.github.io/tags/redis%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
      <category term="redis管理工具" scheme="http://xym-loveit.github.io/tags/redis%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>redis入门指南之集群</title>
    <link href="http://xym-loveit.github.io/2017/06/05/redis%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E4%B9%8B%E9%9B%86%E7%BE%A4/"/>
    <id>http://xym-loveit.github.io/2017/06/05/redis入门指南之集群/</id>
    <published>2017-06-05T13:05:02.000Z</published>
    <updated>2018-03-29T01:27:48.647Z</updated>
    
    <content type="html"><![CDATA[<h6 id="重要星级-★★★★★"><a href="#重要星级-★★★★★" class="headerlink" title="重要星级 ★★★★★"></a>重要星级 ★★★★★</h6><hr><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>即使使用哨兵，此时的Redis集群的每个数据库依然存有集群中的所有数据，从而导致集群的总数据存储量受限于可用存储内存最小的数据库节点，形成木桶效应。由于Redis中的所有数据都是基于内存存储，这一问题就尤为突出了，尤其是当使用Redis做了持久化存储服务使用时。<br>对Redis进行水平扩容，在旧版Redis中通常使用客户端分片来解决这个问题，即启动多个Redis数据库节点，由客户端决定每个键交由哪个数据库节点存储，下次客户端读取该键值时直接到该节点读取。这样可以实现将整个数据分布存储在N个数据库节点中，每个节点只存放总数据量的1/N。但对于需要扩容的场景来说，在客户端分片后，如果想增加更多的节点，就需要对数据进行手工迁移，同时在迁移的过程中为了保证数据的一致性，还需要将集群暂时下线，相对比较复杂。<br>考虑到Redis实例非常轻量的特点，可以采用预分片技术（presharding）来在一定程度上避免此问题，具体来说是在节点部署初期，就提前考虑日后的存储规模，建立足够多的实例（如128个节点），初期数据很少，所以每个节点存储的数据也非常少，但由于节点轻量的特性，数据之外的内存开销并不大，这使得只需要很少的服务器即可运行这些实例。日后存储规模扩大后，所要做的不过是将某些实例迁移到其他服务器上，而不需要对所有数据进行重新分片并进行集群下线和数据迁移了。<br>无论如何，客户端分片终归是有非常多的缺点，比如维护成本高，增加、移除节点较繁琐等。Redis3.0版的一大特性就是支持集群（Cluster，注意与本章标题–广义的“集群”相区别）功能。集群的特点在于拥有和单机实例同样的性能，同时在网络分区后能够提供一定的可访问性以及对主数据库故障恢复的支持。另外集群支持几乎所有的单机实例支持的命令，对于涉及多键的命令（如MGET），如果每个键都位于同一个节点中，则可以正常支持，否则会提示错误。除此之外集群还有一个限制是只能使用默认的0号数据库，如果执行SELECT切换数据库则会提示错误。<br>哨兵与集群是两个独立的功能，但从特性来看哨兵可以视为集群的子集，当不需要数据分片或者已经在客户端进行分片的场景下哨兵就足够使用了，但如果需要进行水平扩容，则集群是一个非常好的选择。  </p><h3 id="1、配置集群"><a href="#1、配置集群" class="headerlink" title="1、配置集群"></a>1、配置集群</h3><p>使用集群，只需要将每个数据库节点的cluster-enabled配置选项打开即可。每个集群中至少需要3个主数据库才能正常运行。<br>为了演示集群的应用场景以及故障恢复等操作，这里以配置一个3主3从的集群系统为例。首先建立启动6个Redis实例，需要注意的是配置文件应该打开cluster-enabled。一个示例配置为：  </p><pre><code>port 6380cluster-enabled yes  </code></pre><p>其中port参数修改成实际的端口即可。这里假设6个实例的端口分别是6380、6381、6382、6383、6384和6385。集群会将当前节点记录的集群状态持久化地存储在指定文件中，这个文件默认为当前工作目录下的nodes.conf文件。每个节点对应的文件必须不同，否则会造成启动失败，所以启动节点时要注意最后为每个节点使用不同的工作目录，或者是通过cluster-config-file选项修改持久化文件的名称：  </p><pre><code>cluster-config-file nodes.conf  </code></pre><p>启动后，可以使用Redis命令行客户端连接任意一个节点使用INFO命令来判断集群是否正常启用了：  </p><pre><code>192.168.100.238:6381&gt; info cluster# Clustercluster_enabled:1</code></pre><p>其中cluster_enabled为1表示集群正常启用了。现在每个节点都是完全独立的，要将它们加入同一个集群中还需要几个步骤。Redis源代码中提供了一个辅助工具redis-trib.rb可以非常方便地完成这一任务。因为redis-trib.rb使用Ruby语言编写的，所以运行前需要在服务器上安装Ruby程序，具体安装方法请查阅相关文档。redis-trib.rb依赖于gem包redis，可执行gem install redis来安装。使用redis-trib.rb来初始化集群，只需要执行：  </p><pre><code>[admin@KFCS3 redis-stable_01]$ ./src/redis-trib.rb create --replicas 1 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 127.0.0.1:6385</code></pre><p>其中create参数表示要初始化集群，–replicas 1表示每个主数据库拥有的从数据库个数为1，所以集群共有3（6/2）个主数据库以及3个从数据库。执行完成后，redis-trib.rb会输出如下内容：  </p><pre><code>--未执行集群时&gt;&gt;&gt; Creating cluster&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...Using 3 masters:127.0.0.1:6380127.0.0.1:6381127.0.0.1:6382Adding replica 127.0.0.1:6383 to 127.0.0.1:6380Adding replica 127.0.0.1:6384 to 127.0.0.1:6381Adding replica 127.0.0.1:6385 to 127.0.0.1:6382M: bec0f2a8743b6636cf53cd5611137dd9a5ee72f3 127.0.0.1:6380   slots:0-5460 (5461 slots) masterM: a24810378b2ee15efbbef8bbf285872198ef6902 127.0.0.1:6381   slots:5461-10922 (5462 slots) masterM: e18b9946f5c4db8b170b395a6de8204ab56237f9 127.0.0.1:6382   slots:10923-16383 (5461 slots) masterS: 50c78a069f7d4a052d0f3e4c83083e6279b49acb 127.0.0.1:6383   replicates bec0f2a8743b6636cf53cd5611137dd9a5ee72f3S: 6054c3053a0f50a9b8f6dc2e9134d6b1ce25e90c 127.0.0.1:6384   replicates a24810378b2ee15efbbef8bbf285872198ef6902S: 4c9ec5e346ac451d6d44df4d817112fdac3f6da6 127.0.0.1:6385   replicates e18b9946f5c4db8b170b395a6de8204ab56237f9Can I set the above configuration? (type &apos;yes&apos; to accept): yes--已执行过集群后[admin@KFCS3 redis-stable]$ ./src/redis-trib.rb create --replicas 1 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 127.0.0.1:6385&gt;&gt;&gt; Creating cluster[ERR] Node 127.0.0.1:6382 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0.</code></pre><p>上实例2表示节点已分配插槽。上例1输出内容包括集群具体的分配方案，如果觉得没问题则输入yes来开始创建。下面根据上面的输出详细讲解集群创建的过程。<br>首先redis-trib.rb会以客户端的形式尝试连接所有节点，并发送PING命令以确定节点能够正常服务。如果有任何节点无法连接，则创建失败。同时发送INFO命令获取每个节点的运行ID以及是否开启了集群功能（即cluster_enabled为1）。<br>准备就绪后集群会向每个节点发送CLUSTER MEET 命令，格式为CLUSTER MEET ip port，这个命令用来告诉当前节点指定ip和port上在运行的节点也是集群的的一部分，从而使得6个节点最终可以纳入一个集群。<br>然后redis-trib.rb会分配主从数据库节点，分配的原则是尽量保证每个主数据库运行在不同的IP地址上，同时每个从数据库和主数据库均不运行在同一个IP地址上，以保证系统的容灾能力。分配结果如下：  </p><pre><code>Using 3 masters:127.0.0.1:6380127.0.0.1:6381127.0.0.1:6382Adding replica 127.0.0.1:6383 to 127.0.0.1:6380Adding replica 127.0.0.1:6384 to 127.0.0.1:6381Adding replica 127.0.0.1:6385 to 127.0.0.1:6382</code></pre><p>其中主数据库是6380、6381和6382端口上的节点（以下使用端口来指代节点），6383是6380的从数据库，6384是6381的从数据库，6385是6382的从数据库。分配完成后，会为每个主数据库分配插槽，分配插槽的过程其实就是分配哪些键归哪些节点负责。之后对每个要成为子数据库的节点发送CLUSTER REPLICATE 主数据库的运行ID 来讲当前节点转换成从数据库并复制指定运行ID的节点（主数据库）。<br>此时整个集群的过程即创建完毕，使用Redis命令行客户端连接任意一个节点执行CLUSTER NODES 可以获得集群中的所有节点信息，如在6380执行：  </p><pre><code>127.0.0.1:6380&gt; cluster nodes50c78a069f7d4a052d0f3e4c83083e6279b49acb 127.0.0.1:6383 slave bec0f2a8743b6636cf53cd5611137dd9a5ee72f3 0 1496677290597 4 connectede18b9946f5c4db8b170b395a6de8204ab56237f9 127.0.0.1:6382 master - 0 1496677293602 3 connected 10923-163836054c3053a0f50a9b8f6dc2e9134d6b1ce25e90c 127.0.0.1:6384 slave a24810378b2ee15efbbef8bbf285872198ef6902 0 1496677294603 5 connectedbec0f2a8743b6636cf53cd5611137dd9a5ee72f3 127.0.0.1:6380 myself,master - 0 0 1 connected 0-54604c9ec5e346ac451d6d44df4d817112fdac3f6da6 127.0.0.1:6385 slave e18b9946f5c4db8b170b395a6de8204ab56237f9 0 1496677292600 6 connecteda24810378b2ee15efbbef8bbf285872198ef6902 127.0.0.1:6381 master - 0 1496677295605 2 connected 5461-10922</code></pre><p>从上面的输出中可以看到所有节点的运行ID、地址和端口、角色、状态以及负责的插槽等信息，后文会进行解读。redis-trib.rb是一个非常好用的辅助工具，其本质是通过执行Redis命令来实现集群管理的任务。如果有兴趣可以尝试不借助redis-trib.rb，手动建立一次集群。      </p><h3 id="2、节点的增加"><a href="#2、节点的增加" class="headerlink" title="2、节点的增加"></a>2、节点的增加</h3><p> 前面介绍过redis-trib.rb是使用CLUSTER MEET 命令来使每个节点认识集群中的其他节点的，可想而知如果要向集群中加入新节点，也需要使用CLUSTER MEET 命令实现。加入新节点非常简单，只需要向新节点（以下记着A）发送如下命令:  </p><pre><code>CLUSTER MEET ip port  </code></pre><p>ip和port是集群中任意一个节点的地址和端口号，A接受到客户端发来的命令后，会与该地址和端口号的节点B进行握手，使B将A认作当前集群中的一员。当B与A握手成功后，B会使用Gossip协议将节点A的信息通知给集群中的每一个节点。通过这一方式，即使集群中有多个节点，也只需要选择MEET 其中任意一个节点，即可使新节点最终加入整个集群。  </p><h3 id="3、插槽的分配"><a href="#3、插槽的分配" class="headerlink" title="3、插槽的分配"></a>3、插槽的分配</h3><p>新的节点加入集群后有两种选择，要么使用CLUSTER REPLICATE 命令复制每个数据库来以从数据库的形式运行，要么向集群申请分配插槽（solt）来以主数据库的形式运行。在一个集群中，所有的键会被分配给16384个插槽，而每个主数据库会负责处理其中的一部分插槽。现在回头来看上面创建集群时的输出：  </p><pre><code>M: bec0f2a8743b6636cf53cd5611137dd9a5ee72f3 127.0.0.1:6380   slots:0-5460 (5461 slots) masterM: a24810378b2ee15efbbef8bbf285872198ef6902 127.0.0.1:6381   slots:5461-10922 (5462 slots) masterM: e18b9946f5c4db8b170b395a6de8204ab56237f9 127.0.0.1:6382   slots:10923-16383 (5461 slots) master</code></pre><p>上面的每一行表示一个主数据库的信息，其中可以看到6380负责处理0~5460折5461个插槽，6381负责处理5461~10922这5462个插槽，6382负责处理10923~16383这5461个插槽。虽然redis-trib.rb初始化集群分配给每个节点的插槽都是连续的，但是实际上Redis并没有限制，可以将任意的几个插槽分配给任意的节点负责。<br>在介绍如何将插槽分配给指定的节点前，先来介绍键和插槽的对应关系。Redis将每个键的键名的有效部分使用CRC16算法计算出散列值，然后取对16384的余数。这样使得每个键都可以分配到16384个插槽中，进而分配的指定的一个节点中处理。这里键名的有效部分是指：<br>（1）如果键名包含{符号，且在{符合后面存在}符号，并且{和}之间有至少一个字符，则有效部分是指{和}之间的内容。<br>（2）如果不满足上一条规则，那么整个键名为有效部分。<br>例如，键hello.world的有效部分为“hello.world”，键{user102}:last.name的有效部分为“user102”。如本节引言所说，如果命令涉及多个键（如MGET），只有当所有键都位于同一个节点时Redis才能正常支持。利用键的分配规则，可以将所有相关的键的有效部分设置成相同的值使得相关键都能分配到同一个节点以支持多键操作。比如，{user102}:first.name和{user102}:last.name会被分配到同一个节点，所以可以使用MGET {user102}:first.name {user102}:last.name 来同时获取两个键的值。介绍完键与插槽的对应关系后，接下来再来介绍如何将插槽分配给指定节点。插槽的分配分为如下几种情况。<br>（1）插槽之前没有被分配过，现在想分配给指定节点。<br>（2）插槽之前被分配过，现在想移动到指定节点。<br>其中第一种情况使用CLUSTER ADDSLOTS命令来实现，redis-trib.rb也是通过该命令在创建集群时为新节点分配插槽的。<strong>CLUSTER ADDSLOTS</strong>命令的用法为：  </p><pre><code>CLUSTER ADDSLOTS  slot1 [slot2] ... [slotN]</code></pre><p>如想将100和101两个插槽分配给某个节点，只需要在该节点执行：CLUSTER ADDSLOTS 100 101即可。如果指定插槽已经分配过了，则会提示：  </p><pre><code>127.0.0.1:6380&gt; cluster addslots 100 101(error) ERR Slot 100 is already busy  </code></pre><p>可以通过命令 <strong>CLUSTER SLOTS</strong> 来查看插槽分配情况，如：  </p><pre><code>127.0.0.1:6380&gt; cluster slots1) 1) (integer) 10923   2) (integer) 16383   3) 1) &quot;127.0.0.1&quot;      2) (integer) 6382      3) &quot;e18b9946f5c4db8b170b395a6de8204ab56237f9&quot;   4) 1) &quot;127.0.0.1&quot;      2) (integer) 6385      3) &quot;4c9ec5e346ac451d6d44df4d817112fdac3f6da6&quot;2) 1) (integer) 0   2) (integer) 5460   3) 1) &quot;127.0.0.1&quot;      2) (integer) 6380      3) &quot;bec0f2a8743b6636cf53cd5611137dd9a5ee72f3&quot;   4) 1) &quot;127.0.0.1&quot;      2) (integer) 6383      3) &quot;50c78a069f7d4a052d0f3e4c83083e6279b49acb&quot;3) 1) (integer) 5461   2) (integer) 10922   3) 1) &quot;127.0.0.1&quot;      2) (integer) 6381      3) &quot;a24810378b2ee15efbbef8bbf285872198ef6902&quot;   4) 1) &quot;127.0.0.1&quot;      2) (integer) 6384      3) &quot;6054c3053a0f50a9b8f6dc2e9134d6b1ce25e90c&quot;  </code></pre><p>其中返回结果的格式很容易理解，一共3条记录，每条记录的前两个表示插槽的开始号码和结束号码，后面的值则为负责该插槽的节点，包括主数据库和所有的从数据库，主数据库始终在第一位。<br>对于情况2，处理起来就相对复杂一些，不过redis-trib.rb提供了比较方便的方式来对插槽进行迁移。我们首先使用redis-trib.rb将一个插槽从6380迁移到6381，然后再介绍如何不使用redis-trib.rb来完成迁移。首先执行如下命令：  </p><pre><code>[admin@KFCS3 redis-stable_01]$ ./src/redis-trib.rb reshard 127.0.0.1:6380</code></pre><p>其中reshard表示告诉redis-trib.rb要重新分片，127.0.0.1:6380是集群中任意一个节点的地址和端口，redis-trib.rb会自动获取集群信息。接下来redis-trib.rb将会询问具体如何进行重新分片，首先会询问想要迁移多少个插槽：  </p><pre><code>How many slots do you want to move (from 1 to 16384)?</code></pre><p>我们只需要迁移一个，所以输入1后回车。接下来redis-trib.rb会询问要把插槽迁移到哪个节点： </p><pre><code>How many slots do you want to move (from 1 to 16384)? 1What is the receiving node ID? </code></pre><p>可以通过<strong>CLUSTER NODES</strong>命令获取6381的运行ID,这里是a24810378b2ee15efbbef8bbf285872198ef6902，输入并回车。接着最后异步是询问从那个节点移除插槽：  </p><pre><code>What is the receiving node ID? a24810378b2ee15efbbef8bbf285872198ef6902Please enter all the source node IDs.  Type &apos;all&apos; to use all the nodes as source nodes for the hash slots.  Type &apos;done&apos; once you entered all the source nodes IDs.Source node #1:all</code></pre><p>我们输入6380对应的ID按回车后输入done再按回车确认即可。接下来输入yes来确认重新分片方案，重新分片即告成功。</p><pre><code>Ready to move 1 slots.  Source nodes:    M: bec0f2a8743b6636cf53cd5611137dd9a5ee72f3 127.0.0.1:6380   slots:0-5460 (5461 slots) master   1 additional replica(s)    M: e18b9946f5c4db8b170b395a6de8204ab56237f9 127.0.0.1:6382   slots:10923-16383 (5461 slots) master   1 additional replica(s)  Destination node:    M: a24810378b2ee15efbbef8bbf285872198ef6902 127.0.0.1:6381   slots:5461-10922 (5462 slots) master   1 additional replica(s)  Resharding plan:    Moving slot 0 from bec0f2a8743b6636cf53cd5611137dd9a5ee72f3Do you want to proceed with the proposed reshard plan (yes/no)? yesMoving slot 0 from 127.0.0.1:6380 to 127.0.0.1:6381:</code></pre><p>使用<strong>CLUSTER SLOTS</strong>命令获取当前插槽的分配情况如下：  </p><pre><code>127.0.0.1:6380&gt; cluster slots1) 1) (integer) 10923   2) (integer) 16383   3) 1) &quot;127.0.0.1&quot;      2) (integer) 6382      3) &quot;e18b9946f5c4db8b170b395a6de8204ab56237f9&quot;   4) 1) &quot;127.0.0.1&quot;      2) (integer) 6385      3) &quot;4c9ec5e346ac451d6d44df4d817112fdac3f6da6&quot;2) 1) (integer) 1   2) (integer) 5460   3) 1) &quot;127.0.0.1&quot;      2) (integer) 6380      3) &quot;bec0f2a8743b6636cf53cd5611137dd9a5ee72f3&quot;   4) 1) &quot;127.0.0.1&quot;      2) (integer) 6383      3) &quot;50c78a069f7d4a052d0f3e4c83083e6279b49acb&quot;3) 1) (integer) 0--多出来的第0号插槽   2) (integer) 0   3) 1) &quot;127.0.0.1&quot;      2) (integer) 6381      3) &quot;a24810378b2ee15efbbef8bbf285872198ef6902&quot;   4) 1) &quot;127.0.0.1&quot;      2) (integer) 6384      3) &quot;6054c3053a0f50a9b8f6dc2e9134d6b1ce25e90c&quot;4) 1) (integer) 5461   2) (integer) 10922   3) 1) &quot;127.0.0.1&quot;      2) (integer) 6381      3) &quot;a24810378b2ee15efbbef8bbf285872198ef6902&quot;   4) 1) &quot;127.0.0.1&quot;      2) (integer) 6384      3) &quot;6054c3053a0f50a9b8f6dc2e9134d6b1ce25e90c&quot;</code></pre><p>可以看到现在比之前多了一条记录，第0号插槽已经有6381负责，此时重新分片成功。那么redis-trib.rb实现重新分片的原理是什么呢？我们不妨不借助redis-trib.rb手工进行重新分片，使用如下命令即可：  </p><pre><code>CLUSTER SETSLOTS 插槽号 NODE 新节点的运行ID</code></pre><p>如想要把0号插槽迁移回6380：  </p><pre><code>127.0.0.1:6380&gt; cluster nodes50c78a069f7d4a052d0f3e4c83083e6279b49acb 127.0.0.1:6383 slave bec0f2a8743b6636cf53cd5611137dd9a5ee72f3 0 1496714712675 4 connectede18b9946f5c4db8b170b395a6de8204ab56237f9 127.0.0.1:6382 master - 0 1496714710672 3 connected 10923-163836054c3053a0f50a9b8f6dc2e9134d6b1ce25e90c 127.0.0.1:6384 slave a24810378b2ee15efbbef8bbf285872198ef6902 0 1496714711674 7 connectedbec0f2a8743b6636cf53cd5611137dd9a5ee72f3 127.0.0.1:6380 myself,master - 0 0 1 connected 1-54604c9ec5e346ac451d6d44df4d817112fdac3f6da6 127.0.0.1:6385 slave e18b9946f5c4db8b170b395a6de8204ab56237f9 0 1496714710172 6 connecteda24810378b2ee15efbbef8bbf285872198ef6902 127.0.0.1:6381 master - 0 1496714706668 7 connected 0 5461-10922127.0.0.1:6380&gt; cluster setslot 0 node bec0f2a8743b6636cf53cd5611137dd9a5ee72f3OK</code></pre><p>此时重新使用CLUSTER SLOTS 查看插槽的分配情况，可以看到已经恢复如初了。然而这样迁移插槽的前提是插槽中并没有任何键，因为使用CLUSTER SETSLOT 命令迁移插槽时并不会连同相应的键一起迁移，这就造成了客户端在指定节点无法找到未迁移的键，造成这些键对客户端来说“丢失了”，为此需要手工获取插槽中存储在哪些键，然后将每个键迁移到新的节点中才行。手工获取某个插槽存在哪些键的方法是：  </p><pre><code>CLUSTER GETKEYSINSLOT 插槽号 要返回的键的数量</code></pre><p>之后对每个键，使用MIGRATE命令将其迁移到目标节点：  </p><pre><code>MIGRATE 目标节点地址 目标节点端口 键名 数据库号码 超时时间 [COPY] [REPLACE]</code></pre><p>其中COPY选项表示不将键从当前数据库中删除，而是复制一份副本。REPLACE表示如果目标节点存在同名键，则覆盖。因为集群模式只能使用0号数据库，所以数据库号码始终未0。如要把键abc从当前节点（如6381）迁移到6380：  </p><pre><code>MIGRATE 127.0.0.1 127.0.0.1 6380 abc 0 15999 REPLACE</code></pre><p>至此，我们已经知道如果将插槽委派给其他节点，并同时将当前节点中的插槽下所有的键迁移到目标节点中。然而还有最后一个是如果要迁移的数据量比较大，整个过程会话费较长时间，那么究竟在什么时候执行 CLUSTER SETSLOT 命令来完成插槽的交接呢？如果在键迁移未完成时执行，那么客户端就会尝试在新的节点读取键值，此时还没迁移完成，自然有可能读取不到键值，从而造成相关键的临时“丢失”。相反，如果在键迁移完成后在执行，那么在迁移时客户端会在旧的节点读取键值，然后有些键已经迁移到新节点上了，同样也会造成键的临时“丢失”。那么redis-trib.rb工具是如何解决这个问题的呢？Redis提供了如下两个命令用来实现在集群不下线的情况下迁移数据：  </p><pre><code>CLUSTER SETSLOT 插槽号 MIGRATING 新节点的运行IDCLUSTER SETSLOT 插槽号 IMPORTING 原节点的运行ID</code></pre><p>进行迁移时，假设要把0号插槽从A迁移到B，此时redis-trib.rb会依次执行如下操作。<br>（1）在B执行CLUSTER SETSLOT 0 IMPORTING A。<br>（2）在A执行CLUSTER SETSLOT 0 MIGRATING B。<br>（3）执行CLUSTER GETKEYSINSLOT 0 获取0号插槽的键列表。<br>（4）对第3步获取的每个键执行MIGRATE命令，将其从A迁移到B。<br>（5）执行CLUSTER SETSLOT 0 NODE B 来完成迁移。<br>从上面的步骤来看redis-trib.rb多了1和2两个步骤，这两个步骤就是为了解决迁移过程中键的临时“丢失”问题。首先执行完前两步后，当客户端向A请求插槽0中的键时，如果键存在（即尚未被迁移），则正常处理，如果不存在，则返回一个ASK跳转请求，告诉客户端这个键在B里，如下图所示，客户端接受到ASK跳转请求后，首先向B发送ASKING命令，然后再重新发送之前的命令。  </p><p><img src="http://op7wplti1.bkt.clouddn.com/askA.png" alt="客户端请求A节点，服务器返回ASK情况">  </p><p>相反，当客户端向B请求插槽0中的键，如果前面执行了ASKING命令，则返回键值内容，否则返回MOVED跳转请求，如下图所示，这样一来客户端只有能够处理ASK跳转，则可以在数据库迁移时自动从正确的节点获取到相应的键值，避免了键在迁移过程中临时“丢失”的问题。  </p><p><img src="http://op7wplti1.bkt.clouddn.com/askB.png" alt="客户端请求B节点，根据是否前面执行过ASKING，则返回不同"> </p><h3 id="4、获取与插槽对应的节点"><a href="#4、获取与插槽对应的节点" class="headerlink" title="4、获取与插槽对应的节点"></a>4、获取与插槽对应的节点</h3><p>对于指定的键，可以根据前面讲述的算法来计算其属于哪个插槽，但是如何获取某一个键有哪一个节点负责呢？<br>实际上，当客户端向集群中的任意一个节点发送命令后，该节点会判断相应的键是否在当前节点中，如果键在该节点中，则会像单机实例一样正确处理该命令；如果键不在该节点中，就会返回一个MOVE重定向请求，告诉客户端这个键目前由哪个节点负责，然后客户端再将同样的请求项目表节点重新发送一次以获取结果。<br>一些语言的redis库支持代理MOVE请求，所以对于开发者而言命令重定向的过程是透明的，使用集群与使用单机实例并没有什么不同。然而也有些语言库并不支持集群，这时就需要在客户端编码处理了。<br>还是以上面的集群配置为例，键foo实际应该由6382节点负责，如果尝试在6380节点执行与键foo相关的命令，就会有如下输出：  </p><pre><code>127.0.0.1:6380&gt; set foo bar(error) MOVED 12182 127.0.0.1:6382</code></pre><p>返回的是一个MOVE重定向请求，12182表示foo所属的插槽号，127.0.0.1:6382则是负责该插槽的节点地址和端口，客户端收到重定向请求后，应该将命令重新向6382节点发送一次：  </p><pre><code>127.0.0.1:6382&gt; set foo barOK</code></pre><p>Redis命令行客户端提供了集群模式来支持自动重定向，使用-c参数来启用： </p><pre><code>[admin@KFCS3 redis-stable_01]$ ./src/redis-cli -p 6380127.0.0.1:6380&gt; get foo(error) MOVED 12182 127.0.0.1:6382--加了c参数之后[admin@KFCS3 redis-stable_01]$ ./src/redis-cli -c -p 6380127.0.0.1:6380&gt; get foo-&gt; Redirected to slot [12182] located at 127.0.0.1:6382&quot;bar&quot;</code></pre><p>可见加入了-c参数后，如果当前节点并不负责要处理的键，Redis命令行客户端会进行自动命令重定向。而这一过程正是每个支持集群的客户端应该实现的。<br>然而相比单机实例，集群的命令重定向也增加了命令的请求次数，原先只需要执行一次的命令现在有可能需要依次发向两个节点，算上往返时延，可以说请求重定向对性能还是有些影响的。<br>为了解决这一问题，当发现新的重定向请求时，客户端应该在重新向正确节点发送命令的同时，缓存插槽的路由信息，即记录下当前插槽时由哪个节点负责的。这样每次发起命令时，客户端首先计算相关键是属于哪个插槽的，然后根据缓存的路由判断插槽有哪个节点负责。考虑到插槽总数相对少（16384个），缓存所有插槽的路由信息后，每次命令将均只发向正确的节点，从而达到和单机实例同样的性能。  </p><h3 id="5、故障恢复"><a href="#5、故障恢复" class="headerlink" title="5、故障恢复"></a>5、故障恢复</h3><p>在一个集群中，每个节点都会定期向其他节点发送PING命令，并通过有没有收到回复来判断目标节点是否已经下线了。具体来说，集群中的每个节点每隔1秒钟就会随机选择5个节点，然后选择其中最久没有响应的节点发送PING命令。<br>如果一定时间内目标节点没有响应回复，则发送PING命令的节点会认为目标节点疑似下线（PFALL）。疑似下线可以与哨兵的主观下线类比，两者都表示某一节点从自身的角度认为目标节点时下线状态。需要一定数量的节点都认为该节点疑似下线才可以，这一过程具体为：<br>（1）一旦节点A认为节点B是疑似下线状态，就会在集群中传播该消息，所有其他节点收到消息后都会记录下这一信息；<br>（2）当集群中的某一节点C收集到半数以上的节点认为B是疑似下线的状态时，就会将B标记为下线（FALL），并且向集群中的其他节点传播该消息，从而使得B在整个集群中下线。<br>在集群中，当一个数据库下线时，就会出现一部分插槽无法写入的问题。这时如果该主数据库拥有至少一个从数据库，集群就进行故障恢复操作来将其中一个从数据库转变成主数据库来保证集群的完整。选择哪个从数据库来作为主数据库的过程与哨兵中选择领头哨兵的过程一样，都是基于Raft算法，过程如下：<br>（1）发现其复制的主数据下线的从数据库（下面称作A）向每个集群中的节点发送请求，要求对方选自己成为主数据库。<br>（2）如果收到请求的节点没有选过其他人，则会同意将A设置成主数据库。<br>（3）如果A发现有超过集群中节点总数一半的节点同意选自己成为主数据库，则A则成为主数据库。<br>（4）当有多个从数据库节点同时参选主数据库，则会出现没有任何节点当选的可能。此时每个参选节点将等待一个随机时间重新发起参选请求，进行下一轮选举，直到选举成功。<br>当某个从数据库当选为主数据库后，会通过命令SLAVEOF NO ONE 将自己转换成主数据库，并将旧的主数据库的插槽转换给自己负责。<br>如果一个至少负责一个插槽的主数据库下线且没有相应的从数据库可以进行故障恢复，则整个集群默认会进入下线状态无法继续工作。如果想在这种情况下使集群仍然能正常工作，可以修改配置cluster-require-full-coverage为no（默认为yes）：  </p><pre><code>cluster-require-full-converage no</code></pre>]]></content>
    
    <summary type="html">
    
      Redis集群的配置，集群工作原理；节点（nodes）、插槽（slots）、键值的对应关系；使用redis-trib.rb的辅助工具。
    
    </summary>
    
      <category term="redis系列" scheme="http://xym-loveit.github.io/categories/redis%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="redis集群" scheme="http://xym-loveit.github.io/tags/redis%E9%9B%86%E7%BE%A4/"/>
    
      <category term="redis-trib.rb集群辅助工具" scheme="http://xym-loveit.github.io/tags/redis-trib-rb%E9%9B%86%E7%BE%A4%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
    
      <category term="集群（cluster）插槽slot" scheme="http://xym-loveit.github.io/tags/%E9%9B%86%E7%BE%A4%EF%BC%88cluster%EF%BC%89%E6%8F%92%E6%A7%BDslot/"/>
    
      <category term="节点（node）的插槽（slot）分配" scheme="http://xym-loveit.github.io/tags/%E8%8A%82%E7%82%B9%EF%BC%88node%EF%BC%89%E7%9A%84%E6%8F%92%E6%A7%BD%EF%BC%88slot%EF%BC%89%E5%88%86%E9%85%8D/"/>
    
      <category term="键归属的插槽" scheme="http://xym-loveit.github.io/tags/%E9%94%AE%E5%BD%92%E5%B1%9E%E7%9A%84%E6%8F%92%E6%A7%BD/"/>
    
      <category term="集群故障恢复" scheme="http://xym-loveit.github.io/tags/%E9%9B%86%E7%BE%A4%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>redis入门指南之哨兵</title>
    <link href="http://xym-loveit.github.io/2017/06/02/redis%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E4%B9%8B%E5%93%A8%E5%85%B5/"/>
    <id>http://xym-loveit.github.io/2017/06/02/redis入门指南之哨兵/</id>
    <published>2017-06-02T08:25:25.000Z</published>
    <updated>2018-03-29T01:27:48.640Z</updated>
    
    <content type="html"><![CDATA[<h6 id="重要星级-★★★★★"><a href="#重要星级-★★★★★" class="headerlink" title="重要星级 ★★★★★"></a>重要星级 ★★★★★</h6><hr><h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><p>Redis中的复制的原理和使用方式，在一个典型的一主多从的Redis系统中，从数据库在整个系统中起到了数据冗余备份和读写分离的作用。当主数据库遇到异常中断服务后，开发者可以通过手动的方式选择一个从数据库来升格为主数据库，以使得系统能够继续提供服务。然后整个过程相对麻烦且需要人工介入，难以实现自动化。为此，Redis2.8中提供了哨兵工具来实现自动化的系统监控和故障恢复功能。  </p><h3 id="1、什么是哨兵"><a href="#1、什么是哨兵" class="headerlink" title="1、什么是哨兵"></a>1、什么是哨兵</h3><p>顾名思义，哨兵的作用就是监控Redis系统的运行状况。它的功能包含以下两个。<br>（1）监控主数据库和从数据库是否正常运行。<br>（2）主数据库出现故障时自动将从数据库转换为主数据库。<br>哨兵是一个独立的进程，使用哨兵的一个典型架构如下图:  </p><p><img src="http://op7wplti1.bkt.clouddn.com/sentinelMonitor.png" alt="哨兵监控">  </p><p>在一个一主多从的Redis系统中，可以使用多个哨兵进行监控任务以保证系统足够稳健，如下图所示。注意，此时不仅哨兵会同时监控主数据库和从数据库，哨兵之间也会相互监控。  </p><p><img src="http://op7wplti1.bkt.clouddn.com/multiSentinel.png" alt="一主多从Redis集群多哨兵监控">  </p><h3 id="2、实例讲解"><a href="#2、实例讲解" class="headerlink" title="2、实例讲解"></a>2、实例讲解</h3><p>在理解哨兵的原理前，我们首先实际使用一下哨兵，来了解哨兵是如何工作的。为了简单起见，我们将建立三个Redis的集群（一主两从）。我们使用Redis命令行客户端来获取复制状态，以保证复制配置正确。<br>首先是主数据库：  </p><pre><code>--236服务器127.0.0.1:6379&gt; info replication# Replicationrole:masterconnected_slaves:2slave0:ip=192.168.100.237,port=6379,state=online,offset=151945,lag=1slave1:ip=192.168.100.238,port=6379,state=online,offset=152104,lag=0master_repl_offset:152104repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:2repl_backlog_histlen:152103  </code></pre><p>可见其连接了两个从数据库，配置正确。然后用相同的方法查看两个从数据库的配置：  </p><pre><code>--237服务器127.0.0.1:6379&gt; info replication# Replicationrole:slavemaster_host:192.168.100.236master_port:6379master_link_status:upmaster_last_io_seconds_ago:0master_sync_in_progress:0slave_repl_offset:159045slave_priority:100slave_read_only:1connected_slaves:0master_repl_offset:0repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0  --238服务器127.0.0.1:6379&gt; info replication# Replicationrole:slavemaster_host:192.168.100.236master_port:6379master_link_status:upmaster_last_io_seconds_ago:1master_sync_in_progress:0slave_repl_offset:160972slave_priority:100slave_read_only:1connected_slaves:0master_repl_offset:0repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0  </code></pre><p>当出现的信息如上时，即证明一主二从的配置已经成功了。接下来配置哨兵。建立一个配置文件，如sentinel.conf，内容为：  </p><pre><code>sentinel monitor mymaster 192.168.100.236 6379 1  </code></pre><p>其中mymaster表示要监控的主数据库的名字，可以自己定义一个。这个名字必须仅有大小写字母、数字和“.-_”这三种字符组成。后面2个参数表示主数据库的地址和端口号，这里我们要监控的是主数据库236。最后一个1表示最低通过票数。接下来启动sentinel进程，并将上述配置的路径传递给哨兵：  </p><pre><code>[root@KFCS1 src]# ./redis-sentinel ../sentinel.conf  </code></pre><p>需要注意的是，配置哨兵监控一个系统时，只需要配置其监控主数据库即可，哨兵会自动发现所有复制该主数据库的从数据库。启动哨兵后，哨兵输出内容如下：  </p><pre><code>Sentinel ID is 5f9becd72d6c4e8d7e5c0a06836b1b79a8ad055014246:X 02 Jun 17:39:46.909 # +monitor master mymaster 192.168.100.236 6379 quorum 114246:X 02 Jun 17:39:46.911 * +slave slave 192.168.100.238:6379 192.168.100.238 6379 @ mymaster 192.168.100.236 637914246:X 02 Jun 17:39:46.938 * +slave slave 192.168.100.237:6379 192.168.100.237 6379 @ mymaster 192.168.100.236 6379</code></pre><p>其中+slave表示新发现了从数据库，可见哨兵成功地发现了两个从数据库。现在哨兵已经在监控这3个Redis实例了，这时我们将主数据库关闭（杀死进程或使用SHUTDOWN命令），等待指定时间后（可以配置，默认为30秒），哨兵会输出如下内容：  </p><pre><code>14246:X 02 Jun 17:40:34.699 # +sdown master mymaster 192.168.100.236 637914246:X 02 Jun 17:40:34.700 # +odown master mymaster 192.168.100.236 6379 #quorum 1/1  </code></pre><p>其中+sdown表示哨兵主观认为主数据库停止服务了，而+odown则表示哨兵客观认为主数据库停止服务了，关于主观和客观的区别后文会详细介绍。此时哨兵开始执行故障恢复，即挑选一个从数据库，将其升格为主数据库，输出如下：  </p><pre><code>14246:X 02 Jun 17:40:34.700 # +try-failover master mymaster 192.168.100.236 637914246:X 02 Jun 17:40:34.714 # +vote-for-leader 5f9becd72d6c4e8d7e5c0a06836b1b79a8ad0550 214246:X 02 Jun 17:40:34.714 # +elected-leader master mymaster 192.168.100.236 637914246:X 02 Jun 17:40:34.714 # +failover-state-select-slave master mymaster 192.168.100.236 637914246:X 02 Jun 17:40:34.815 # +selected-slave slave 192.168.100.238:6379 192.168.100.238 6379 @ mymaster 192.168.100.236 637914246:X 02 Jun 17:40:34.815 * +failover-state-send-slaveof-noone slave 192.168.100.238:6379 192.168.100.238 6379 @ mymaster 192.168.100.236 637914246:X 02 Jun 17:40:34.891 * +failover-state-wait-promotion slave 192.168.100.238:6379 192.168.100.238 6379 @ mymaster 192.168.100.236 637914246:X 02 Jun 17:40:35.072 # +promoted-slave slave 192.168.100.238:6379 192.168.100.238 6379 @ mymaster 192.168.100.236 637914246:X 02 Jun 17:40:35.072 # +failover-state-reconf-slaves master mymaster 192.168.100.236 637914246:X 02 Jun 17:40:35.134 * +slave-reconf-sent slave 192.168.100.237:6379 192.168.100.237 6379 @ mymaster 192.168.100.236 637914246:X 02 Jun 17:40:36.104 * +slave-reconf-inprog slave 192.168.100.237:6379 192.168.100.237 6379 @ mymaster 192.168.100.236 637914246:X 02 Jun 17:40:36.104 * +slave-reconf-done slave 192.168.100.237:6379 192.168.100.237 6379 @ mymaster 192.168.100.236 637914246:X 02 Jun 17:40:36.186 # +failover-end master mymaster 192.168.100.236 637914246:X 02 Jun 17:40:36.186 # +switch-master mymaster 192.168.100.236 6379 192.168.100.238 637914246:X 02 Jun 17:40:36.186 * +slave slave 192.168.100.237:6379 192.168.100.237 6379 @ mymaster 192.168.100.238 637914246:X 02 Jun 17:40:36.187 * +slave slave 192.168.100.236:6379 192.168.100.236 6379 @ mymaster 192.168.100.238 6379  </code></pre><p>+try-failover表示哨兵开始进行故障恢复，+failover-end表示哨兵完成故障恢复，期间涉及的内容比较复杂，包括领头哨兵的选举、备选从数据库的选择等，放到后面介绍，此处只需要关注最后3条输出。+switch-master表示主数据库从236转换到了238，即238服务器升格为主数据库，同时两个+slave则列出了新的主数据库的2个从数据库。其中236就是之前停止服务的主数据库，可见哨兵并没有彻底清除停止服务的实例信息，这是因为停止服务的实例有可能会在之后的某个时间恢复服务，这时哨兵会让其重新加入进来，所以当实例停止服务后，哨兵会更新该实例的信息，使得当其重新加入后可以按照当前信息继续对外提供服务。此例中236主数据库实例停止服务了，而238服务器的从数据库已经升格为主数据库，当236实例恢复服务后，会转变为238实例的从数据库来运行，所以哨兵将236服务器实例的信息修改成了238实例的从数据库。<br>故障恢复完成后，可以使用Redis命令行客户端重新检查237/238两台服务器上的实例信息：  </p><pre><code>--237服务器127.0.0.1:6379&gt; info replication# Replicationrole:slavemaster_host:192.168.100.238master_port:6379master_link_status:upmaster_last_io_seconds_ago:0master_sync_in_progress:0slave_repl_offset:308379slave_priority:100slave_read_only:1connected_slaves:0master_repl_offset:0repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0--238服务器127.0.0.1:6379&gt; info replication# Replicationrole:masterconnected_slaves:1slave0:ip=192.168.100.237,port=6379,state=online,offset=311494,lag=1master_repl_offset:311494repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:2repl_backlog_histlen:311493  </code></pre><p>可以看到238服务器上实例已经确实升格为主数据库了，同时237服务器上的实例是其从数据库。整个故障恢复过程就此完成。那么我们重新启动236服务器上的Redis实例，监控到的日志输出如下:  </p><pre><code>14246:X 02 Jun 17:42:27.637 # -sdown slave 192.168.100.236:6379 192.168.100.236 6379 @ mymaster 192.168.100.238 637914246:X 02 Jun 17:42:37.643 * +convert-to-slave slave 192.168.100.236:6379 192.168.100.236 6379 @ mymaster 192.168.100.238 6379</code></pre><p>-sdown表示实例236已经恢复服务了（与+sdown相反）同时+convert-to-slave表示将236服务器的实例设置为238服务器实例的从数据库。这时使用Redis命令行客户端查看236实例的复制信息为：  </p><pre><code>127.0.0.1:6379&gt; info replication# Replicationrole:slavemaster_host:192.168.100.238master_port:6379master_link_status:upmaster_last_io_seconds_ago:0master_sync_in_progress:0slave_repl_offset:333678slave_priority:100slave_read_only:1connected_slaves:0master_repl_offset:0repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0  </code></pre><p>同时238端口的复制信息为:  </p><pre><code>127.0.0.1:6379&gt; info replication# Replicationrole:masterconnected_slaves:2slave0:ip=192.168.100.237,port=6379,state=online,offset=311494,lag=1slave1:ip=192.168.100.236,port=6379,state=online,offset=311494,lag=0master_repl_offset:311494repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:2repl_backlog_histlen:311493</code></pre><p>正如预期一样，238实例的从数据库变为了2个，236成功恢复服务。</p><h3 id="3、实现原理"><a href="#3、实现原理" class="headerlink" title="3、实现原理"></a>3、实现原理</h3><p>一个哨兵进程启动时会读取配置文件的内容，通过如下的配置找出需要监控的主数据库：  </p><pre><code>sentinel monitor master-name ip redis-port quorum</code></pre><p>其中master-name是一个由大小写字母、数字和“.-_”组成的主数据库的名字，因为考虑到故障恢复后当前监控的系统的主数据库的地址和端口号会产生变化，所以哨兵提供了命令可以通过主数据库的名字获取当前系统的主数据库的地址和端口号。<br>ip 表示当前系统中主数据库的地址，而redis-port则表示端口号。<br>quorum用来表示执行故障恢复操作前至少需要几个哨兵节点同意。一个哨兵节点可以同时监控多个Redis主从系统，只需要提供多个sentinel monitor 配置即可，例如：  </p><pre><code>sentinel monitor mymaster 127.0.0.1 6379 2sentinel monitor othermaster 192.168.100.238 6379 1</code></pre><p>同时多个哨兵节点也可以同时监控同一个Redis主从系统，从而形成网状结构。具体实践时如何协调哨兵与主从系统的数量关系将在后文介绍。<br>配置文件中还可以定义其他监控相关的参数，每个配置选项都包含主数据的名字使得监控不同主数据库时可以使用不同的配置参数。如：  </p><pre><code>sentinel down-after-milliseconds mymaster 60000sentinel down-after-milliseconds othermaster 10000</code></pre><p>上面的两行配置分别配置了mymaster和othermaster的sentinel down-after-milliseconds选项分别为60000和10000。<br>哨兵启动后，会与要监控的主数据库建立两条连接，这两条连接的建立方式与普通的Redis客户端无异。其中一条连接用来订阅该主数据库的__sentinel__:hello频道以获取其他同样监控该数据库的哨兵节点的信息，另外哨兵也需要定期向主数据库发送INFO等命令来获取主数据库本身的信息，因为之前介绍过当客户端的连接进入订阅模式时就不能再执行其他命令了，所以这时哨兵会使用另外一条连接来发送这些命令。和主数据库的连接建立完成后，哨兵会定时执行下面3个操作。<br>（1）每10秒哨兵会向主数据库和从数据库发送INFO命令。<br>（2）每2秒哨兵会向主数据库和从数据库的__sentinel__:hello频道发送自己的信息。<br>（3）每1秒哨兵会向主数据库、从数据库和其他哨兵节点发送PING命令。<br>这3个操作贯穿哨兵进程的整个生命周期中，非常重要，可以说了解了这3个操作的意义就能够了解哨兵工作原理的一半内容了。<br>首先，发送INFO命令使得哨兵可以获得当前数据库的相关信息（包括运行ID、复制信息等）从而实现新节点的自动发现。前面说配置哨兵监控Redis主从系统时只需要指定主数据库的信息即可，因为哨兵正是借助INFO命令来获取所有复制该主数据库的从数据库信息的。启动后，哨兵向主数据库发送INFO命令，通过解析返回结果来得知从数据库列表，而后对每个从数据库同样建立2个连接，2个连接的作用和前面介绍的与主数据库建立的2个连接完全一致。在此之后哨兵会每10秒定时向已知的所有主从数据库发送INFO命令来获取信息更新并进行相应操作，比如对新增的从数据库建立连接并加入监控列表，对主从数据库的角色变化（由故障恢复操作引起）进行信息更新等。<br>接下来哨兵向主从数据库的__sentinel__:hello频道发送信息来与同样监控该数据库的哨兵分享自己的信息。发送的消息内容为：  </p><blockquote><p>&lt;哨兵的地址&gt;,&lt;哨兵的端口&gt;,&lt;哨兵的运行ID&gt;,&lt;哨兵的配置版本&gt;,&lt;主数据的名字&gt;,&lt;主数据库的地址&gt;,&lt;主数据库的端口&gt;,&lt;主数据库的配置版本&gt;  </p></blockquote><p>可以看到消息包括的哨兵的基本信息，以及其监控的数据库的信息。前文介绍过，哨兵会订阅每个其监控的数据库的__sentinel__:hello频道，所以当其他哨兵收到消息后，会判断发送消息的哨兵是不是新发现的哨兵。如果是则将其加入已发现的哨兵列表中并创建一个到其的连接（与数据库不同，哨兵与哨兵之间只会创建一条连接用来发送PING命令，而不需要创建另外一条连接来订阅频道，因为哨兵只需要订阅数据库的频道即可实现自动发现其他哨兵）。同时哨兵会判断信息中主数据的配置版本，如果该版本比当前记录的主数据库的版本高，则更新主数据库的数据。配置版本的作用将在后面介绍。<br>实现了自动发现从数据库和其他哨兵节点后，哨兵要做的就是定时监控这些数据库和节点有没有停止服务。这是通过每隔一定时间向这些节点发送PING命令实现的。时间间隔与down-after-milliseconds选项有关，当down-after-milliseconds的值小于1秒时，哨兵会每隔down-after-milliseconds指定的时间发送一次PING命令，当down-after-milliseconds的值大于1秒时，哨兵会每隔1秒发送一次PING命令。如：  </p><pre><code>--每隔1秒发送一次PING命令sentinel down-after-milliseconds mymaster 60000--每隔600毫秒发送一次PING命令sentinel down-after-milliseconds mymaster 600</code></pre><p>当超过down-after-milliseconds选项指定时间后，如果被PING的数据库或节点仍然未进行回复，则哨兵认为其主观下线(subjectively down)。主观下线表示从当前的哨兵进程看来，该节点已经下线。如果该节点是主数据库，则哨兵会进一步判断是否需要对其进行故障恢复：哨兵发送SENTINEL is-master-down-by-addr命令询问其他哨兵节点以了解他们是否也认为该主数据库主观下线，如果达到指定数量时，哨兵会认为其客观下线（objectively down），并选举领头的哨兵节点对主从系统发起故障恢复。这个指定数量即为前文介绍的quorum参数。如下配置：  </p><pre><code>sentinel monitor mymaster 127.0.0.1 6379 2</code></pre><p>该配置表示只有当至少2个sentinel节点（包括当前节点）认为该主数据库主观下线时，当前哨兵节点才会认为该主数据库客观下线。进行接下来的选举领头哨兵步骤。<br>虽然当前哨兵节点发现了主数据库客观下线，需要故障恢复，但是故障恢复需要有领头的哨兵来完成，这样可以保证同一时间只有一个哨兵节点来执行故障恢复。选举领头哨兵的过程使用后了Raft算法，具体如下：<br>（1）发现主数据库客观下线的哨兵节点（下面称作A）向每个哨兵节点发送命令，要求对方选自己成为领头哨兵。<br>（2）如果目标哨兵节点没有选过其他人，则会同意将A设置成领头哨兵。<br>（3）如果A发现有超过半数且超过quorum参数值的哨兵节点同意选自己成为领头哨兵，则A成功成为领头哨兵。<br>（4）当有多个哨兵节点同时参选领头哨兵，则会出现没有任何节点当选的可能。此时每个参选节点将等待一个随机时间重新发起参选请求，进行下一轮选举，直到选举成功。<br>具体过程可以参考Raft算法的过程<a href="http://www.cnblogs.com/mindwind/p/5231986.html" target="_blank" rel="noopener">http://www.cnblogs.com/mindwind/p/5231986.html</a>。因为要成为领头哨兵必须有超过半数的哨兵节点支持，所以每次选举最多只会选出一个领头哨兵。<br>选出领头哨兵后，领头哨兵将会开始对主数据库进行故障恢复。故障恢复的过程相对简单，具体如下：<br>首先领头哨兵将从停止服务的主数据库的从数据库中挑选一个充当新的主数据库。挑选的依据如下：<br>（1）所有在线的从数据库中，选择优先级最高的从数据库。优先级可以通过slave-priority选项来设置。<br>（2）如果有多个最高优先级的从数据库，则复制的命令偏移量越大（即复制越完整）越优先。<br>（3）如果以上条件都一样，则选择运行ID较小的从数据库。<br>选出一个从数据库后，领头哨兵将向从数据库发送SLAVEOF NO ONE 命令使其升格为主数据库。而后领头哨兵向其他从数据库发送SLAVEOF命令来使其成为新主数据库的从数据库。最后一步则是更新内部的记录，将已经停止服务的旧的主数据库更新成为新的主数据库的从数据库，使得当其恢复服务时自动以从数据库的身份继续服务。  </p><h3 id="4、哨兵的部署"><a href="#4、哨兵的部署" class="headerlink" title="4、哨兵的部署"></a>4、哨兵的部署</h3><p>哨兵以独立进程的方式对一个主从系统进行监控，监控的效果好坏与否取决于哨兵的视角是否有代表性。如果一个主从系统中配置的哨兵较少，哨兵对整个系统的判断的可靠性就会降低。极端情况下，当只有一个哨兵时，哨兵本身就可能会发生单点故障。整体来讲，相对稳妥的哨兵部署方案是使得哨兵的视角尽可能地与每个节点的视角一致，即：<br>（1）为每个节点（无论是主数据库还是从数据库）部署一个哨兵。<br>（2）使每个哨兵与其对应的节点网络环境相同或相近。<br>这样的部署方案可以保证哨兵的视角拥有较高的代表性和可靠性。举例：当网络分区后，如果哨兵认为某个分区是主要分区，即意味着从每个节点观察，该分区均为主分区。同时设置quorum的值为N/2+1（其中N为哨兵节点数量），这样使得只有当大部分哨兵节点同意后才会进行故障恢复。<br>当系统中的节点较多时，考虑到每个哨兵都会和系统中的所有节点建立连接，为每个节点分配一个哨兵会产生较多连接，尤其是当进行客户端分片时使用多个哨兵节点监控多个主数据库会因为Redis不支持连接复用而产生大量冗余连接，同时如果Redis节点负载较高，会在一定程度上影响其对哨兵的回复以及与其节点的通信。所以配置哨兵时还需要根据实际的生产环境情况进行选择。</p>]]></content>
    
    <summary type="html">
    
      通过使用redis主从模式提升redis负载能力，减小单点故障的可能，阅读本章使用哨兵（sentinel）可以配置出更强劲的Redis集群，重中之重。
    
    </summary>
    
      <category term="redis系列" scheme="http://xym-loveit.github.io/categories/redis%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="redis哨兵监控" scheme="http://xym-loveit.github.io/tags/redis%E5%93%A8%E5%85%B5%E7%9B%91%E6%8E%A7/"/>
    
      <category term="哨兵（sentinel）的实现原理" scheme="http://xym-loveit.github.io/tags/%E5%93%A8%E5%85%B5%EF%BC%88sentinel%EF%BC%89%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
      <category term="哨兵的配置" scheme="http://xym-loveit.github.io/tags/%E5%93%A8%E5%85%B5%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>redis入门指南之复制</title>
    <link href="http://xym-loveit.github.io/2017/06/02/redis%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E4%B9%8B%E5%A4%8D%E5%88%B6/"/>
    <id>http://xym-loveit.github.io/2017/06/02/redis入门指南之复制/</id>
    <published>2017-06-02T00:59:46.000Z</published>
    <updated>2018-03-29T01:27:48.641Z</updated>
    
    <content type="html"><![CDATA[<h6 id="重要星级-★★★★★"><a href="#重要星级-★★★★★" class="headerlink" title="重要星级 ★★★★★"></a>重要星级 ★★★★★</h6><hr><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>通过持久化功能，Redis保证了即使在服务器重启的情况下也不会损失（或少量损失）数据。但是由于数据是存储在一台服务器上的，如果这台服务器出现硬盘故障等问题，也会导致数据丢失。为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上，这样即使有一台服务器出现故障，其他服务器依然可以继续提供服务。为此，Redis提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上。  </p><h3 id="1、配置"><a href="#1、配置" class="headerlink" title="1、配置"></a>1、配置</h3><p>在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库（slave）。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一个数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。如下图：  </p><p><img src="http://op7wplti1.bkt.clouddn.com/masterSlave.png" alt="Redis一主多从数据库示意图">  </p><p>在Redis中使用复制功能非常容易，只需要在从数据库的配置文件中加入“slaveof 主数据库地址 主数据库端口”即可，主数据库无需进行任何配置。为了能够更直观地展示复制的流程，下面将实现一个最简化的复制系统。我们在1台服务器上启动2个Redis实例，监听不同端口，其中一个作为主数据库，另一个作为从数据库。首先我们不加任何参数来启动一个Redis实例作为主数据库： </p><pre><code>redis-server redis.conf</code></pre><p>该实例默认监听6379端口。然后加上slaveof参数启动另一个Redis实例作为从数据库，并让其监听6380端口：  </p><pre><code>redis-server --port 6380 --slaveof 127.0.0.1 6379</code></pre><p>此时在主数据库中的任何数据变化都会自动同步到从数据库中。我们打开redis-cli实例A并连接到主数据库： </p><pre><code>redis-cli -p 6379</code></pre><p>再打开redis-cli实例B并连接到从数据库：  </p><pre><code>redis-cli -p 6380</code></pre><p>这是我们使用INFO命令来分别在实例A和实例B中获取Replication节点的相关信息：  </p><pre><code>127.0.0.1:6379&gt; info replication# Replicationrole:masterconnected_slaves:1slave0:ip=192.168.100.237,port=6379,state=online,offset=1346,lag=1master_repl_offset:1346repl_backlog_active:1repl_backlog_size:1048576repl_backlog_first_byte_offset:2repl_backlog_histlen:1345</code></pre><p>可以看到，实例A的角色（上面输出中的role）是master，即主数据库，同时已连接的从数据库（上面输出中的connected_slaves）的个数为1。同样在实例B中获取相应的信息为：  </p><pre><code>127.0.0.1:6379&gt; info replication# Replicationrole:slavemaster_host:192.168.100.236master_port:6379master_link_status:upmaster_last_io_seconds_ago:4master_sync_in_progress:0slave_repl_offset:1714slave_priority:100slave_read_only:0connected_slaves:0master_repl_offset:0repl_backlog_active:0repl_backlog_size:1048576repl_backlog_first_byte_offset:0repl_backlog_histlen:0</code></pre><p>这里可以看到，实例B的role是slave，即从数据库，同时其主数据的地址为127.0.0.1，端口为6379。在实例A中使用SET命令设置一个键的值： </p><pre><code>127.0.0.1:6379&gt; set foo barOK</code></pre><p>此时在实例B中就可以获得该值了：  </p><pre><code>127.0.0.1:6379&gt; get foo&quot;bar&quot;</code></pre><p>默认情况下，从数据库是只读的，如果直接修改从数据库的数据库会出现错误： </p><pre><code>127.0.0.1:6379&gt; set foo bar(error) READONLY You can&apos;t write against a read only slave.</code></pre><p>可以通过设置从数据库的slave-read-only为no以使从数据库可写，但是因为对从数据库的任何更改都不会同步给任何其他数据库，并且一旦主数据库中更新了对应的数据就会覆盖从数据库中的改动，所以通常的场景下不应该设置从数据库可写，以免导致易被忽略的潜在应用逻辑错误。<br>配置多台从数据库的方法也一样，在所有的从数据库的配置文件中都加上slaveof 参数指向同一个主数据库即可。除了通过配置文件或命令行参数设置slaveof 参数，还可以在运行时使用slaveof命令修改：  </p><pre><code>slaveof 127.0.0.1 6379</code></pre><p>如果该数据库已经是其他主数据库的从数据库了，SLAVEOF命令会停止和原来数据库的同步转而和新数据库同步。此外对于从数据库来说，还可以使用SLAVEOF NO ONE 命令来使当前数据库停止接受其他数据库的同步并转换成为主数据库。  </p><h3 id="2、原理"><a href="#2、原理" class="headerlink" title="2、原理"></a>2、原理</h3><p>了解Redis复制的原理对日后运维有很大帮助，包括如何规划节点，如何处理节点故障等。下面将详细介绍Redis实现复制的过程。<br>当一个从数据库启动后，会向主数据库发送SYNC命令。同时主数据库接收到SYNC命令后会开始在后台保存快照（即RDB持久化的过程），并将保存快照期间接收到的命令缓存起来。当快照完成后，Redis会将快照文件和所有缓存的命令发送给从数据库。从数据库收到后，会载入快照文件并执行收到的缓存的命令。以上过程称为复制初始化。复制初始化结束后，主数据库每当收到写命令时就会将命令同步给从数据库，从而保证主从数据库数据一致。<br>当主从数据库之间的连接断开重连后，Redis2.6以及之前的版本会重新进行复制初始化（即主数据库保存快照并传送给从数据库），即使从数据库可能仅有几条命令没有收到，主数据库也必须要将数据库里的所有数据重新传送给从数据库。这使得主从数据库断线重连后的数据恢复过程效率很低下，在网络环境不好的时候这一问题尤其明显。Redis2.8版的一个重要改进就是断线重连能够支持有条件的增量数据传输，当从数据库重新连接上主数据库后，主数据库只需要将断线期间执行的命令传送给从数据库，从而大大提高Redis复制的实用性。<br>下面将从具体协议角度详细介绍复制初始化的过程。由于Redis服务器使用TCP协议通信，所以我们可以使用telnet工具伪装成一个从数据库来与主数据库通信。首先在命令行中连接主数据库（默认端口为6379，假设目前没有任何从数据库连接）：  </p><pre><code>[admin@KFCS2 ~]$ telnet 192.168.100.236 6379Trying 192.168.100.236...Connected to 192.168.100.236.Escape character is &apos;^]&apos;.</code></pre><p>然后作为从数据库，我们先要发送PING命令确认主数据库是否可以连接： </p><pre><code>ping+PONG</code></pre><p>主数据库会回复+PONG。如果没有收到主数据库的回复，则向用户提示错误。如果主数据库需要密码才能连接，我们还要发送AUTH命令进行验证。而后向主数据库发送REPLCONF命令说明自己的端口号：  </p><pre><code>replconf listening-port 6379 +OK</code></pre><p>这时就可以开通同步的过程了：向主数据库发送SYNC命令开始同步，此时主数据库发送回快照文件和缓存命令。目前主数据库中只有一个foo键，所以收到的内容如下：  </p><pre><code>sync$90REDIS0007    redis-ver3.2.5  </code></pre><p>从数据库会将收到的内容写入到硬盘上的临时文件中，当写入完成后从数据库会用该临时文件替换RDB快照文件（RDB快照文件的位置就是持久化时配置的位置，由dir和dbfilename两个参数确定），之后的操作就和RDB持久化时启动恢复的过程一样了。需要注意的是在同步过程中从数据库并不会阻塞，而是可以继续处理客户端发来的命令。默认情况下，从数据库会用同步前的数据对命令进行响应。可以配置slave-serve-stale-data 参数为no来使从数据库在同步完成前对所有命令（除了INFO和SLAVEOF）都回复错误:”SYNC with master in progress.”<br>复制初始化阶段结束后，主数据库执行的任何会导致数据变化的命令都会异步地传送给从数据库，这一过程为复制同步阶段。同步的内容和Redis通信协议一样，比如我们在主数据库中执行了SET foo bar，通过telnet我们收到了： </p><pre><code>set$3foo$3bar*1$4</code></pre><p>复制同步阶段会贯穿整个主从同步过程的始终，直到主从关系终止为止。<br>在复制的过程中，快照无论在主数据库还是从数据库中都起了很大的作用，只要执行复制就会进行快照，即使我们关闭了RDB方式的持久化（通过删除所有save参数）。Redis2.8.18之后支持了无硬盘复制。<br>（1）乐观复制<br>Redis采用了乐观复制（optimistic replication）的复制策略，容忍在一定时间内主从数据库的内容是不同的，但是两者的数据会最终同步。具体来说，Redis在主从数据库之间复制数据的过程本身是异步的，这意味着，主数据库执行完客户端请求的命令后会立即将命令在主数据库的执行结果返回给客户端，并异步地将命令同步给从数据库，而不会等待从数据库接收到改该命令后再返回给客户端。这一特性保证了启用复制后主数据库的性能不会受到影响，但另一方面也会产生一个主从数据库数据不一致的时间窗口，当主数据库执行一条写命令后，主数据库的数据已经发生的变动，然而在主数据库将该命令传送给从数据库之前，如果两个数据库之前的网络连接断开了，此时二者之间数据就会是不一致的。从这个角度来看，主数据库是无法得知某个命令最终同步给了多少个从数据库的，不过Redis提供了两个配置选项来限制只有当数据至少同步给指定数量的从数据库时，主数据库才是可写的：  </p><pre><code>min-slaves-to-write 3min-slaves-max-lag 10</code></pre><p>上面的配置中，min-slaves-to-write表示只有当3个或3个以上的从数据库连接到主数据库时，主数据库才是可写的，否则会返回错误，例如：  </p><pre><code>set foo bar(error) NOREPLICAS Not enough good slaves to write</code></pre><p>min-slaves-max-lag表示允许从数据库最长失去连接的时间，如果从数据库最后与主数据库联系（即发送REPLCONF ACK命令）的时间小于这个值，则认为从数据还在保持与主数据库的连接。举个例子，按上面的配置，主数据库假设与3个从数据库相连，其中一个从数据库上一次与主数据库联系是9秒前，这时主数据库可以正常接受写入，一旦1秒过后这台从数据库依旧没有活动，则主数据库认为目前连接的从数据库只有2个，从而拒绝写入。这一特性默认是关闭的，在分布式系统中，打开并合理配置该选项后可以降低主从架构中因为网络分区导致的数据不一致的问题。  </p><h3 id="3、图结构"><a href="#3、图结构" class="headerlink" title="3、图结构"></a>3、图结构</h3><p>从数据库不仅可以接受主数据库的同步数据，自己也可以同时作为主数据库存在，形成类似图的结构，如下图，数据库A的数据会同步到B和C中，而B中的数据会同步到D和E中。向B中写入数据不会同步到A或C中，只会同步到D和E中。  </p><p><img src="http://op7wplti1.bkt.clouddn.com/slaveWithSlave.png" alt="slave也可再拥有slave">  </p><h3 id="4、读写分离与一致性"><a href="#4、读写分离与一致性" class="headerlink" title="4、读写分离与一致性"></a>4、读写分离与一致性</h3><p>通过复制可以实现读写分离，以提高服务器的负载能力。在常见的场景中（如电子商务网站），读的频率大于写，当单机的Redis无法应付大量的读请求时（尤其是较耗资源的请求，如SORT命令等）可以通过复制功能建立多个从数据库节点，主数据库只进行写操作，而从数据库负责读操作。这种一主多从的结果很适合读多写少的场景，而当单个的主数据库不能满足需求时，就需要使用Redis3.0推出的集群功能。  </p><h3 id="5、从数据库持久化"><a href="#5、从数据库持久化" class="headerlink" title="5、从数据库持久化"></a>5、从数据库持久化</h3><p>另一个相对耗时的操作是持久化，为了提高性能，可以通过复制功能建立一个（或多个）从数据库，并在从数据库中启用持久化，同时在主数据库中禁用持久化。当从数据库奔溃重启后主数据库会自动将数据同步过来，所以无需担心数据丢失。然后当主数据库奔溃时，情况就稍显复杂了。手工通过从数据库数据恢复主数据库数据时，需要严格按照以下两部进行。<br>（1）在从数据中使用SLAVEOF NO ONE 命令将从数据库提升成主数据库继续服务。<br>（2）启动之前奔溃的主数据库，然后使用SLAVEOF命令将其设置成新的主数据库的从数据库，即可将数据同步回来。  </p><p><strong>注意：当开启复制且主数据关闭持久化功能时，一定不要使用Supervisor以及类似的进程管理工具令主数据库奔溃后自动重启。同样当主数据所在的服务器因故关闭时，也要避免直接重新启动。这是因为当数据库重新启动后，因为没有开启持久化功能，所以数据库中的所有数据都被清空，这时从数据库依然会从主数据库中接受收据，使得所有从数据库也被清空，导致从数据库的持久化失去意义。</strong>  </p><p>无论哪种情况，手工维护从数据库或主数据库的重启以及数据恢复都相对麻烦，好在Redis提供了一种自动化方案哨兵来实现这一过程，避免了手工维护的麻烦和容易出错的问题。 </p><h3 id="6、无硬盘复制"><a href="#6、无硬盘复制" class="headerlink" title="6、无硬盘复制"></a>6、无硬盘复制</h3><p>Redis复制的工作原理时介绍了复制是基于RDB方式的持久化实现的，即主数据库端在后台保存RDB快照，从数据库端则接受并载入快照文件。这样的实现有点是可以显著地简化逻辑，复用已有代码，但是缺点也很明显。<br>（1）当数据库禁用RDB快照时（即删除了所有的配置文件中的save语句）。如果执行了复制初始化操作，Redis依然会生成RDB快照，所以下次启动后主数据库会以该快照恢复数据。因为复制发生的时间不确定，这使得恢复的数据可能是任何时间点的。<br>（2）因为复制初始化时需要在硬盘中创建RDB快照文件，所以如果硬盘性能很慢（如网络硬盘）时这一过程会对性能产生影响。举例来说，当使用Redis作缓存系统时，因为不需要持久化，所以服务器的硬盘读写速度可能较差。但是当该缓存系统使用一主多从的集群架构时，每次和从数据同步，Redis都会执行一次快照，同时对硬盘进行读写，导致性能降低。因此从2.8.18版本开始，Redis引入了无硬盘复制选项，开启该选项时，Redis在与从数据库进行复制初始化时将不会将快照内容存储到硬盘上，而是直接通过网络发送给从数据库，避免了硬盘的性能瓶颈。<br>目前无硬盘复制的功能还在试验阶段，可以在配置文件中使用如下配置来开启该功能：  </p><pre><code>repl-diskless-sync yes</code></pre><h3 id="7、增量复制"><a href="#7、增量复制" class="headerlink" title="7、增量复制"></a>7、增量复制</h3><p>在介绍复制的原理时提到当主从数据库连接断开后，从数据库会发送SYNC命令来重新进行一次完成的复制操作。这样即使断开期间数据库的变化很小（甚至没有），也需要将数据库中的所有数据重新快照并传送一次。在正常的网络应用环境中，这种实现方式显然不太理想。Redis2.8版相对2.6版的重要更新之一就是实现了主从断线重连的情况下的增量复制。增量复制是基于如下三点实现：<br>（1）从数据库会存储主数据库的运行ID（run id）。每个Redis运行实例均会拥有一个唯一的运行ID，每当实例重启后，就会自动生成一个新的运行ID。<br>（2）在复制同步阶段，主数据库每将一个命令传送给从数据库时，都会同时把该命令存放到一个积压队列（backlog）中，并记录下当前积压队列中存放的命令的偏移量范围。<br>（3）同时，从数据库接收到主数据库传来的命令时，会记录下该命令的偏移量。<br>这三点是实现增量复制的基础。回到之前介绍主从通信流程，可以看到，当主从连接准备就绪后，从数据库会发送一条SYNC命令来告诉主数据库可以开始把所有数据同步过来了。而2.8版以后，不再发送SYNC命令，取而代之的是发送PSYNC，格式为“PSYNC 主数据库的运行id 断开前最新的命令偏移量”。主数据库收到PSYNC命令后，会执行以下判断来决定此次重连是否可以执行增量复制。<br>（1）首先主数据库会判断从数据库传送的运行ID是否和自己的运行ID相同。这一步骤的意义在于确保从数据库之前确实是和自己同步的，以免从数据库拿到错误的数据（比如主数据库在断线重启过，会造成数据的不一致）。<br>（2）然后判断从数据库最后同步成功的命令偏移量是否在积压队列中，如果在则可以执行增量复制，并将积压队列中的相应的命令发送给从数据库。如果此次重连不满足增量复制的条件，主数据库会进行一次全部同步（即与Redis2.6的过程相同）。大部分情况下，增量复制的过程对开发者来说是完全透明的，开发者不需要关心增量复制的具体细节。2.8版本的主数据库也可以正常地和旧版本的从数据库同步（通过接受SYNC命令），同样2.8版本的从数据库也可以与旧版本的主数据库同步（通过发送SYNC命令）。唯一需要开发者设置的就是积压队列的大小了。<br>积压队列的本质上是一个固定长度的循环队列，默认情况下积压队列的大小为1MB，可以通过配置文件的repl-backlog-size选项来调整。很容易理解的是，积压队列越大，其允许的主从数据库断线的时间就越长。根据主从数据库之间的网络状态，设置一个合理的积压队列很重要。因为积压队列存储的内容是命令本身，如SET foo bar，所以估算积压队列的大小只需要估计主从数据库断线的时间中主数据库可能执行的命令的大小即可。与积压队列相关的另一个配置是repl-backlog-ttl，即当所有从数据库与主数据库断开连接后，经过多久时间可以释放积压队列的内存空间。默认时间是1小时。</p>]]></content>
    
    <summary type="html">
    
      通过使用redis主从模式提升redis负载能力，减小单点故障的可能，阅读本章可以配置出更强劲的Redis集群。
    
    </summary>
    
      <category term="redis系列" scheme="http://xym-loveit.github.io/categories/redis%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="redis主从模式" scheme="http://xym-loveit.github.io/tags/redis%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="redis复制" scheme="http://xym-loveit.github.io/tags/redis%E5%A4%8D%E5%88%B6/"/>
    
      <category term="redis一主多从模式" scheme="http://xym-loveit.github.io/tags/redis%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="redis复制原理" scheme="http://xym-loveit.github.io/tags/redis%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    
      <category term="redis复制初始化" scheme="http://xym-loveit.github.io/tags/redis%E5%A4%8D%E5%88%B6%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
      <category term="redis增量复制" scheme="http://xym-loveit.github.io/tags/redis%E5%A2%9E%E9%87%8F%E5%A4%8D%E5%88%B6/"/>
    
      <category term="redis积压队列" scheme="http://xym-loveit.github.io/tags/redis%E7%A7%AF%E5%8E%8B%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>redis入门指南之持久化</title>
    <link href="http://xym-loveit.github.io/2017/06/01/redis%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E4%B9%8B%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://xym-loveit.github.io/2017/06/01/redis入门指南之持久化/</id>
    <published>2017-06-01T02:29:27.000Z</published>
    <updated>2018-03-29T01:27:48.642Z</updated>
    
    <content type="html"><![CDATA[<h6 id="重要星级-★★★★★"><a href="#重要星级-★★★★★" class="headerlink" title="重要星级 ★★★★★"></a>重要星级 ★★★★★</h6><hr><p>Redis的强劲性能很大程度上市由于将其所有数据都存储在了内存中，然而当Redis重启后，所有存储在内存中的数据就会丢失。在一些情况下，我们希望在重启后能保证数据不丢失，例如：<br>（1）将Redis作为数据库使用时。<br>（2）将Redis作为缓存服务器，但缓存被穿透后会对性能造成较大影响，所有缓存同时失效会导致缓存雪崩，从而使服务无法响应。<br>这时我们希望Redis能将数据从内存中以某种形式同步到硬盘中，使得重启后可以根据硬盘中的记录恢复数据。这一过程就是持久化。Redis支持两种方式的持久化，一种是RDB方式，另一种是AOF方式。前者会根据指定的规则“定时”将内存中的数据存储在硬盘上，而后者在每次执行命令后将命令本身记录下来。两种持久化方式可以单独使用其中一种，但更多情况下是将二者结合使用。  </p><h2 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h2><p>RDB方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时Redis会自动将内存中的所有数据生成一份副本存储在硬盘上，这个过程即为“快照”。Redis会在以下几种情况下对数据进行快照：  </p><ol><li>根据配置规则进行自动快照  </li><li>用户执行SAVE或GBSAVE命令手动快照  </li><li>执行FLUSHALL命令  </li><li>执行复制（replication）时。  </li></ol><h3 id="1、根据配置规则自动快照"><a href="#1、根据配置规则自动快照" class="headerlink" title="1、根据配置规则自动快照"></a>1、根据配置规则自动快照</h3><p>Redis允许用户自定义快照条件，当符合快照条件时，Redis会自动执行快照操作。进行快照的条件可以由用户在配置文件中自定义，由两个参数构成：时间窗口M和改动的键的个数N。每当时间M内被更改的键的个数大于N时，即符合自动快照条件。例如Redis安装目录中包含的样例配置文件中预置的3个条件：  </p><pre><code>save 900 1save 300 10save 60 10000</code></pre><p>每条快照条件占一行，并且以save参数开头。同时可以存在多个条件，条件之间是“或”的关系。就这个例子而言，save 900 1的意思是在15分钟（900秒）内有一个或一个以上的键被更改则进行快照。同理save 300 10表示在300秒内至少有10个键被修改则进行快照。  </p><h3 id="2、用户执行SAVE或BGSAVE命令手动快照"><a href="#2、用户执行SAVE或BGSAVE命令手动快照" class="headerlink" title="2、用户执行SAVE或BGSAVE命令手动快照"></a>2、用户执行SAVE或BGSAVE命令手动快照</h3><p>除了让Redis自动进行快照外，当服务重启、手动迁移以及备份时我们也会需要手动执行快照操作。Redis提供了2个命令来完成这一任务。  </p><h4 id="1、SAVE命令"><a href="#1、SAVE命令" class="headerlink" title="1、SAVE命令"></a>1、SAVE命令</h4><p>当执行SAVE命令时，Redis同步地进行快照操作，在快照执行的过程中会阻塞所有来自客户端的请求。当数据库中的数据比较多时，这一过程会导致Redis较长时间不相应，所以要尽量避免在生产环境使用这一命令。  </p><h4 id="2、BGSAVE命令"><a href="#2、BGSAVE命令" class="headerlink" title="2、BGSAVE命令"></a>2、BGSAVE命令</h4><p>需要手动执行快照时推荐使用BGSAVE命令。BGSAVE命令可以在后台异步地进行数据快照操作，快照的同时服务器还可以继续响应来自客户端的请求。执行BGSAVE后Redis会立即返回OK表示开始执行快照操作，如果想知道快照是否完成，可以通过LASTSAVE命令获取最近一次成功执行快照的时间，返回结果是一个Unix时间戳，如：  </p><pre><code>127.0.0.1:6379&gt; lastsave(integer) 1496286152  </code></pre><p>执行自动快照时，Redis采用的策略即是异步快照。  </p><h3 id="3、执行FLUSHALL命令"><a href="#3、执行FLUSHALL命令" class="headerlink" title="3、执行FLUSHALL命令"></a>3、执行FLUSHALL命令</h3><p>当执行FLUSHALL命令时，Redis会清除数据库中的所有数据。需要注意的是，不论清空数据库的过程是否触发了自动快照条件，只要自动快照条件不为空，Redis就会执行一次快照操作。例如，当定义的快照条件为当一秒内修改10000个键时进行自动快照，而当数据库里只有一个键时，执行FLUSHALL命令也会触发快照，即使这一过程实际上只有一个键被修改了。当没有定义自动快照条件时，执行FLUSHALL则不会进行快照。  </p><h3 id="4、执行复制时"><a href="#4、执行复制时" class="headerlink" title="4、执行复制时"></a>4、执行复制时</h3><p>当设置了主从模式时，Redis会在复制初始化时进行自动快照。当使用复制操作时，即使没有自定义自动快照条件，并且也没有手动执行过快照操作，也会生成RDB快照文件。  </p><h3 id="快照原理"><a href="#快照原理" class="headerlink" title="快照原理"></a>快照原理</h3><p>理清Redis实现快照的过程对我们了解快照文件的特性有很大帮助。Redis默认会将快照文件存储在Redis当前进程的工作目录中的dump.rdb文件中，可以通过配置<strong>dir</strong>和<strong>dofilename</strong>两个参数分别指定快照文件的存储路径和文件名。快照过程如下：<br>（1）Redis使用fork函数复制一份当前进程（父进程）的副本（子进程）；<br>（2）父进程继续接受并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件；<br>（3）当子进程写入完所有数据后会用临时文件替换掉旧的RDB文件，至此一次快照操作完成。  </p><p><strong>提示：在执行fork的时候操作系统（类Unix操作系统）会使用写时复制（copy-on-write）策略，即fork函数发生的一刻父子进程共享同一内存数据，当父进程要更改其中某片数据时（如执行一个写命令），操作系统会将该片数据复制一份以保证子进程的数据不受影响，所以新的RDB文件存储的是执行fork一刻的内存数据。写时复制策略也保证了在fork的时刻虽然看上去生成了两份内存副本，但实际上内存的占用量并不会增加一倍。这就意味着当系统内存只有2GB，而Redis数据库的内存有1.5GB时，执行fork后内存使用量不会增加到3GB（超出物理内存）。为此需要确保Linux系统允许应用程序申请超过可用内存（物理内存和交换分区）的空间，方法是在/etc/sysctl.conf文件中加入vm.overcommit_memory=1，然后重启系统或者执行sysctl vm.overcommit_memory=1确保设置生效。另外需要注意的是，当进行快照的过程中，如果写入操作较多，造成fork前后数据差异较大，是会使得内存占用量显著超过实际数据大小的，因为内存中不仅保存了当前的数据库数据，而且保存着fork时刻的内存数据。进行内存用量估算时很容易忽略这一问题，造成内存用量超限。 </strong> </p><p>通过上述过程可以发现Redis在进行快照的过程中不会修改RDB文件，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。这使得我们可以通过定时备份RDB文件来实现Redis数据库备份。RDB文件是经过压缩（可以配置rdbcompression）的二进制格式，所以占用的空间会小于内存中的数据大小，更加利于传输。<br>Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将一个记录1000万个字符串类型建、大小为1GB的快照文件载入到内存中需要花费20~30秒。<br>通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能否接受的范围。例如，使用Redis存储缓存数据时，丢失最近几秒的数据或者丢失最近更新的几十个键并不会有很大的影响。如果数据相对重要，希望将损失降到最小，则可以使用AOF方式进行持久化。  </p><h2 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h2><p>当使用Redis存储非临时数据时，一般需要打开AOF持久化来降低进程终止导致的数据丢失。AOF可以将Redis执行的每一条写命令追加到硬盘文件中，这一过程显然会降低Redis性能，但是大部分情况下这个影响是可以接受的，另外使用较快的硬盘可以提高AOF的性能。  </p><h3 id="1、开启AOF"><a href="#1、开启AOF" class="headerlink" title="1、开启AOF"></a>1、开启AOF</h3><p>默认情况下Redis没有开始AOF（append only file）方式的持久化，可以通过appendonly参数启用：</p><pre><code>appendonly yes  </code></pre><p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof，可以通过appendfilename参数修改：  </p><pre><code>appendfilename appendonly.aof  </code></pre><h3 id="2、AOF实现"><a href="#2、AOF实现" class="headerlink" title="2、AOF实现"></a>2、AOF实现</h3><p>AOF文件以纯文本的形式记录了Redis执行的写命令，例如在开启AOF持久化的情况下执行了如下4个命令:  </p><pre><code>SET foo 1SET foo 2SET foo 3GET foo  </code></pre><p>Redis会将前3条命令写入AOF文件中。AOF文件内容为Redis客户端向Redis发送的原始通信协议的内容，从中可见Redis确实只记录了前3条命令。然而这时有一个问题是前2条命令其实都是冗余的，因为这2执行结果会第三条命令覆盖。随着执行的命令越来越多，AOF文件的大小也会越来越大，即使内存中实际的数据可能并没有多少。很自然地，我们希望Redis可以自动优化AOF文件，就上例而言，就是将前两条无用的记录删除，只保留第三条。实际上Redis也正是这样做的，每当达到一定条件时Redis就会自动重写AOF文件，这个条件可以在配置文件中设置：  </p><pre><code>auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb  </code></pre><p>auto-aof-rewrite-percentage参数的意义是当目前的AOF文件大小超过上一次重写时的AOF文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时的AOF文件大小为依据。auto-aof-rewrite-min-size参数限制了允许重写的最小AOF文件大小，通常在AOF文件很小的情况下即使其中有很多冗余的命令我们也并不太关心。除了让Redis自动执行重写外，我们还可以主动使用BGREWRITEAOF命令手动执行AOF重写。重写的过程只和内存中的数据有关，和之前的AOF文件无关，这与RDB很相似，只不过二者的文件格式完全不同。在启动时Redis会逐个执行AOF文件中的命令来将硬盘中的数据载入到内存中，载入的速度相对RDB会慢一些。  </p><h3 id="3、同步硬盘数据"><a href="#3、同步硬盘数据" class="headerlink" title="3、同步硬盘数据"></a>3、同步硬盘数据</h3><p>虽然每次执行更改数据库内容的操作时，AOF都会将命令记录在AOF文件中，但是事实上，由于操作系统的缓存机制，数据并没有真正的写入硬盘，而是进入了系统的硬盘缓存。在默认情况下系统每30秒回执行一次同步操作，以便将硬盘缓存中的内容真正地写入硬盘，在这30秒的过程中如果系统异常退出则会导致缓存中的数据丢失。一般来讲启用AOF持久化的应用都无法容忍这样的损失，这就需要Redis在写入AOF文件后主动要求系统将缓存内容同步到硬盘中。在Redis中我们可以通过appendfsync参数设置同步机制：  </p><pre><code>#appendfsync alwaysappendfsync everysec#appendfsync no   </code></pre><p>默认情况下Redis采用everysec规则，即每秒执行一次同步操作。always表示每次执行写入都会执行同步，这是最安全也是最慢的方式。no表示不主动进行同步操作，而是完全交由操作系统来做（即每30秒一次），这是最快但最不安全的方式。一般情况下使用默认值everysec就足够了，即兼顾了性能又保证了安全。<br>Redis允许同时开启AOF和RDB，既保证了数据安全又使得进行备份等操作十分容易。此时重新启动Redis后Redis会使用AOF文件来恢复数据，因为AOF方式的持久化可能丢失的数据更少。  </p>]]></content>
    
    <summary type="html">
    
      通过redis的RDB和AOF两种持久化选择适当场景下的安全处理方式
    
    </summary>
    
      <category term="redis系列" scheme="http://xym-loveit.github.io/categories/redis%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="redis持久化" scheme="http://xym-loveit.github.io/tags/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
      <category term="redis的AOF持久化" scheme="http://xym-loveit.github.io/tags/redis%E7%9A%84AOF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
      <category term="redis的RDB持久化" scheme="http://xym-loveit.github.io/tags/redis%E7%9A%84RDB%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>redis入门指南之Lua脚本</title>
    <link href="http://xym-loveit.github.io/2017/06/01/redis%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E4%B9%8BLua%E8%84%9A%E6%9C%AC/"/>
    <id>http://xym-loveit.github.io/2017/06/01/redis入门指南之Lua脚本/</id>
    <published>2017-06-01T02:29:19.000Z</published>
    <updated>2018-03-29T01:27:48.639Z</updated>
    
    <content type="html"><![CDATA[<h6 id="重要星级-★★★★★"><a href="#重要星级-★★★★★" class="headerlink" title="重要星级 ★★★★★"></a>重要星级 ★★★★★</h6><hr><p>在进阶章节讲到实现访问频率限制功能，用来限制一个IP地址1分钟最多只能访问100次：  </p><pre><code>$isKeyExists=EXISTS rate.limiting:$IPif $isKeyExists is 1    $times=INCR rate.limiting:$IP    if $times&gt;100        print 访问频率超过限制，请稍后再试        exitelse    MULTI    INCR rate.limiting:$IP    EXPIRE $keyName,60    EXEC  </code></pre><p>当时提到上面的代码会出现竞态条件，解决方法是用WATCH命令检测rate.limiting:$IP键的变动，但是这样做比较麻烦，而且还需要判断事务是否因为键被改动而没有执行。除此之外这段代码在不适用管道的情况下最多要向Redis请求5条命令，在网络传输上会浪费很多时间。<br>我们这时最希望就是Redis直接提供一个“RATELIMITING”命令用来实现访问频率限制功能，这个命令只需要我们提供键名、时间限制和在时间限制内最多访问的次数三个参数就可以直接返回访问频率是否超限。就像下面这样：  </p><pre><code>if RATELIMITING rate.limiting:$IP,60 100    print 访问频率超过限制，请稍后再试else     #没有超限，其他业务处理  </code></pre><p>这种方式不仅代码简单、没有竞态条件（Redis的命令都是原子的），而且减少了通过网络发送和接收命令的传输开销。然而可惜的是Redis并没有提供这个命令，不过我们可以使用Redis脚本功能自己定义新的命令。  </p><h3 id="1、脚本介绍"><a href="#1、脚本介绍" class="headerlink" title="1、脚本介绍"></a>1、脚本介绍</h3><p>Redis在2.6版推出了脚本功能，允许开发者用Lua语言编写脚本传到Redis中执行。在Lua脚本中可以调用大部分的Redis命令，也就是说可以写一段Lua脚本发送给Redis执行。使用脚本的好处：<br>（1）减少网络开销。复合操作需要向Redis发送多次请求，如上例，而是用脚本功能完成同样的操作只需要发送一个请求即可，减少了网络往返时延。<br>（2）原子操作。Redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。换句话说在编写脚本的过程中无需担心会出现竞态条件，也就无需使用事务。事务可以完成的所有功能都可以用脚本来实现。<br>（3）复用。客户端发送的脚本会永久存储在Redis中，这就意味着其他客户端（可以是其他语言开发的项目）可以复用这一脚本而不需要使用代码完成同样的逻辑。  </p><h3 id="2、实例：访问频率限制"><a href="#2、实例：访问频率限制" class="headerlink" title="2、实例：访问频率限制"></a>2、实例：访问频率限制</h3><p>因为无需考虑事务，使用Redis脚本实现访问频率限制非常简单。Lua代码如下：  </p><pre><code>local time=redis.call(&apos;incr&apos;,KEYS[1])if times==1 then --KEYS[1]键刚创建，所以为其设置生存时间    redis.call(&apos;expire&apos;,KEYS[1],ARGV[1])endif times &gt;tonumber(ARGV[2]) then    return 0endreturn 1  </code></pre><p>这段代码实现的功能与我们之前所做的类似，不过简洁了很多，即使不了解Lua语言也能猜出来大概意思。那么，该如何测试这个脚本呢？首先我们把这段代码存为ratelimiting.lua然后在命令行输入：<br>redis-cli –eval /path/to/ratelimiting.lua rate.limiting:127.0.0.1 , 10 3，其中–eval参数是告诉redis-cli读取并运行后面的Lua脚本，/path/to/ratelimiting.lua是ratelimiting.lua文件的位置，后面跟着的是传给Lua脚本的参数。其中“，”前的rate.limiting:127.0.0.1是要操作的键，可以在脚本中使用KEYS[1]获取，“，”后面的10和3是参数，在脚本中能够使用ARGV[1]/ARGV[2]获得。结合脚本的内容可知这行命令的作用是将访问频率限制为每10秒最多3次，所以在终端中不断地运行此命令会发现当访问频率在10秒内小于或等于3次时返回1，否则返回0。<br><strong>注意：上面命令中的“，”两边的空格不能省略，否则会出错。</strong>  </p><h2 id="Lua-语法学习"><a href="#Lua-语法学习" class="headerlink" title="Lua 语法学习"></a>Lua 语法学习</h2><p>请参见一些网络学习地址或学习书籍，本人收集地址如下：</p><blockquote><p><a href="http://book.luaer.cn/" target="_blank" rel="noopener">Lua程序设计</a><br><a href="http://manual.luaer.cn/" target="_blank" rel="noopener">Lua在线手册</a><br><a href="http://lua-users.org/wiki/" target="_blank" rel="noopener">Lua WIKI</a><br><a href="https://github.com/wenquan0hf/lua/blob/master/TOC.md" target="_blank" rel="noopener">GitHub Lua教程</a><br><a href="http://www.runoob.com/lua/lua-tutorial.html" target="_blank" rel="noopener">Lua菜鸟教程</a>  </p></blockquote><h2 id="Redis与Lua"><a href="#Redis与Lua" class="headerlink" title="Redis与Lua"></a>Redis与Lua</h2><p>编写Redis脚本的目的就是读写Redis的数据，本章主要介绍Redis与Lua交互的方法。  </p><h3 id="1、在脚本中调用Redis命令"><a href="#1、在脚本中调用Redis命令" class="headerlink" title="1、在脚本中调用Redis命令"></a>1、在脚本中调用Redis命令</h3><p>在脚本中可以使用redis.call函数调用Redis命令。就像这样：  </p><pre><code>redis.call(&apos;set&apos;,&apos;foo&apos;,&apos;bar&apos;)local value=redis.call(&apos;get&apos;,&apos;foo&apos;) --value的值为bar</code></pre><p>redis.call函数的返回值就是Redis命令的执行结果。Redis命令的返回值有5种类型，redis.call函数会将这5种类型的回复转换成对应的Lua的数据类型，具体的对应规则如下表（空结果比较特殊，其对应为Lua的false）。 </p><table><thead><tr><th>Redis返回值类型</th><th>Lua数据类型</th></tr></thead><tbody><tr><td>整数回复</td><td>数字类型</td></tr><tr><td>字符串回复</td><td>字符串类型</td></tr><tr><td>多行字符串回复</td><td>表类型（数组形式）</td></tr><tr><td>状态回复</td><td>表类型（只有一个ok字段存储状态信息）</td></tr><tr><td>错误回复</td><td>表类型（只有一个err字段存储错误信息）  </td></tr></tbody></table><p>Redis还提供了了redis.pcall函数，功能与redis.call相同，唯一区别是当命令执行出错时redis.pcall会记录错误并继续执行，而redis.call会直接返回错误，不会继续执行。  </p><h3 id="2、从脚本中返回值"><a href="#2、从脚本中返回值" class="headerlink" title="2、从脚本中返回值"></a>2、从脚本中返回值</h3><p>在很多情况下都需要脚本返回值，比如前面的访问频率限制脚本会返回频率是否超限。在脚本中可以使用return语句将值返回给客户端，如果没有执行return语句则会默认返回nil。因为我们可以向调用其他Redis内置命令一样调用我们自己写的脚本，所以同样Redis会自动将脚本返回值的Lua数据类型转换成Redis的返回值类型。具体的转换规则见下表（其中Lua的false比较特殊，会被转换成空结果）。  </p><table><thead><tr><th>Lua数据类型</th><th>Redis返回值类型</th></tr></thead><tbody><tr><td>数字类型</td><td>整数回复（Lua的数字类型会被自动转换成整数）</td></tr><tr><td>字符串类型</td><td>字符串回复</td></tr><tr><td>表类型（数组形式）</td><td>多行字符串回复</td></tr><tr><td>表类型（只有一个ok字段存储状态信息）</td><td>状态回复</td></tr><tr><td>表类型（只有一个err字段存储错误信息）</td><td>错误回复  </td></tr></tbody></table><h3 id="3、脚本相关命令"><a href="#3、脚本相关命令" class="headerlink" title="3、脚本相关命令"></a>3、脚本相关命令</h3><h4 id="1-EVAL命令"><a href="#1-EVAL命令" class="headerlink" title="1.EVAL命令"></a>1.EVAL命令</h4><p>编写完脚本后最重要的就是在程序中执行脚本。Redis提供了EVAL命令可以使开发者像调用其他Redis内指命令一样调用脚本。EVAL命令的格式是：EVAL 脚本内容 key参数的数量 [key…] [arg …]。可以通过key和arg这两类参数向脚本传递数据，他们的值可以在脚本中分别使用KEYS和ARGV两个类型的全局变量访问。比如希望用脚本功能实现一个SET命令,脚本内容是这样：  </p><pre><code>return redis.call(&apos;SET&apos;,KEYS[1],ARGV[1])  </code></pre><p>现在打开redis-cli执行此脚本</p><pre><code>127.0.0.1:6379&gt; eval &quot;return redis.call(&apos;SET&apos;,KEYS[1],ARGV[1])&quot; 1 foo barOK127.0.0.1:6379&gt; get foo&quot;bar&quot;  </code></pre><p>其中要读写的键名应该作为key参数，其他的数据都作为arg参数。<br><strong>注意：EVAL命令依据第二个参数将后面的所有参数分别存入脚本中的KEYS和ARGV两个表类型的全局变量中。当脚本不需要任务参数时也不能省略这个参数（设为0）</strong>。  </p><h4 id="2-EVALSHA命令"><a href="#2-EVALSHA命令" class="headerlink" title="2.EVALSHA命令"></a>2.EVALSHA命令</h4><p>考虑到在脚本比较长的情况下，如果每次调用脚本都需要将这个脚本传给Redis会占用较多的带宽。为了解决这个问题，Redis提供了EVALSHA命令允许开发者通过脚本内容的SHA1摘要来执行脚本，改命令的用法和EVAL一样，只不过是将脚本内容替换成脚本内容的SHA1摘要。<br>Redis在执行EVAL命令时会计算脚本的SHA1摘要并记录在脚本缓存中，执行EVALSHA命令时Redis会根据提供的摘要从脚本缓存中查找对应的脚本内容，如果找到了则执行脚本，否则会返回错误：“NOSCRIPT No matching script.Please use EVAL.”,在程序中使用EVALSHA命令的一般流程：<br>（1）先计算脚本的SHA1摘要，并使用EVALSHA命令执行脚本。<br>（2）获得返回值，如果返回“NOSCRIPT”错误则使用EVAL命令重新执行脚本。<br>虽然这一流程略显麻烦，但值得庆幸的是很多编程语言的Redis客户端都会代替开发者完成这一流程。比如使用node_redis客户端执行EVAL命令时，node_redis会先尝试执行EVALSHA命令，如果失败才会执行EVAL命令。  </p><h2 id="深入脚本"><a href="#深入脚本" class="headerlink" title="深入脚本"></a>深入脚本</h2><h3 id="1、KEYS与ARGV"><a href="#1、KEYS与ARGV" class="headerlink" title="1、KEYS与ARGV"></a>1、KEYS与ARGV</h3><p>前面提到过向脚本传递参数分为KEYS和ARGV两类，前者表示要操作的键名，后者表示非键名参数。但事实上这一要求并不是强制的，比如 EVAL “return redis.call(‘get’,KEYS[1])” 1 user:Bob可以获得user:Bob的键值，同样还可以使用EVAL “return redis.call(‘get’,’user:’ .. ARGV[1])” 0 Bob完成同样的功能，此时我们虽然并未按照Redis的规则使用KEYS参数传递键名，但还是获得了正确的结果。<br>虽然规则不是强制的，但不遵守规则依然有一定代价。Redis3.0版带有集群的功能，集群的作用是将数据库中的键分散到不同的节点上。这意味着在脚本执行前就需要知道脚本会操作哪些键以便于找到对应的节点，所以如果脚本中的键名没有使用KEYS参数传递则无法兼容集群。  </p><h3 id="2、沙盒与随机数"><a href="#2、沙盒与随机数" class="headerlink" title="2、沙盒与随机数"></a>2、沙盒与随机数</h3><p>Redis脚本禁止使用Lua标准库中与文件或系统调用相关函数，在脚本中只允许对Redis的数据进行处理。并且Redis还通过禁用脚本的全局变量的方式保证每个脚本都要是相对隔离的，不会相互干扰。<br>使用沙盒不仅是为了保证服务器的安全性，而且还确保了脚本的执行结果只和脚本本身和执行时传递的参数有关，不依赖外界条件（如 系统时间、系统中某个文件内容、其他脚本执行结果等。）这是因为在执行复制和AOF持久化操作时记录的是脚本的内容而不是脚本调用命令，所以必须保证在脚本内容和参数一样的前提下的执行结果是一样的。  </p><h3 id="3、其他脚本相关命令"><a href="#3、其他脚本相关命令" class="headerlink" title="3、其他脚本相关命令"></a>3、其他脚本相关命令</h3><p>除了EVAL和EVALSHA外，Redis还提供了了其他4个脚本相关的命令，一般都会被客户端封装起来，开发者很少能使用到。<br>（1）、将脚本加入缓存：SCRIPT LOAD<br>每次执行EVAL命令时Redis都会将脚本的SHA1摘要加入到脚本缓存中，以便下次客户端可以使用EVALSHA命令调用该脚本。如果只是希望将脚本加入脚本缓存而不执行则可以使用SCRIPT LOAD命令，返回值是脚本的SHA1摘要。如：  </p><pre><code>127.0.0.1:6379&gt; script load &quot;return 1&quot;&quot;e0e1f9fabfc9d4800c877a703b823ac0578ff8db&quot;  </code></pre><p>（2）、判断脚本是否已经被缓存：SCRIPT EXISTS<br>SCRIPT EXISTS 命令可以同时查找1个或多个脚本的SHA1摘要是否被缓存，如：  </p><pre><code>127.0.0.1:6379&gt; script exists e0e1f9fabfc9d4800c877a703b823ac0578ff8db1) (integer) 1  </code></pre><p>（3）、清空脚本缓存：SCRIPT FLUSH<br>Redis将脚本的SHA1摘要加入到脚本缓存后会永久保留，不会删除，但可以手动使用SCRIPT FLUSH命令清空脚本缓存：  </p><pre><code>127.0.0.1:6379&gt; script flushOK  </code></pre><p>（4）、强制终止当前脚本的执行：SCRIPT KILL<br>如果想终止当前正在执行的脚本可以使用SCRIPT KILL命令。  </p><h3 id="4、原子性和执行时间"><a href="#4、原子性和执行时间" class="headerlink" title="4、原子性和执行时间"></a>4、原子性和执行时间</h3><p>Redis的脚本执行时原子的，即脚本执行期间Redis不会执行其他命令。所有的命令都必须等待脚本执行完成后才能执行。为了防止某个脚本执行时间过长导致Redis无法提供服务（比如陷入死循环），Redis提供了<strong>lua-time-limit</strong>参数限制脚本的最长运行时间，默认为5秒钟。当脚本运行时间超过这一限制后，Redis将开始接受其他命令但不会执行（以确保脚本的原子性，因为此时脚本并没有被终止），而是会返回“BUSY”错误。限制我们可以打开2个redis-cli实例A和B来测试一下。首先A中执行一个死循环脚本：  </p><pre><code>127.0.0.1:6379&gt; eval &quot;while true do end&quot; 0  --死循环  </code></pre><p>然后在另一个B客户端执行一条命令:  </p><pre><code>127.0.0.1:6379&gt; get foo(error) BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.  </code></pre><p>这时实例B中命令并没有马上返回结果，因为、Redis已经被实例A发送的死循环脚本阻塞了，无法执行其他命令。且等待5秒钟之后实例B收到了“BUSY”错误，此时Redis虽然可以接受任何命令，但实际会执行的只有两个命令：SCRIPT KILL 和SHUTDOWN NOSAVE。在实例B中执行SCRIPT KILL命令可以终止当前脚本的运行，并且此时实例A中会返回错误:  </p><pre><code>--实例A127.0.0.1:6379&gt; script killOK  --实例B127.0.0.1:6379&gt; eval &quot;while true do end&quot; 0(error) ERR Error running script (call to f_694a5fe1ddb97a4c6a1bf299d9537c7d3d0f84e7): @user_script:1: Script killed by user with SCRIPT KILL... (343.29s)</code></pre><p>需要注意的是如果当前执行的脚本对Redis的数据进行了修改（如调用SET、LPUSH或DEL等命令）则SCRIPT KILL 命令不会终止脚本的运行以防止脚本只执行了一部分。因为如果脚本只执行了一部分就被终止，会违背脚本的原子性要求，即脚本中的所有命令都要么执行，要么都不执行。比如在实例A中执行：  </p><pre><code>127.0.0.1:6379&gt; eval &quot;redis.call(&apos;SET&apos;,&apos;foo&apos;,&apos;bar&apos;) while true do end&quot; 0--死循环卡住  </code></pre><p>5秒钟后尝试在B中终止该脚本：  </p><pre><code>127.0.0.1:6379&gt; script kill(error) UNKILLABLE Sorry the script already executed write commands against the dataset. You can either wait the script termination or kill the server in a hard way using the SHUTDOWN NOSAVE command.  </code></pre><p>这是只能通过SHUTDOWN NOSAVE命令强制终止Redis。SHUTDOWN NOSAVE命令与SHUTDOWN命令的区别在于前者将不会进行持久化操作，这意味着所有发生在上一次快照后的数据库修改都会丢失。由于Redis脚本非常高效，所以在大部分情况下都不用担心脚本的性能。但同时由于脚本的强大功能，很多原本在程序中执行的逻辑都可以放到脚本中执行，这时就需要开发者根据具体的应用权衡到底哪些任务适合交给脚本。通常来说不应该在脚本中进行大量耗时的运算，因为毕竟Redis是单进程单线程执行脚本，而程序却能够多进程多线程运行。  </p>]]></content>
    
    <summary type="html">
    
      使用Redis的Lua编程脚本，实现复杂的复合操作，实现原子操作避免竞态条件。
    
    </summary>
    
      <category term="redis系列" scheme="http://xym-loveit.github.io/categories/redis%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="redis使用Lua脚本" scheme="http://xym-loveit.github.io/tags/redis%E4%BD%BF%E7%94%A8Lua%E8%84%9A%E6%9C%AC/"/>
    
      <category term="Lua脚本" scheme="http://xym-loveit.github.io/tags/Lua%E8%84%9A%E6%9C%AC/"/>
    
      <category term="EVAL及EVALSHA" scheme="http://xym-loveit.github.io/tags/EVAL%E5%8F%8AEVALSHA/"/>
    
      <category term="KEYS与ARGV" scheme="http://xym-loveit.github.io/tags/KEYS%E4%B8%8EARGV/"/>
    
  </entry>
  
  <entry>
    <title>redis入门指南之提高篇III</title>
    <link href="http://xym-loveit.github.io/2017/05/26/redis%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E4%B9%8B%E6%8F%90%E9%AB%98%E7%AF%87III/"/>
    <id>http://xym-loveit.github.io/2017/05/26/redis入门指南之提高篇III/</id>
    <published>2017-05-26T10:21:49.000Z</published>
    <updated>2018-03-29T01:27:48.644Z</updated>
    
    <content type="html"><![CDATA[<h6 id="重要星级-★★★★★"><a href="#重要星级-★★★★★" class="headerlink" title="重要星级 ★★★★★"></a>重要星级 ★★★★★</h6><hr><h2 id="消息通知"><a href="#消息通知" class="headerlink" title="消息通知"></a>消息通知</h2><p>任务队列顾名思义，就是“传递任务的队列”。与任务队列进行交互的尸体有两类，一类是生产者（producer），一类是消费者（consumer）。生产者会将需要处理的任务放入队列中，而消费者则不断地从队列中读入任务信息并执行。<br>使用任务队列有如下好处：<br>（1）松耦合。生产者和消费者无需知道彼此的实现细节，只需要约定好任务的描述格式。这使得生产者和消费者可以由不同的团队使用不同的编程语言编写。<br>（2）易于扩展消费者可以有多个，而且可以分布在不同的服务器中，借此可以轻易地降低单台服务器的负载。</p><p><img src="http://op7wplti1.bkt.clouddn.com/producerandConsumer.png" alt="多个消费者消费生产者放入队列的任务"></p><h3 id="1、Redis实现任务队列"><a href="#1、Redis实现任务队列" class="headerlink" title="1、Redis实现任务队列"></a>1、Redis实现任务队列</h3><p>说到任务队列自然想到之前介绍的LPUSH和RPOP命令实现队列的概念。如果要实现队列，只需要让生产者将任务使用LPUSH命令加入某个键中，另一边让消费者不断地使用RPOP命令从该键中取出任务即可。消费者伪代码如下：  </p><pre><code>loop //无限循环读取任务队列中的内容    $task=RPOP queue    if $task        //如果任务队列中有任务执行它        execute($task)    else        //如果没有则等待1秒以免过于频繁请求数据        wait 1 second</code></pre><p>到此一个使用Redis实现的简单任务队列就写好了。不好还有一点不完美的地方:当任务队列中没有任务时消费者每秒都会调用一次RPOP命令查看是否有新任务。如果可以实现一旦有新任务队列就通知消费者就好了。其实借助BRPOP命令就可以实现这一的需求。<br>BRPOP命令和RPOP命令相似，唯一的区别是当列表中没有元素时BRPOP命令会一直阻塞住连接，知道有新元素加入。如上代码可改为： </p><pre><code>loop    //如果任务队列中没有新任务，BRPOP命令会一直阻塞，不会执行execute()。    $task=BRPOP queue,0    //返回值是数组，数组第二个元素时我们需要的任务。    execute($task[1])</code></pre><p>BRPOP命令接受2个参数，第一个是键名，第二个是超时时间，单位是秒。当超过了此时间仍然没有获得新元素就会返回nil。上例中超时时间为“0”，表示不限制等待的时间，即如果没有新元素加入列表就会永远组塞下去。<br>当获得一个元素后BPOP命令返回二个值，分别是键名和元素值。为了测试BPOP命令，我们可以打开2个redis-cli实例，在实例A中：  </p><pre><code>127.0.0.1:6379&gt; brpop queue 0</code></pre><p>键入回车后实例1会处于阻塞状态，这时在实例B中向queue中加入一个元素： </p><pre><code>127.0.0.1:6379&gt; lpush queue task(integer) 1</code></pre><p>在LPUSH命令执行后实例A马上就返回了结果： </p><pre><code>127.0.0.1:6379&gt; brpop queue 01) &quot;queue&quot;2) &quot;task&quot;(73.70s)</code></pre><p>同时会发现queue中的元素已经被取走： </p><pre><code>127.0.0.1:6379&gt; llen queue(integer) 0</code></pre><p>除了BRPOP命令外，Redis还提供了BLPOP，和BRPOP的区别在于从队列取元素时BLPOP会从左边取。  </p><h3 id="2、优先级队列"><a href="#2、优先级队列" class="headerlink" title="2、优先级队列"></a>2、优先级队列</h3><p>BRPOP命令可以同时接受多个键，其完整的命令格式为BRPOP key [key …] timeout，如BRPOP queue:1 queue:2 0。意义是同时检测多个键，如果所有键都没有元素则阻塞，如果其中有一个键有元素则会从该键中弹出元素。例如，打开两个redis-cli实例，在实例A中:  </p><pre><code>127.0.0.1:6379&gt; BLPOP queue:1 queue:2 queue:3 0</code></pre><p>在实例B中：  </p><pre><code>127.0.0.1:6379&gt; lpush queue:2 task(integer) 1</code></pre><p>则实例A中返回： </p><pre><code>1) &quot;queue:2&quot;2) &quot;task&quot;(15.54s)</code></pre><p>如果多个键都有元素则按照从左到右的顺序取第一个的一个元素。我们现在queue:2和queue:3中各加入一个元素： </p><pre><code>127.0.0.1:6379&gt; lpush queue:2 task2(integer) 1127.0.0.1:6379&gt; lpush queue:3 task3(integer) 1</code></pre><p>然后执行BRPOP命令：  </p><pre><code>127.0.0.1:6379&gt; BRPOP queue:1 queue:2 queue:3 01) &quot;queue:2&quot;2) &quot;task2&quot;</code></pre><p>借此特性可以实现区分优先级的任务队列。我们分别使用queue:confirm.email和queue：notification.email两个键存储发送确认邮件（注册网站需要发送确认邮箱正确性邮件）和发送通知邮件（一旦有新博客文章就发送邮件信息提醒）两种任务，然后将消费者的代码改为： </p><pre><code>loop    $task=BRPOP queue:confirm.email,queue:notification.email,0    execute($task[1])</code></pre><p>这时一旦发送确认邮件的任务被加入到queue:confirm.email队列中，无论queue:notification.email还有多少任务，消费者都会优先完成发送确认邮件的任务。  </p><h3 id="3、发布-订阅模式"><a href="#3、发布-订阅模式" class="headerlink" title="3、发布/订阅模式"></a>3、发布/订阅模式</h3><p>除了实现任务队列外，Redis还提供了一组命令可以让开发者实现“发布/订阅”（publish/subscribe）模式。“发布/订阅”模式同样可以实现进程间的消息传递，其原理是这样的：<br>“发布/订阅”模式中包含两种角色，分别是发布者和订阅者。订阅者可以订阅一个或若干个频道（channel），而发布者可以向指定的频道发送消息，所有订阅此频道的订阅者都会收到此消息。发布者发布消息的命令是publish，用法是publish channel message，如向channel1.1发送“hello”： </p><pre><code>127.0.0.1:6379&gt; publish channel1.1 hello(integer) 0</code></pre><p>这样消息就发出去了。PUBLISH命令的返回值表示接收到这条消息的订阅者数量。因为此时没有客户端订阅channel1.1，所以返回0。发出去的消息不会被持久化，也就是说当有客户端订阅channel1.1后只能收到后续发布到该频道的消息，之前发送的就收不到了。订阅频道的命令时SUBSCRIBE，可以同时订阅多个频道，用法是SUBSCRIBE channel [channel …]。现在新开一个redis-cli实例A，用它来订阅channel1.1： </p><pre><code>127.0.0.1:6379&gt; subscribe channel1.1Reading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;channel1.1&quot;3) (integer) 1</code></pre><p>执行SUBSCRIBE命令后客户端会进入订阅状态，处于此状态下的客户端不能使用除SUBSCRIBE/UNSUBSCRIBE/PSUBSCRIBE/PUNSUBSCRIBE这4个属于“发布/订阅”模式的命令之外的其他命令，否则会报错。<br>进入订阅状态后客户端可能收到三种类型的回复。每种类型的回复都包含3个值，第一个值是消息的类型，根据消息类型的不同，第二、第三个值的含义也不同。消息类型可能取值有：<br>（1）Subscribe。表示订阅成功的反馈信息。第二个值是订阅成功的频道名称，第三个值是当前客户端订阅的频道数量。<br>（2）message。这个类型的回复使我们最关心的，它表示接受到的消息。第二个值表示产生消息的频道名称，第三个是消息的内容。<br>（3）unsubscribe。表示成功取消订阅某个频道。第二个值是对应的频道名称，第三个值是当前客户端订阅频道的数量，当此值为0时客户端会退出订阅状态，之后就可以执行其他非“发布/订阅”模式的命令了。<br>上例中当实例A订阅了channel1.1进入订阅状态后收到了一条subscribe类型的回复，这时我们打开另一个redis-cli实例B，并向channel1.1发送一条消息：  </p><pre><code>127.0.0.1:6379&gt; publish channel1.1 hello(integer) 1</code></pre><p>返回值为1表示有一个客户端订阅了channel1.1，此时实例A收到了类型为message的回复：<br>127.0.0.1:6379&gt; subscribe channel1.1</p><pre><code>Reading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;channel1.1&quot;3) (integer) 11) &quot;message&quot;2) &quot;channel1.1&quot;3) &quot;hello&quot;</code></pre><p>使用UNSUBSCRIBE命令可以取消订阅指定的频道，用法为UNSUBSCRIBE [channel [channel…]]，如果不指定频道则会取消订阅所有频道。  </p><h3 id="4、按照规则订阅"><a href="#4、按照规则订阅" class="headerlink" title="4、按照规则订阅"></a>4、按照规则订阅</h3><p>除了可以使用SUBSCRIBE命令订阅指定名称的频道外，还可以使用PSUBSCRIBE命令订阅指定的规则。规则支持glob风格通配符格式，如：  </p><pre><code>127.0.0.1:6379&gt; psubscribe channel.?*Reading messages... (press Ctrl-C to quit)1) &quot;psubscribe&quot;2) &quot;channel.?*&quot;3) (integer) 1</code></pre><p>规则channel.?*可以匹配channel.1和channel.10但不会匹配channel.。这时在实例B中发送消息：  </p><pre><code>127.0.0.1:6379&gt; publish channel.1 hello(integer) 2</code></pre><p>返回结果是2因为2个实例客户端都订阅了channel.1频道。实例psubscribe channel.?*收到的回复是：  </p><pre><code>1) &quot;pmessage&quot;2) &quot;channel.?*&quot;3) &quot;channel.1&quot;4) &quot;hello&quot;</code></pre><p>第一个值表示这条消息是通过PSUBSCRIBE命令订阅频道而收到的======，第二个值表示订阅时用的通配符，第三个值表示实际收到的消息的频道，第四个值则是消息内容。 </p><p>提示：使用PSUBSCRIBE命令可以重复订阅一个频道，如某客户端执行了PSUBSCRIBE channel.? channel.?*，这时向channel.2发布消息后该客户端会收到2条消息，而同时PUBLISH命令返回的值也是2而不是1。同样的，如果有另一个客户端执行了SUBSCRIBE channel.10和PSUBSCRIBE channel.?*的话，向channel.10发送命令该客户端也会收到两条消息（但是是两种类型，message和pmessage），同时publish命令会返回2。<br>PUNSUBSCRIBE命令可以推定指定的规则，用法是PUNSUBSCRIBE [pattern [pattern …]]，如果没有参数则会退订所有规则。  </p><p><strong>注意：使用PUNSUBSCRIBE命令只能退订通过PSUBSCRIBE命令订阅的规则，不会影响直接通过SUBSCRIBE命令订阅的频道；同样UNSUBSCRIBE命令也不会影响通过PSUBSCRIBE命令订阅的规则。另外容易出错的是使用PUNSUBSCRIBE命令退订某个规则时不会将其中的通配符展开，而是进行严格的字符串匹配，所以PUNSUBSCRIBE * 无法退订channel.* 规则，而是必须使用PUNSUBSCRIBE channel.*才能退订。</strong>  </p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>客户端和Redis使用TCP协议连接。不论是客户端向Redis发送命令还是Redis向客户端返回命令的执行结果，都需要经过网络传输，这两个部分的总耗时称为往返时延。根据网络性能不同，往返时延也不同，大致来说到本地回环地址（loop back address）的往返时延在数量级上相当于Redis处理一条简单命令（如LPUSH list 1 2 3）的时间。如果执行较多的命令，每个命令的往返时延累加起来对性能还是有一定影响的。<br>在执行多个命令时每条命令都需要等待上一条命令执行完（即收到Redis的返回结果）才能执行，即使命令不需要上一条命令的执行结果。如要获得post:1、post:2和post:3这3个键中的title字段，需要执行三条命令，如下图：  </p><p><img src="http://op7wplti1.bkt.clouddn.com/executeCommand.png" alt="不使用管道时多条命令执行示意图">  </p><p>Redis的底层通信协议对管道（pipelining）提供了支持。通过管道可以一次性发动多条命令并在执行完后一次性将结果返回，当一组命令中每条命令都不依赖于之前命令的执行结果时就可以将这组命令一起通过管道发出。管道通过减少客户端与Redis的通信次数来实现降低往返时延累计值的目的，如下图：  </p><p><img src="http://op7wplti1.bkt.clouddn.com/pipeExecute.png" alt="管道执行多条命令示意图">  </p><h2 id="节省空间"><a href="#节省空间" class="headerlink" title="节省空间"></a>节省空间</h2><p>相比于硬盘而言，内存在今天仍然显得比较昂贵。而Redis是一个基于内存的数据库，所有的数据都存储在内存中，所以如何优化存储，减少内存空间占用对成本控制来说是一个非常重要的话题。  </p><h3 id="1、精简键名和键值"><a href="#1、精简键名和键值" class="headerlink" title="1、精简键名和键值"></a>1、精简键名和键值</h3><p>精简键名和键值是最直观的减少内存占用的方式，如将键名very.important.person:20改成VIP:20。当然精简键名一定要把握尺度，不能单纯为了节约空间而使用不易理解的键名（比如将VIP:20修改为V:20，这样既不易维护，还容易造成命名冲突）。又比如一个存储用户性别的字符串类型键的取值是male和female，我们可以将其修改成m和f来为每条记录节约几个字节空间（更好的办法是使用0和1来表示性别）。  </p><h3 id="2、内部编码优化"><a href="#2、内部编码优化" class="headerlink" title="2、内部编码优化"></a>2、内部编码优化</h3><p>有时候仅凭精简键名和键值所减少的空间并不足以满足需求，这时就需要根据Redis内部的编码规则来节省更多的空间。Redis为每种数据类型都提供了两种内部编码方式，以散列类型为例，散列类型是通过散列表实现，这样就可以实现O（1）时间复杂度的查找、赋值操作，然而当键中元素很少的时候，O（1）的操作并不会比O（n）有明显的性能提高，所以这种情况下Redis会采用一种更为紧凑但性能稍差（获取元素的时间复杂度为O（n））的内部编码方式。内部编码方式的选择对于开发者来说是透明的，Redis会根据实际情况自动调整。当键中元素变多时Redis会自动将该键的内部编码方式转换成散列表。如果想查看一个键的内部编码方式可以使用OBJECT ENCODING 命令，如：  </p><pre><code>127.0.0.1:6379&gt; type score:2string127.0.0.1:6379&gt; get score:2&quot;100&quot;127.0.0.1:6379&gt; object encoding score:2&quot;int&quot;127.0.0.1:6379&gt; type post:5hash127.0.0.1:6379&gt; object encoding post:5&quot;ziplist&quot;</code></pre><p>Redis的每个键值都是使用一个redisObject结构体保存的，redisObject的定义如下：  </p><pre><code>typedef struct redisObject{    unsigned type:4;    unsigned notused:2;    unsigned encoding:4;    unsigned lru:22; /* lru time(relative to server.lruclock) */    int refcount;    void *ptr;} robj;</code></pre><p>其中type字段表示的是键值的数据类型，取值可以是如下内容：  </p><pre><code>#define REDIS_STRING 0#define REDIS_LIST 1#define REDIS_SET 2#define REDIS_ZSET 3#define REDIS_HASH 4</code></pre><p>encoding字段表示的就是Redis键值内部编码方式，取值如下：  </p><pre><code>#define REDIS_ENCODING_RAW 0 /* Raw representation */#define REDIS_ENCODING_INT 1 /* Encoded as integer */#define REDIS_ENCODING_HT 2  /* Encoded as hash table */#define REDIS_ENCODING_ZIPMAP 3 /* Encoded as zipmap */#define REDIS_ENCODING_LINKEDLIST 4 /* Encoded as regular linked list */#define REDIS_ENCODING_ZIPLIST 5 /* Encoded as ziplist */#define REDIS_ENCODING_INTSET 6 /* Encoded as intset */#define REDIS_ENCODING_SKIPLIST 7 /* Encoded as skiplist */</code></pre><p>各个数据类型可能采用的内部编码方式及其相应的OBJECT ENCODING 命令执行结果如下：  </p><p><img src="http://op7wplti1.bkt.clouddn.com/redisEncoding.png" alt="Redis每种数据类型都采用二种编码方式中的一种存储"></p><h4 id="1、字符串类型"><a href="#1、字符串类型" class="headerlink" title="1、字符串类型"></a>1、字符串类型</h4><p>Redis使用一个sdshdr类型的变量来存储字符串，而redisObject的ptr字段指向的是该变量的地址。sdshdr的定义如下： </p><pre><code>struct sdshdr{    int len;    int free;    char buf[];}</code></pre><p>其中len字段表示的是字符串的长度，free字段表示buf中的剩余空间，而buf字段存储的才是字符串的内容。所以当执行SET key foobar时，存储键值需要占用的空间是sizeof(redisObject)+sizeof(sdshdr)+strlen(“foobar”)=30字节，如下图：  </p><p><img src="http://op7wplti1.bkt.clouddn.com/strstructure.png" alt="字符串键值的存储结构">  </p><p>而当键值内容可以用一个64位有符号整数表示时，Redis会将键值转换成long类型来存储。如SET key 123456，实际占用空间是sizeof(redisObject)=16字节，比存储“foobar”节省了一般的存储空间，如下图：  </p><p><img src="http://op7wplti1.bkt.clouddn.com/strstructure2.png" alt="字符串键值的存储结构2">   </p><p>redisObject中的refcount字段存储的是该键值被引用数量，即一个键值可以被多个键引用。Redis启动后会预先建立10000个分别存储从0到9999这些数字的redisObject类型变量作为共享对象，如果要设置的字符串在这10000个数字内（如SET key1 123）则可以直接引用共享对象而不用再建立一个redisObject了，也就是说存储键值占用的空间是0字节，如下图：  </p><p><img src="http://op7wplti1.bkt.clouddn.com/shareObject.png" alt="Redis直接引用共享对象">  </p><p>由此可见，使用字符串类型键存储对象ID这种小数字是非常节省存储空间的，Redis只需存储键名和一个对共享对象的引用即可。<br><strong>提示：当通过配置文件参数maxmemory设置了Redis可用的最大空间大小时，Redis不会使用共享对象，因为对于每个键值都需要使用一个redisObject来记录其LRU信息。</strong>  </p><h4 id="2、散列类型"><a href="#2、散列类型" class="headerlink" title="2、散列类型"></a>2、散列类型</h4><p>散列类型的内部编码方式可能是REDIS_ENCODING_HT或REDIS_ENCODING_ZIPLIST。在配置文件中可以定义使用REDIS_ENCODING_ZIPLIST方式编码散列表类型的时机：  </p><pre><code>hash-max-ziplist-entries 512hash-max-ziplist-value 64</code></pre><p>当散列类型键的字段个数少于hash-max-ziplist-entries参数值且每个字段名和字段值的长度都小于hash-max-ziplist-value 参数值（单位为字节）时，Redis就会使用REDIS_ENCODING_ZIPLIST来存储该键，否则就会使用REDIS_ENCODING_HT。转换过程是透明的，每当键值变更后Redis都会自动判断是否满足条件来完成转换。  </p><p>REDIS_ENCODING_HT编码即散列表，可以实现O（1）时间复杂度的赋值取值等操作，其字段和字段值都是使用redisObject存储的，所以前面讲到的字符串类型键值的优化方法同样适用于散列类型键的字段和字段值。  </p><p>提示 Redis的键值对存储也是通过散列表实现的，与REDIS_ENCODING_HT编码方式类似，但键名并非使用redisObject存储，所以键名“123456”并不会比“abcdef”占用更少空间。之所以不对键名进行优化是因为绝大多数情况下键名都不会是纯数字。  </p><pre><code>补充知识 Redis支持多数据库，每个数据库中的数据都是通过结构体redisDb存储。redisDb的定义如下：  typedef struct redisDb{    dict *dict; /* The keyspace for this DB */    dict *expires; /* Timeout of keys with a timeout set */    dict *blocking_keys; /* Keys with clients waiting for data (BLPOP) */    dict *ready_keys; /* Blocked keys that received a PUSH */    dict *watched_keys; /* WATCHED keys for MULTI/EXEC CAS */    int id;} redisDb;dict类型就是散列表结构，expires存储的是数据的过期时间。当Redis启动时会根据配置文件中databases参数指定的数量创建若干个redisDb类型变量存储不同数据库中的数据。</code></pre><p>REDIS_ENCODING_ZIPLIST编码类型是一种紧凑的编码格式，它牺牲了部分读取性能以换取极高的空间利用率，适合在元素较少的时使用。该编码类型同样还在列表类型和有序集合类型中使用。REDIS_ENCODING_ZIPLIST编码结构下图所示:  </p><p><img src="http://op7wplti1.bkt.clouddn.com/REDIS_ENCODING_ZIPLIST_bmjg.png" alt="REDIS_ENCODING_ZIPLIST编码的内存结构"><br>其中zlbytes是uint32_t类型，表示整个结构占用的空间。zltail也是uint32_t类型，表示到最后一个元素的偏移，记录zltail是的程序可以直接定位到尾部元素而无需遍历整个结构，执行从尾部弹出（对列表类型而言）等操作时速度更快。zllen是uint16_t类型，存储的是元素的数量。zlend是一个单字节标识，标记结构的末尾，值永远是255。<br>在REDIS_ENCODING_ZIPLIST中每个元素由4个部分组成。第一个部分用来存储前一个元素的大小以实现倒序查找，当前一个元素的大小小于245字节时第一个部分占用1个字节，否则会占用5个字节。</p><p>第二、三个部分分别是元素的编码类型和元素大小，当元素的大小小于或等于63个字节时，元素的编码类型是ZIP_STR_06B（即0&lt;&lt;6），同时第三个部分用6个二进制位来记录元素的长度，所以第二、三个部分总占用空间是1字节。当元素的大小大于63且小于或等于16383字节时，第二、三个部分总占用空间是2字节。当元素的大小大于16383字节时，第二、三个部分总占用空间是5字节。<br>第四个部分是元素的实际内容，如果元素可以转换成数字的话Redis会使用相应的数字类型来存储以节省空间，并用第二、第三个部分来表示数字的类型（int16_t/int32_t等）。使用REDIS_ENCODING_ZIPLIST编码存储散列类型时元素的排列方式是：元素1存储字段1，元素2存储字段值1，以此类推，如下图：  </p><p><img src="http://op7wplti1.bkt.clouddn.com/REDIS_ENCODING_ZIPLIST_2.png" alt="使用REDIS_ENCODING_ZIPLIST编码存储散列类型内存结构">    </p><p>例如，当执行命令HSET hkey foo bar 命令后，hkey键值的内存结构如下图：  </p><p><img src="http://op7wplti1.bkt.clouddn.com/REDIS_ENCODING_ZIPLIST_3.png" alt="使用REDIS_ENCODING_ZIPLIST编码存储散列类型内存结构2">   </p><p>下次需要执行HSET hkey foo anothervalue 时Redis需要从头开始找到值为foo的元素（查找时每次都会跳过一个元素以保证只查找字段名），找到后删除其下一个元素，并将新值anothervalue 插入。删除和插入都需要移动后面的内存数据，而且查找操作也需要遍历才能完成，可想而知当散列键中的数据多时性能将很低，所以不宜将<strong>hash-max-ziplist-entries</strong>和<strong>hash-max-ziplist-value</strong> 两个参数设置得很大。  </p><h4 id="3、列表类型"><a href="#3、列表类型" class="headerlink" title="3、列表类型"></a>3、列表类型</h4><p>列表类型的内部编码方式可能是REDIS_ENCODING_LINKEDLIST或REDIS_ENCODING_ZIPLIST。同样在配置文件中可以使用REDIS_ENCODING_ZIPLIST方式编码的时机:  </p><pre><code>list-max-ziplist-entries 512list-max-ziplist-value 64</code></pre><p>具体转换方式和散列类型一样，REDIS_ENCODING_LINKEDLIST编码方式即双向链表，链表中的每个元素是用redisObject存储的，所以此种编码方式下的元素值的优化方法与字符串的键值相同。<br>而是用REDIS_ENCODING_ZIPLIST编码方式时具体的表现和散列类型一样，由于REDIS_ENCODING_ZIPLIST编码方式同样支持倒序访问，所以采用此种编码方式时获取两端的数据依然较快。  </p><h4 id="4、集合类型"><a href="#4、集合类型" class="headerlink" title="4、集合类型"></a>4、集合类型</h4><p>集合类型的内部编码方式可能是REDIS_ENCODING_HT或REDIS_ENCODING_INTSET。当集中的所有元素都是整数且元素的个数小于配置文件中的set-max-intset-entries参数指定值（默认512）时Redis会使用REDIS_ENCODING_INTSET编码存储该集合，否则会使用REDIS_ENCODING_HT来存储。REDIS_ENCODING_INTSET编码存储结构体intset的定义如下： </p><pre><code>typedef struct intset{    uint32_t encoding;    uint32_t length;    int8_t contents[];} intset;</code></pre><p>其中contents存储的就是集合中的元素值，根据encoding的不同，每个元素占用的字节大小不同。默认encoding是INTSET_ENC_INT16（即2个字节），当新增加的整数元素无法使用2个字节表示时，Redis会将该集合的encoding升级为INTSET_ENC_INT32（即2个字节）并调整之前所有元素的位置和长度，同样集合的encoding还可升级为INTSET_ENC_INT64（即8个字节）。<br>REDIS_ENCODING_INTSET编码以有序的方式存储元素（所以使用SMEMBERS命令获得的结果是有序的），使得可以使用二分算法查找元素。然后无论是添加还是删除元素，Redis都需要调整后面元素的内存位置，所以当集合中元素太多时性能较差。当新增加的元素不是整数或集合中的元素数量超过了set-max-intset-entries参数指定值时，Redis会自动将该集合的存储结构转换成REDIS_ENCODING_HT。  </p><h4 id="5、有序集合类型"><a href="#5、有序集合类型" class="headerlink" title="5、有序集合类型"></a>5、有序集合类型</h4><p>有序集合类型的内部编码方式可能是REDIS_ENCODING_SKIPLIST或REDIS_ENCODING_ZIPLIST。同样在配置文件中可以使用REDIS_ENCODING_ZIPLIST方式编码的时机:  </p><pre><code>zset-max-ziplist-entries 128zset-max-ziplist-value 64</code></pre><p>具体规则和散列表一样。当编码方式是REDIS_ENCODING_SKIPLIST时，Redis使用散列表和跳跃列表（skip list）两种数据结构来存储有序集合类型键值，其中散列表用来存储元素值与元素分数的映射关系以实现O（1）时间复杂度的ZSCORE等命令。跳跃列表用来存储元素的分数及其到元素值的映射以实现排序的功能。Redis对跳跃表的实现进行了几点修改，其中包括允许跳跃列表中的元素（即分数）相同，还有为跳跃链表每个节点增加了指向前一个元素的指针以实现倒序查找。采用此种编码方式时，元素值是使用redisObject存储的，所以可以使用字符串类型键值的优化方式优化元素值，而元素的分数是使用double类型存储的。<br>使用REDIS_ENCODING_ZIPLIST编码时有序集合存储的方式按照“元素1的值，元素1的分数，元素2的值，元素2的分数”的顺序排列，并且分数是有序的。</p>]]></content>
    
    <summary type="html">
    
      Redis中的任务队列（消费者/生产者模式）、发布订阅的使用、从Redis节省空间到详解Redis存储数据结构（节约内存必读）。
    
    </summary>
    
      <category term="redis系列" scheme="http://xym-loveit.github.io/categories/redis%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Redis任务队列" scheme="http://xym-loveit.github.io/tags/Redis%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    
      <category term="Redis优先级队列" scheme="http://xym-loveit.github.io/tags/Redis%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
    
      <category term="Redis发布订阅" scheme="http://xym-loveit.github.io/tags/Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/"/>
    
      <category term="Redis管道概念" scheme="http://xym-loveit.github.io/tags/Redis%E7%AE%A1%E9%81%93%E6%A6%82%E5%BF%B5/"/>
    
      <category term="Redis键值存储详解" scheme="http://xym-loveit.github.io/tags/Redis%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>redis入门指南之提高篇II</title>
    <link href="http://xym-loveit.github.io/2017/05/26/redis%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E4%B9%8B%E6%8F%90%E9%AB%98%E7%AF%87II/"/>
    <id>http://xym-loveit.github.io/2017/05/26/redis入门指南之提高篇II/</id>
    <published>2017-05-26T02:58:16.000Z</published>
    <updated>2018-03-29T01:27:48.644Z</updated>
    
    <content type="html"><![CDATA[<h6 id="重要星级-★★★★★"><a href="#重要星级-★★★★★" class="headerlink" title="重要星级 ★★★★★"></a>重要星级 ★★★★★</h6><hr><h2 id="Redis排序"><a href="#Redis排序" class="headerlink" title="Redis排序"></a>Redis排序</h2><h3 id="1、有序集合的集合操作"><a href="#1、有序集合的集合操作" class="headerlink" title="1、有序集合的集合操作"></a>1、有序集合的集合操作</h3><p>集合类型提供了强大的集合操作命令，但是如果需要排序就要用到有序集合类型。Redis作者在设计Redis的命令时考虑到了不同类型的使用场景，对于不常用到的或者在不损失过多性能的前提下可以使用现有命令来实现的功能，Redis就不会单独提供命令来实现。这一原则使得Redis在拥有强大功能的同时保持着相对精简的命令。<br>有序集合常见的使用场景是大数据排序，如游戏玩家排行榜，所有很少会需要获得键中的全部数据。同样Redis认为开发者在做完交集、并集运算后不需要直接获得全部结果，而是会希望将结果存入新的键中以便后续处理。这解释了为什么有序集合只有ZINTERSTORE和ZUNIONSTORE命令而没有ZINTER和ZUNION命令。<br>当然实际使用中确实会有直接获取集合运算结果的情况，除了等待Redis加入相关命令，我们还可以使用multi，zinterstore，zrange，del和exec这5个命令自己实现ZINTER。  </p><h3 id="2、SORT命令"><a href="#2、SORT命令" class="headerlink" title="2、SORT命令"></a>2、SORT命令</h3><p>SORT命令可以对列表类型、集合类型和有序集合类型键进行排序，并且可以完成与关系型数据库中的链接查询相类似的任务。如：  </p><pre><code>//对结合类型进行操作SMEMBERS tag:java:posts1) &quot;1&quot;2) &quot;2&quot;3) &quot;6&quot;4) &quot;10&quot;5) &quot;12&quot;127.0.0.1:6379&gt; sort tag:java:posts DESC1) &quot;12&quot;2) &quot;10&quot;3) &quot;6&quot;4) &quot;2&quot;5) &quot;1&quot;//对列表类型进行操作127.0.0.1:6379&gt; lpush mylist 4 2 6 1 3 7(integer) 6127.0.0.1:6379&gt; sort mylist1) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;4) &quot;4&quot;5) &quot;6&quot;6) &quot;7&quot;//对有序集合类型排序会忽略元素的分数，只针对元素自身的值进行排序127.0.0.1:6379&gt; zadd myset 50 2 40 3 20 1 60 5(integer) 4127.0.0.1:6379&gt; sort myset1) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;4) &quot;5&quot;</code></pre><p>除了可以排列数字，SORT命令还可以通过ALPHA参数实现按照字典顺序排列非数字元素，如：  </p><pre><code>127.0.0.1:6379&gt; lpush mylist a c e d B C A(integer) 7127.0.0.1:6379&gt; 127.0.0.1:6379&gt; sort mylist(error) ERR One or more scores can&apos;t be converted into double127.0.0.1:6379&gt; sort mylist alpha1) &quot;a&quot;2) &quot;A&quot;3) &quot;B&quot;4) &quot;c&quot;5) &quot;C&quot;6) &quot;d&quot;7) &quot;e&quot;</code></pre><p>SORT命令还支持LIMIT参数来返回指定范围的结果。用法和SQL语句一样，LIMIT offset count，表示跳过前offset个元素并获取之后的count个元素。SORT命令参数可以组合使用，如：  </p><pre><code>127.0.0.1:6379&gt; sort tag:java:posts DESC1) &quot;12&quot;2) &quot;10&quot;3) &quot;6&quot;4) &quot;2&quot;5) &quot;1&quot;127.0.0.1:6379&gt; sort tag:java:posts DESC limit 1 21) &quot;10&quot;2) &quot;6&quot;127.0.0.1:6379&gt; sort tag:java:posts DESC limit 1 31) &quot;10&quot;2) &quot;6&quot;3) &quot;2&quot;</code></pre><h3 id="3、BY参数"><a href="#3、BY参数" class="headerlink" title="3、BY参数"></a>3、BY参数</h3><p>很多情况下列表（或集合、有序集合）中存储的元素值代表的是对象ID（如标签集合中存储的是文章对象的ID），单纯对这些ID自身排序有时意义并不大。更多的时候我们希望根据ID对应的对象的某个属性进行排序。我们可以通过有序集合键来存储文章ID列表，以修改时间作为有序集合的分数，所有文章的ID顺序和文章的发布时间（或更新时间）并不是完全一致。因此对ID本身排序就没什么意义了。使用散列表存储文章对象，其中time字段的值就是文章的发布时间。假设现在我们知道ID为“2”、”6“、”12“和”26“的四篇文章的time值分别为”1352619200“，”1352619600“，”1352620100“和”1352620000“（Unix时间）。如果要按照文章的发布时间递减排列结果应为”12“，”26“，”6“，”2“。位了获得这一的结果，需要使用SORT命令的另一个强大的参数BY。<br>BY参数的语法为“BY 参考键”。其中参考键可以是字符串类型键或者是散列类型键的某个字段（表示为键名-&gt;字段名）。如果提供了BY参数，SORT命令将不再依据元素自身的值排序，而是对每个元素使用元素的值替换参考键中的第一个“*”并获取其值，然后依据该值对元素排序。如：  </p><pre><code>//添加测试数据127.0.0.1:6379&gt; hmset post:2 time 1352619200 name java编程思想 price 86.6OK127.0.0.1:6379&gt; hmset post:26 time 1352620000 name java核心技术 price 98.2OK127.0.0.1:6379&gt; hmset post:12 time 1352620000 name Java并发编程的艺术 price 43.5OK127.0.0.1:6379&gt; hmset post:6 time 1352619600  name java2 price 2.5OK127.0.0.1:6379&gt; hmset post:5 time 1352622221 name java3 price 15OK127.0.0.1:6379&gt; ZRANGE tag:java:posts 0 -11) &quot;2&quot;2) &quot;6&quot;3) &quot;12&quot;4) &quot;26&quot;5) &quot;5&quot;//使用BY参数按post对象的time属性倒序，且26和12的time值相同时，我们发现26在前12在后127.0.0.1:6379&gt; sort tag:java:posts BY post:\*-&gt;time DESC 1) &quot;5&quot;2) &quot;26&quot;3) &quot;12&quot;4) &quot;6&quot;5) &quot;2&quot;</code></pre><p><strong>上例中SORT命令会去读取post:2、post:6、post:12、post:26、post:5几个散列键中的time字段的值并以此决定tag:java:posts键中各个文章ID的顺序。 </strong> </p><p>除了散列类型之外，参考键还可以是字符串类型，如：  </p><pre><code>127.0.0.1:6379&gt; lpush sortList 2 1 3(integer) 3127.0.0.1:6379&gt; set score:1 50OK127.0.0.1:6379&gt; set score:2 100OK127.0.0.1:6379&gt; set score:3 -10OK127.0.0.1:6379&gt; sort sortList by score:\* DESC1) &quot;2&quot;2) &quot;1&quot;3) &quot;3&quot;</code></pre><p>当参考键名不包含“*”时（即常量键名，与元素值无关），SORT命令将不会执行排序操作，因为Redis认为这种情况时没有意义的（因为所有要比较的值都一样）。例如：  </p><pre><code>127.0.0.1:6379&gt; sort sortList by abc1) &quot;3&quot;2) &quot;1&quot;3) &quot;2&quot;</code></pre><p>例中abc是常量名（甚至abc键可以不存在），此时SORT的结果与LRANGE的结果相同，没有执行排序操作。在不需要排序但需要借助SORT命令获得与元素相关联的数据时，常量键是很有用的。如果几个元素的参考键值相同，则SORT命令会再去比较元素本身的值来决定元素的顺序。如：  </p><pre><code>127.0.0.1:6379&gt; lpush sortList 4(integer) 4127.0.0.1:6379&gt; set score:4 50OK127.0.0.1:6379&gt; sort sortList BY score:\* DESC1) &quot;2&quot;2) &quot;4&quot; //4的参考值和1一样也是50，但比较元素本身4比1大，所以4在前3) &quot;1&quot;4) &quot;3&quot;</code></pre><p>当某个元素的参考键不存在时，会默认参考键的值为0：  </p><pre><code>127.0.0.1:6379&gt; LPUSH sortList 5(integer) 5127.0.0.1:6379&gt; sort sortList BY score:\* DESC1) &quot;2&quot;2) &quot;4&quot;3) &quot;1&quot;4) &quot;5&quot;//默认参考键的值为0，比3的参考键的值（-10）要大，所以排列在3前5) &quot;3&quot;</code></pre><p>补充：参考键虽然支持散列类型，但是“*”只能在“-&gt;”符号前面（即键名部分）才有用，在“-&gt;”后（即字段名部分）会被当成字段名本身而不会作为占位符被元素值替换，即常量键名。但是实际运行时会发现一个有趣的结果：  </p><pre><code>127.0.0.1:6379&gt; sort sortList BY somekey-&gt;somefield:\*1) &quot;1&quot;2) &quot;2&quot;3) &quot;3&quot;4) &quot;4&quot;5) &quot;5&quot;</code></pre><p>上面提到了当参数键名是常量键名时SORT命令将不会执行排序操作，然而上面例子中确实进行了排序，而且只是对元素本身进行排序。这是因为Redis判断参考键名是不是常量键名的方式是判断参考键名中是否包含“*”，而somekey-&gt;somefield:*中包含“*”所以不是常量键名。所以在排序的时候Redis对每个元素都会读取键somekey中的somefield:*字段（”*“不会被替换），无论能否获得其值，每个元素的参考键值是相同的，所以Redis会按照元素本身的大小排列。  </p><h3 id="4、GET参数"><a href="#4、GET参数" class="headerlink" title="4、GET参数"></a>4、GET参数</h3><p>GET参数不影响排序，它的作用是使SORT命令的返回结果不再是元素自身的值，而是GET参数中指定的键值。GET参数的规则和BY参数一样，GET参数也支持字符串类型和散列类型的键，并使用“*”作为占位符。要实现在排序后直接返回ID对应的文章标题，代码如下：  </p><pre><code>//按post的time属性倒序，返回post的name属性值127.0.0.1:6379&gt; sort tag:java:posts BY post:\*-&gt;time DESC GET post:\*-&gt;name1) &quot;java3&quot;2) &quot;java\xe6\xa0\xb8\xe5\xbf\x83\xe6\x8a\x80\xe6\x9c\xaf&quot;3) &quot;Java\xe5\xb9\xb6\xe5\x8f\x91\xe7\xbc\x96\xe7\xa8\x8b\xe7\x9a\x84\xe8\x89\xba\xe6\x9c\xaf&quot;4) &quot;java2&quot;5) &quot;java\xe7\xbc\x96\xe7\xa8\x8b\xe6\x80\x9d\xe6\x83\xb3&quot;</code></pre><p>在一个SORT命令中可以有多个GET参数（而BY参数只有一个），所以还可以如下使用：  </p><pre><code>127.0.0.1:6379&gt; sort tag:java:posts BY post:\*-&gt;time DESC GET post:\*-&gt;name GET post:\*-&gt;time 1) &quot;java3&quot; 2) &quot;1352622221&quot; 3) &quot;java\xe6\xa0\xb8\xe5\xbf\x83\xe6\x8a\x80\xe6\x9c\xaf&quot; 4) &quot;1352620000&quot; 5) &quot;Java\xe5\xb9\xb6\xe5\x8f\x91\xe7\xbc\x96\xe7\xa8\x8b\xe7\x9a\x84\xe8\x89\xba\xe6\x9c\xaf&quot; 6) &quot;1352620000&quot; 7) &quot;java2&quot; 8) &quot;1352619600&quot; 9) &quot;java\xe7\xbc\x96\xe7\xa8\x8b\xe6\x80\x9d\xe6\x83\xb3&quot;10) &quot;1352619200&quot;</code></pre><p>可见有N个GET参数，每个元素返回的结果就有N行。如果还需要返回文章的ID，可以使用GET #,也就是说GET# 会返回元素本身 </p><pre><code>127.0.0.1:6379&gt; sort tag:java:posts BY post:\*-&gt;time DESC GET post:\*-&gt;name GET post:\*-&gt;time GET # 1) &quot;java3&quot; 2) &quot;1352622221&quot; 3) &quot;5&quot; 4) &quot;java\xe6\xa0\xb8\xe5\xbf\x83\xe6\x8a\x80\xe6\x9c\xaf&quot; 5) &quot;1352620000&quot; 6) &quot;26&quot; 7) &quot;Java\xe5\xb9\xb6\xe5\x8f\x91\xe7\xbc\x96\xe7\xa8\x8b\xe7\x9a\x84\xe8\x89\xba\xe6\x9c\xaf&quot; 8) &quot;1352620000&quot; 9) &quot;12&quot;10) &quot;java2&quot;11) &quot;1352619600&quot;12) &quot;6&quot;13) &quot;java\xe7\xbc\x96\xe7\xa8\x8b\xe6\x80\x9d\xe6\x83\xb3&quot;14) &quot;1352619200&quot;15) &quot;2&quot;</code></pre><h3 id="5、STORE参数"><a href="#5、STORE参数" class="headerlink" title="5、STORE参数"></a>5、STORE参数</h3><p>默认情况下SORT会直接返回排序结果，如果希望保存排序结果，可以使用STORE参数。如果希望把记过保存到sort.result键中：  </p><pre><code>127.0.0.1:6379&gt; sort tag:java:posts BY post:\*-&gt;time DESC GET post:\*-&gt;name GET post:\*-&gt;time GET # STORE sort.result(integer) 15127.0.0.1:6379&gt; lrange sort.result 0 -1 1) &quot;java3&quot; 2) &quot;1352622221&quot; 3) &quot;5&quot; 4) &quot;java\xe6\xa0\xb8\xe5\xbf\x83\xe6\x8a\x80\xe6\x9c\xaf&quot; 5) &quot;1352620000&quot; 6) &quot;26&quot; 7) &quot;Java\xe5\xb9\xb6\xe5\x8f\x91\xe7\xbc\x96\xe7\xa8\x8b\xe7\x9a\x84\xe8\x89\xba\xe6\x9c\xaf&quot; 8) &quot;1352620000&quot; 9) &quot;12&quot;10) &quot;java2&quot;11) &quot;1352619600&quot;12) &quot;6&quot;13) &quot;java\xe7\xbc\x96\xe7\xa8\x8b\xe6\x80\x9d\xe6\x83\xb3&quot;14) &quot;1352619200&quot;15) &quot;2&quot;</code></pre><p>保存后的键的类型为列表类型，如果键已经存在则会覆盖它。加上STORE参数后SORT命令的返回值为结果的个数。STORE参数常用来结合EXPIRE命令缓存排序结果，如下面的伪代码：  </p><pre><code>//判断是否存在之前排序结果的缓存$isCacheExists=Exists cache.sortif $isCacheExists is 1    //如果存在直接返回    return LRANGE cache.sort,0 -1else     //如果不存在，则使用SORT命令排序并将结果存入cache.sort键中作为缓存    $sortResult=SORT some.list STORE cache.sort    //设置生成时间为10分钟    EXPIRE cache.sort,600    //返回排序结果    return $sortResult</code></pre><h3 id="6、性能优化"><a href="#6、性能优化" class="headerlink" title="6、性能优化"></a>6、性能优化</h3><p>SORT是Redis中最强大最复杂的命令之一，如果使用不好很容易成为性能瓶颈。SORT命令的时间复杂度是O（n+mlogm），其中n表示要排序的列表（集合或有序集合）中的元素个数，m表示要返回的元素个数。当n较大的时候SORT命令的性能相对较低，并且Redis在排序前会建立一个长度为n的容器来存储待排序的元素，虽然是一个临时的过程，但如果同时进行较多的大数据量排序操作则会严重影响性能。<br>所以开发中使用SORT命令时需要注意以下几点：<br>（1）尽可能减少待排序键中元素数量（使n尽可能小）。<br>（2）使用LIMIT参数只获取需要的数据（使m尽可能小）。<br>（3）如果要排序的数据量较大，尽可能使用STORE参数将结果缓存。</p>]]></content>
    
    <summary type="html">
    
      Redis中Sort排序命令详解，关于BY、GET、 STORE参数详解；排序应注意的性能问题等。
    
    </summary>
    
      <category term="redis系列" scheme="http://xym-loveit.github.io/categories/redis%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="redis命令" scheme="http://xym-loveit.github.io/tags/redis%E5%91%BD%E4%BB%A4/"/>
    
      <category term="SORT排序" scheme="http://xym-loveit.github.io/tags/SORT%E6%8E%92%E5%BA%8F/"/>
    
      <category term="Redis排序" scheme="http://xym-loveit.github.io/tags/Redis%E6%8E%92%E5%BA%8F/"/>
    
      <category term="SORT参数讲解" scheme="http://xym-loveit.github.io/tags/SORT%E5%8F%82%E6%95%B0%E8%AE%B2%E8%A7%A3/"/>
    
      <category term="排序性能" scheme="http://xym-loveit.github.io/tags/%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD/"/>
    
      <category term="排序缓存" scheme="http://xym-loveit.github.io/tags/%E6%8E%92%E5%BA%8F%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>redis入门指南之提高篇I</title>
    <link href="http://xym-loveit.github.io/2017/05/24/redis%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97%E4%B9%8B%E6%8F%90%E9%AB%98%E7%AF%87I/"/>
    <id>http://xym-loveit.github.io/2017/05/24/redis入门指南之提高篇I/</id>
    <published>2017-05-24T11:59:52.000Z</published>
    <updated>2018-03-29T01:27:48.643Z</updated>
    
    <content type="html"><![CDATA[<h6 id="重要星级-★★★★★"><a href="#重要星级-★★★★★" class="headerlink" title="重要星级 ★★★★★"></a>重要星级 ★★★★★</h6><hr><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>Redis中的事务（transaction）是一组命令集合。事务同命令一样都是redis的最小执行单位，一个事务中的命令要么都执行，要么都不执行。事务的应用非常普遍，如银行转账过程中A给B汇款，首先系统从A的账户将钱划走，然后向B的账户增加相应的金额。这二个步骤必须属于同一个事务，要么全执行，要么全不执行。否则只执行第一步，钱就凭空消失了，这显然让人无法接受。<br>事务的原理是先将属于一个事务的命令发送给Redis，然后再让Redis依次执行这个命令。如：</p><pre><code>127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; sadd &quot;user:1:following&quot; 2QUEUED127.0.0.1:6379&gt; sadd &quot;user:2:followers&quot; 1QUEUED127.0.0.1:6379&gt; exec1) (integer) 12) (integer) 1</code></pre><p>以上代码演示了事务的使用方式。首先使用multi命令告诉Redis：“下面我发给你的命令属于同一个事务，你先不要执行，而是把他们暂时存起来。”Redis回答：“OK。” 而后我们发送了2个sadd命令来实现关注和被关注的操作，可以看到Redis遵守了承若，没有执行这些命令，而是返回QUEUED表示这两条命令已经进入等待执行的事务队列中了。<br>当把所有同一个事务中的执行的命令都发给Redis后，我们使用EXEC命令告诉Redis将等待执行的事务队列中所有命令（即刚才所有返回QUEUED的命令）按照发送顺序依次执行。EXEC命令的返回值就是这些命令的返回值组成的列表，返回值顺序和命令的顺序相同。<br>Redis保证一个事务中的所有命令要么都执行，要么都不执行。如果在发送EXEC命令前客户端断线了，则Redis会清空事务队列，事务中的所有命令都不会执行。而一旦客户端发送了EXEC命令，所有的命令就都会被执行，即使此后客户端断线也没关系，因为Redis中已经记录了所有要执行的命令。<br>除此之外，Redis的事务还能保证一个事务内的命令依次执行而不被其他命令插入。试想客户端A需要执行几条命令，同时客户端B发送了一条命令，如果不适用事务，则客户端B的命令可能会插入到客户端A的几条命令中执行。如果不希望发生这种情况，也可以使用事务。</p><h3 id="2、错误处理"><a href="#2、错误处理" class="headerlink" title="2、错误处理"></a>2、错误处理</h3><p>如果事务中某个命令执行出错，Redis会怎么处理呢？  </p><h4 id="（1）语法错误。语法错误指命令不存在或者命令参数的个数不对。如："><a href="#（1）语法错误。语法错误指命令不存在或者命令参数的个数不对。如：" class="headerlink" title="（1）语法错误。语法错误指命令不存在或者命令参数的个数不对。如："></a>（1）语法错误。语法错误指命令不存在或者命令参数的个数不对。如：</h4><pre><code>127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set key valueQUEUED127.0.0.1:6379&gt; set key(error) ERR wrong number of arguments for &apos;set&apos; command127.0.0.1:6379&gt; errorcommand key(error) ERR unknown command &apos;errorcommand&apos;127.0.0.1:6379&gt; exec(error) EXECABORT Transaction discarded because of previous errors.</code></pre><p>跟在MULTI命令后执行了3个命令：一个是正确命令，成功地加入了事务队列；其余二个命令都有语法错误。而只要有一个命令有语法错误，执行EXEC命令后Redis就会直接返回错误，连语法正确的命令也不会执行。  </p><h4 id="（2）运行错误。运行错误指在命令执行时出现的错误，比如使用散列类型的命令操作集合类型的键，这种错误在实际执行之前Redis是无法发现的，所以在事务里这样的命令是会被Redis接受并执行的。如果事务里的一条命令出现了运行错误，事务里其他的命令依然会继续执行（包括出错命令之后的命令）。如："><a href="#（2）运行错误。运行错误指在命令执行时出现的错误，比如使用散列类型的命令操作集合类型的键，这种错误在实际执行之前Redis是无法发现的，所以在事务里这样的命令是会被Redis接受并执行的。如果事务里的一条命令出现了运行错误，事务里其他的命令依然会继续执行（包括出错命令之后的命令）。如：" class="headerlink" title="（2）运行错误。运行错误指在命令执行时出现的错误，比如使用散列类型的命令操作集合类型的键，这种错误在实际执行之前Redis是无法发现的，所以在事务里这样的命令是会被Redis接受并执行的。如果事务里的一条命令出现了运行错误，事务里其他的命令依然会继续执行（包括出错命令之后的命令）。如："></a>（2）运行错误。运行错误指在命令执行时出现的错误，比如使用散列类型的命令操作集合类型的键，这种错误在实际执行之前Redis是无法发现的，所以在事务里这样的命令是会被Redis接受并执行的。如果事务里的一条命令出现了运行错误，事务里其他的命令依然会继续执行（包括出错命令之后的命令）。如：</h4><pre><code>127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set key 1QUEUED127.0.0.1:6379&gt; sadd key 2QUEUED127.0.0.1:6379&gt; set key 3QUEUED127.0.0.1:6379&gt; exec1) OK2) (error) WRONGTYPE Operation against a key holding the wrong kind of value3) OK127.0.0.1:6379&gt; get key&quot;3&quot;</code></pre><p>可见虽然sadd key 2出现了错误，但是set key 3 依然执行了。<br>Redis的事务没有关系型数据库事务提供的回滚（rollback）功能。为此开发者必须在事务执行出错后自己收拾烂摊子（将事务恢复到执行前的状态等）<br>不过由于Redis不支持回滚功能，也是的Redis在事务上可以保持简洁和快速。  </p><h3 id="3、WATCH命令"><a href="#3、WATCH命令" class="headerlink" title="3、WATCH命令"></a>3、WATCH命令</h3><p>我们知道在一个事务中只有当所有命令都依次执行完后才能得到每个结果的返回值，可是有些情况下需要先获得一条命令的返回值，然后再根据这个值执行下一条命令。例如，介绍INCR命令时曾经说过使用GET 和SET命令自己实现incr函数会出现竞态条件，伪代码如下：  </p><pre><code>def incr($key)    $value=GET $key    if not $value            $value=0    $value=$value+1    SET $key,$value    return $value</code></pre><p>因为事务中的每一个命令的执行结果都是最后一期返回的，所以无法将前一条命令的结果作为下一条命令的参数，即在执行SET命令时无法获得GET命令的返回值，也就无法做到增1的功能。所以无法使用事务来实现incr函数。<br>为了解决这个问题，我们需要换种思路。即在GET获得键值后保证该键值不被其他客户端修改，直到函数执行完成后才允许其他客户端修改该键值，这样也可以防止竞态条件。要实现这一思路需要请出事务家族中的另一位成员：WATCH。WATCH命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行。监控一直持续到EXEC命令（事务中的命令是在EXEC之后才执行的，所以在MULTI命令后可以修改WATCH监控的键值）。如：</p><pre><code>127.0.0.1:6379&gt; set key 1OK127.0.0.1:6379&gt; watch keyOK127.0.0.1:6379&gt; set key 2OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set key 3QUEUED127.0.0.1:6379&gt; exec(nil)127.0.0.1:6379&gt; get key&quot;2&quot;</code></pre><p>上面例子在执行WATCH命令后、事务执行前修改了key的值（即set key 2），所以最后的事务中的命令SET key 3没有执行，EXEC命令返回空结果。学会了WATCH命令就可以通过事务自己实现incr函数了，伪代码如下：  </p><pre><code>def incr($key)    WATCH $key    $value=GET $key    if not $value            $value=0    $value=$value+1    MULTI    SET $key,$value    result=EXEC    return result[0]</code></pre><p><strong>提示：由于WATCH命令的作用只是当被监控的键值被修改后阻止之后一个事务的执行，而不能保证其他客户端不修改这一键值，所以我们需要在EXEC执行失败后重新执行整个函数。</strong><br>执行EXEC命令后会取消对所有键的监控，如果不想执行事务中的命令也可以使用UNWATCH命令来取消监控。比如我们要实现hsetxx函数，作用于HSETNX命令类似，只不过是仅当字段存在时才赋值。为了避免竞态条件我们使用事务来完成这一功能：</p><pre><code>def hsetxx($key,$field,$value)    WATCH $key    $isFieldExists =HEXISTS $key,$field    if $isFieldExists is 1        MULTI        HSET $key,$field,$value        EXEC    else        UNWATCH    return $isFieldExists</code></pre><p>在代码中会判断要赋值的字段是否存在，如果字段不存在的话就不执行事务中的命令，但需要使用UNWATCH命令来保证下一个事务的执行不会受到影响。</p><h2 id="生存时间"><a href="#生存时间" class="headerlink" title="生存时间"></a>生存时间</h2><h3 id="1、命令"><a href="#1、命令" class="headerlink" title="1、命令"></a>1、命令</h3><p>EXPIRE命令的使用方法为EXPIRE key seconds，其中seconds参数表示键的生存时间，单位是秒。如想要让session:2345 键在15分钟后删除：  </p><pre><code>127.0.0.1:6379&gt; set session:2345 1234OK127.0.0.1:6379&gt; expire session:2345 900(integer) 1</code></pre><p>EXPIRE命令返回1表示设置成功，返回0表示键不存在或设置失败。例如：  </p><pre><code>127.0.0.1:6379&gt; del session:2345(integer) 1127.0.0.1:6379&gt; expire session:2345 900(integer) 0</code></pre><p>如果想知道一个键还有多久时间删除，可以使用TTL命令。返回值为键的剩余时间（单位是秒）。</p><pre><code>127.0.0.1:6379&gt; set foo barOK127.0.0.1:6379&gt; expire foo 20(integer) 1127.0.0.1:6379&gt; ttl foo(integer) 8127.0.0.1:6379&gt; ttl foo(integer) 4127.0.0.1:6379&gt; ttl foo(integer) 1127.0.0.1:6379&gt; ttl foo(integer) -2127.0.0.1:6379&gt; get foo(nil)</code></pre><p>可见随着时间的不同，foo键的生存时间逐渐减少，20秒后foo键会被删除。当然不存在时TTL命令会返回-1，另外同样会返回-1的是没有为键设置生存时间（即永久存在的，这是建立一个键之后的默认情况）。</p><pre><code>127.0.0.1:6379&gt; set k1 v1OK127.0.0.1:6379&gt; ttl k1(integer) -1127.0.0.1:6379&gt; ttl k3(integer) -1</code></pre><p>如果想取消键的生存时间设置（即将键恢复成永久的），可以使用PERSIST命令。如果生存时间被成功清除则返回1；否则返回0（因为键不存在或键本来就是永久的）：  </p><pre><code>127.0.0.1:6379&gt; set foo barOK127.0.0.1:6379&gt; persist foo --键本来就是永久的则返回0(integer) 0127.0.0.1:6379&gt; expire foo 20(integer) 1127.0.0.1:6379&gt; ttl foo(integer) 15127.0.0.1:6379&gt; persist foo --键有生存时间则设置为永久，成功返回1(integer) 1127.0.0.1:6379&gt; ttl foo</code></pre><p>除了PERSIST命令之外，使用SET或GETSET命令为键赋值也会同时清除键的生存时间，例如：  </p><pre><code>127.0.0.1:6379&gt; expire foo 20(integer) 1127.0.0.1:6379&gt; ttl foo(integer) 11127.0.0.1:6379&gt; set foo barOK127.0.0.1:6379&gt; ttl foo(integer) -1</code></pre><p>使用EXPIRE命令会重新设置键的生存时间，如：  </p><pre><code>127.0.0.1:6379&gt; set foo barOK127.0.0.1:6379&gt; expire foo 20(integer) 1127.0.0.1:6379&gt; ttl foo(integer) 18127.0.0.1:6379&gt; expire foo 30(integer) 1127.0.0.1:6379&gt; ttl foo(integer) 27</code></pre><p>其他只对键值进行操作的命令（如：INCR/LPUSH/HSET/ZREM）均不会影响键的生存时间。<br>EXPIRE命令的seconds参数必须是整数，所以最小单位是1秒。如果想要更精确的控制键的生存时间应该使用PEXPIRE命令，PEXPIRE命令与EXPIRE的唯一区别是前者的时间单位是毫秒，即PEXPIRE key 1000与EXPIRE key 1等价。对应地可以用PTTL 命令以毫秒为单位返回键的剩余时间。<br><strong>提示：如果使用WATCH命令监测一个拥有生存时间的键，该键时间到期自动删除并不会被WATCH命令认为该键被改变，也就不会影响事务的执行。</strong><br>另外还有2个相对不太常用的命令：EXPIREAT和PEXPIREAT。<br>EXPIREAT命令与EXPIRE命令的差别在于前者使用unix时间作为第二个参数表示键的生存时间的截止时间。PEXPIREAT命令与EXPIREAT命令的区别是前者的时间单位是毫秒。如：  </p><pre><code>127.0.0.1:6379&gt; set foo valOK127.0.0.1:6379&gt; get foo&quot;val&quot;127.0.0.1:6379&gt; EXPIREAT foo 1498473048362 --时间戳，截止到年月日时分秒(integer) 1127.0.0.1:6379&gt; ttl foo(integer) 1496977350307127.0.0.1:6379&gt; ttl foo(integer) 1496977350301127.0.0.1:6379&gt; PEXPIREAT foo 1498473048362000 --时间戳，截止到年月日时分秒，毫秒为单位(integer) 1127.0.0.1:6379&gt; pttl foo(integer) 1496977350234675</code></pre><h3 id="2、访问频率限制策略"><a href="#2、访问频率限制策略" class="headerlink" title="2、访问频率限制策略"></a>2、访问频率限制策略</h3><ul><li>实现访问频率限制1<br>如需要限制每个用户（以IP计）一段时间的最大访问量。如：<br>每分钟用户最多能访问某系统100个界面，思路是对每个用户使用一个名为“rate.limiting:用户ID”的字符串类型键，每次用户访问则使用INCR 命令递增该键的键值，如果递增后的值是1（第一次访问页面），则同时还要设置该键的生存时间为1分钟。这样每次用户访问页面时都读取该键的键值，如果超过100就表明该用户的访问频次超过了限制，需要提示用户稍后访问。该键每分钟自动被删除，所以下一分钟用户的访问次数又会重新计算，也就达到了限制访问频率的目的。伪代码如下：  </li></ul><pre><code>$isKeyExists=EXISTE rate.limiting:$IPif $isKeyExists is 1    $times=INCR rate.limiting:$IP    if $times&gt;100        print 访问频率超过了限制，请稍后再试        exitelse    //第一次访问设置生存时间    INCR rate.limiting:$IP    EXPIRE $keyName,60</code></pre><p>上述代码存在一个不太明显的问题：假如程序执行完倒数第二行后突然因为某种原因退出了，没能够为该键设置生存时间，那么该键会永久存在，导致使用对应IP的用户在管理员手动删除该键前最多只能访问100次，这是一个很严重的问题。<br>为了保证建立键和为键设置生存时间一起执行，可以使用上面学习的事务功能，修改后代码如下：  </p><pre><code>$isKeyExists=EXISTE rate.limiting:$IPif $isKeyExists is 1    $times=INCR rate.limiting:$IP    if $times&gt;100        print 访问频率超过了限制，请稍后再试        exitelse    //第一次访问设置生存时间,并通过事务保证原子性    MULTI    INCR rate.limiting:$IP    EXPIRE $keyName,60    EXEC</code></pre><ul><li>实现访问频率限制2<br>事实上，上述代码仍然有个问题：如果一个用户在一分钟的第一秒访问了一次，在同一分钟的最后一秒访问了99次，又在下一分钟的第一秒访问了100次，这样的访问是可以通过现在的访问频率限制的，但实际上该用户在2秒钟内访问了199次，这与每个用户每分钟只能访问100次的限制差距较大。尽管这种情况比较极端，但在一些场合中还是需要粒度更小的控制方案。如果要精确控制每分钟最多访问100次，需要记录下用户每次访问的时间。因此对每个用户，我们使用一个列表类型的键来记录他最近100次访问时间。一旦键中的元素超过100个，就判断时间最早的元素距现在的时间是否小于1分钟。如果是则表示最近一分钟的访问次数超过了100频次限制；如果不是就将限制的时间加入到列表中，同时把最早的元素删除掉。伪代码如下：  </li></ul><pre><code>$listLength=LLEN rate.limiting:$IPif $listLength &lt;100    //访问次数不超过限制就加入    LPUSH rate.limiting:$IP,now()else    //超过限制就根据时差分情况    $time=LINDEX rate.limiting:$IP,-1    //如果最早的一次访问距离现在不超过1分钟，说明访问密集已经超出频次限制     if now()-$time&lt;60        print 访问频率超过限制，请稍后再试    else    //说明最早的访问到距离现在已超过一分钟，没有超出限制    LPUSH rate.limiting:$IP,now()    //踢掉最右端的元素（即最早访问时间）    LTRIM rate.limiting:$IP,0,99</code></pre><p>由于需要记录每次访问的时间，所以当要限制“A时间最多访问B次”时，如果“B”的数值较大，比方法会占用较多的存储空间，实际使用时还需要开发者自己权衡。除此之外该方法也会出现竞态条件。  </p><h3 id="3、实现缓存（缓存占用内存解决方案）"><a href="#3、实现缓存（缓存占用内存解决方案）" class="headerlink" title="3、实现缓存（缓存占用内存解决方案）"></a>3、实现缓存（缓存占用内存解决方案）</h3><p>为了提高网站的负载能力，常常需要将一些访问频率较高但是对CPU或IO资源消耗较大的操作结果缓存起来，并希望让这些缓存过段时间自动过期。比如教务网站要对全校所有学生的各个科目成绩汇总排名，并在首页上显示前10名学生姓名，由于计算过程较耗资源，所以可以将结果使用Redis的字符串缓存起来。由于学生成绩总在不断变化，需要每隔二小时就重新计算一次排名，这可以通过给键设置生存时间的方式实现。每次用户访问首页时程序先去查询缓存是否存在，如果存在则直接使用缓存的值；否则重新计算排名并将结果赋值给该键并同时设置该键的生存时间为2小时。伪代码如下：  </p><pre><code>$rank=GET cache:rankif not $rank    $rank=计算排名...    MULTI    SET cache:rank,$rank    EXPIRE cache:rank,7200    EXEC</code></pre><p>然后在一些场合中这种方法并不能满足需求。当服务器内存有限时，如果大量使用缓存键且生存时间设置的过长就会导致Redis占满内存；另一方面如果为了防止Redis占用内存过大而将缓存键的生存时间设得太短，就可能导致缓存命中率过低并且大量内存白白闲置。实际开发中会发现很难为缓存键设置合理的生存时间，为此可以限制Redis能够使用的最大内存，并让Redis按照一定的规则淘汰不需要的缓存键，这种方式只将Redis用作缓存系统时非常有用。<br>具体的设置方法为：修改配置文件中的maxmemory参数，限制Redis最大可用内存大小（单位是字节），当超出这个限制时Redis会根据maxmemory-policy参数指定的策略来删除不需要的键，直到Redis内存小于指定内存。<br>maxmemory-policy支持规则如下，其中LRU（Least Recently Used）算法即“最近最少使用”，其认为最近最少使用的键在未来一段时间内也不会被用到，即当需要时这些键是可以被删除的。  </p><table><thead><tr><th>规则</th><th>说明</th></tr></thead><tbody><tr><td>volatile-lru</td><td>使用LRU算法删除一个键（只针对设置了生存时间的键）</td></tr><tr><td>allkeys-lru</td><td>使用LRU算法删除一个键</td></tr><tr><td>volatile-random</td><td>随机删除一个键（只针对设置了生存时间的键）</td></tr><tr><td>allkeys-random</td><td>随机删除一个键</td></tr><tr><td>volatile-ttl</td><td>删除生存时间最近的一个键</td></tr><tr><td>noevication</td><td>不删除键，值返回错误</td></tr></tbody></table><p>如当maxmemory-policy设置为allkeys-lru时，一旦Redis占用的内存超过了限制，Redis会不断删除数据中最近最少使用的键，直到占用的内存小于限制值。</p><p><strong>LRU(Least Recently Used)最近最少使用：事实上Redis并不会准确地将整个数据库中最久未被使用的键删除，而是每次从数据库中随机取3个键并删除这3个键中最久未被使用的键。删除生存时间最接近的键的实现方法也是这样。“3”这个数字可以通过Redis的配置文件中的maxmemory-samples参数设置。</strong></p>]]></content>
    
    <summary type="html">
    
      通过使用redis事务、生存时间、缓存等redis的高级特性，更好在生产环节适宜的场景中使用它处理问题。
    
    </summary>
    
      <category term="redis系列" scheme="http://xym-loveit.github.io/categories/redis%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="redis命令" scheme="http://xym-loveit.github.io/tags/redis%E5%91%BD%E4%BB%A4/"/>
    
      <category term="redis事务" scheme="http://xym-loveit.github.io/tags/redis%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="生存时间" scheme="http://xym-loveit.github.io/tags/%E7%94%9F%E5%AD%98%E6%97%B6%E9%97%B4/"/>
    
      <category term="缓存" scheme="http://xym-loveit.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="访问频率限制" scheme="http://xym-loveit.github.io/tags/%E8%AE%BF%E9%97%AE%E9%A2%91%E7%8E%87%E9%99%90%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>redis入门指南-命令阶段III</title>
    <link href="http://xym-loveit.github.io/2017/05/24/redis%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E5%91%BD%E4%BB%A4%E9%98%B6%E6%AE%B5III/"/>
    <id>http://xym-loveit.github.io/2017/05/24/redis入门指南-命令阶段III/</id>
    <published>2017-05-24T01:23:42.000Z</published>
    <updated>2018-03-29T01:27:48.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="有序集合类型"><a href="#有序集合类型" class="headerlink" title="有序集合类型"></a>有序集合类型</h2><p>在集合类型的基础上有序集合类型为集合中的每个元素都关联了一个分数，这使得我们不仅可以完成插入、删除和判断元素是否存在等集合类型支持的操作，还能够获得分数最高（或最低）的前N个元素、获得指定分数范围内的元素等与分数有关的操作。虽然集合中每个元素都是不同的，但是他们的分数却可以相同。 </p><p>有序集合类型和列表类型的区别：<br>（1）二者都是有序的。<br>（2）二者都可以获得某一范围的元素。  </p><p>（3）列表类型是通过链表实现的，获取靠近两端的数据速度极快，而当元素增多后，访问中间数据的速度会较慢，所以它更加适合实现如“新鲜事”或“日志”这样的很少访问中间元素的应用。<br>（4）有序集合类型是使用散列表和跳跃表（skip list）实现的，所以即使读取位于中间部分的数据速度也很快（时间复杂度O（logN））。<br>（5）列表中不能简单地调整某个元素的位置，但是有序集合可以（通过更改这个元素的分数）。<br>（6）有序集合要比列表类型更耗费内存。</p><h3 id="1、命令"><a href="#1、命令" class="headerlink" title="1、命令"></a>1、命令</h3><ul><li>增加元素  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD key score member [score member ...]</span><br></pre></td></tr></table></figure><p>ZADD命令用来向有序集合中加入一个元素和该元素的分数，如果该元素已经存在则会用新的分数替换原有的分数。ZADD命令的返回值是新加入到集合的元素的个数（不包含之前已经存在的元素）。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd scores 89 tom 67 peter 100 david</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; zadd scores 76 peter --如果元素已存在，用新分数替换原有分数</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zadd test 17E+307 a --分数支持双精度</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd test 1.5 a </span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; zadd test 1.5 b</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd test +inf c --分数赋值为正无穷大</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd test -inf d --分数设置为负无穷大</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><strong>+inf表示正无穷大<br>-inf表示负无穷大</strong></p><ul><li>获得元素的分数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE key member</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE scores 0 -1 withscores</span><br><span class="line">1) &quot;peter&quot;</span><br><span class="line">2) &quot;76&quot;</span><br><span class="line">3) &quot;tom&quot;</span><br><span class="line">4) &quot;89&quot;</span><br><span class="line">5) &quot;david&quot;</span><br><span class="line">6) &quot;100&quot;</span><br><span class="line">127.0.0.1:6379&gt; zscore scores tom</span><br><span class="line">&quot;89</span><br></pre></td></tr></table></figure><ul><li>获得排名在某个范围的元素列表  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key start stop [WITHSCORES]</span><br><span class="line">ZREVRANGE key start stop [WITHSCORES]</span><br></pre></td></tr></table></figure><p>ZRANGE 命令会按照元素的分数从小到大的顺序返回索引从start到stop之间的所有元素（包括两端元素）。ZRANGE命令与LRANGE命令十分相似，如索引都是从0开始，负数代表从后向前查找（-1表示最后一个元素）。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange scores 1 2</span><br><span class="line">1) &quot;tom&quot;</span><br><span class="line">2) &quot;david&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange scores 0 -1</span><br><span class="line">1) &quot;peter&quot;</span><br><span class="line">2) &quot;tom&quot;</span><br><span class="line">3) &quot;david&quot;</span><br></pre></td></tr></table></figure><p>如果同时获得元素的分数的话可以在ZRANGE命令尾部加上WITHSCORES参数，这时返回的数据格式就从，“元素1，元素2，…，元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n”变成了“元素1，分数1，元素2，分数2,...,元素n，分数n”。如：</span><br><span class="line">127.0.0.1:6379&gt; zrange scores 0 -1 withscores</span><br><span class="line">1) &quot;peter&quot;</span><br><span class="line">2) &quot;76&quot;</span><br><span class="line">3) &quot;tom&quot;</span><br><span class="line">4) &quot;89&quot;</span><br><span class="line">5) &quot;david&quot;</span><br><span class="line">6) &quot;100&quot;</span><br></pre></td></tr></table></figure></p><p>如果两个元素分数相同，redis会按照字典顺序（即“0”&lt;“9”&lt;”A”&lt;”Z”&lt;”a”&lt;”z” 这样的顺序）来进行排列。<br>ZREVRANGE命令和ZRANGE的唯一不同在于ZREVRANGE命令是按元素的分数从大到小的顺序给出结果。</p><ul><li>获得指定分数范围的元素  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br><span class="line">ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]--注意参数</span><br></pre></td></tr></table></figure><p>ZRANGEBYSCORE命令参数虽然多，但是很好理解。该命令按照元素的分数从小到大的顺序返回分数在min和max之间（包括min和max）的元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE scores 80 100 withscores</span><br><span class="line">1) &quot;tom&quot;</span><br><span class="line">2) &quot;89&quot;</span><br><span class="line">3) &quot;david&quot;</span><br><span class="line">4) &quot;100&quot;</span><br></pre></td></tr></table></figure><p>如果希望分数范围不包含端点值，可以在分数加上“（”符号。如，希望返回80分到100分的数据，可以含80分，但不包含100分，则修改命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE scores 80 (100 withscores</span><br><span class="line">1) &quot;tom&quot;</span><br><span class="line">2) &quot;89&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE scores 80 100 withscores</span><br><span class="line">1) &quot;tom&quot;</span><br><span class="line">2) &quot;89&quot;</span><br><span class="line">3) &quot;david&quot;</span><br><span class="line">4) &quot;100&quot;</span><br></pre></td></tr></table></figure><p>min和max还支持无穷大，通ZADD命令一样，-inf和+inf分别表示负无穷大和正无穷大。比如你希望得到所有分数高于80分（不包含80分）的人的名单，但你却不知道最高分是多少，这时就可以使用+inf。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANGEbyscore scores (80 +inf withscores</span><br><span class="line">1) &quot;tom&quot;</span><br><span class="line">2) &quot;89&quot;</span><br><span class="line">3) &quot;david&quot;</span><br><span class="line">4) &quot;100&quot;</span><br></pre></td></tr></table></figure><p>LIMIT offset count与SQL 中的用法基本相同，即在获得的元素列表的基础上向后偏移offset个元素，并且只获取前count个元素。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange scores 0 -1 withscores</span><br><span class="line"> 1) &quot;admin&quot;</span><br><span class="line"> 2) &quot;69&quot;</span><br><span class="line"> 3) &quot;peter&quot;</span><br><span class="line"> 4) &quot;76&quot;</span><br><span class="line"> 5) &quot;tom&quot;</span><br><span class="line"> 6) &quot;89&quot;</span><br><span class="line"> 7) &quot;david&quot;</span><br><span class="line"> 8) &quot;100&quot;</span><br><span class="line"> 9) &quot;xym&quot;</span><br><span class="line">10) &quot;102&quot;</span><br></pre></td></tr></table></figure><p>获取分数高于60分的从第二个人开始的三个人：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE scores 60 +inf LIMIT 1 3 withscores</span><br><span class="line">1) &quot;peter&quot;</span><br><span class="line">2) &quot;76&quot;</span><br><span class="line">3) &quot;tom&quot;</span><br><span class="line">4) &quot;89&quot;</span><br><span class="line">5) &quot;david&quot;</span><br><span class="line">6) &quot;100&quot;</span><br></pre></td></tr></table></figure><p>ZREVRANGEBYSCORE 命令不仅是按照元素的分数从大往小的顺序给出结果，而且它的min和max参数的顺序和ZRANGEBYSCORE命令拾相反的。如：  </p><p>获取分数低于100分的前三个人：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrevrangebyscore scores 100 0 LIMIT 0 3 WITHscores</span><br><span class="line">1) &quot;david&quot;</span><br><span class="line">2) &quot;100&quot;</span><br><span class="line">3) &quot;tom&quot;</span><br><span class="line">4) &quot;89&quot;</span><br><span class="line">5) &quot;peter&quot;</span><br><span class="line">6) &quot;76&quot;</span><br></pre></td></tr></table></figure><ul><li>增加某个元素的分数  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY key increment member</span><br></pre></td></tr></table></figure><p>ZINCRBY 命令可以增加一个元素的分数，返回的是更改后的分数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zincrby scores 8 xym</span><br><span class="line">&quot;110&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange scores 0 -1 withscores</span><br><span class="line"> 1) &quot;admin&quot;</span><br><span class="line"> 2) &quot;69&quot;</span><br><span class="line"> 3) &quot;peter&quot;</span><br><span class="line"> 4) &quot;76&quot;</span><br><span class="line"> 5) &quot;tom&quot;</span><br><span class="line"> 6) &quot;89&quot;</span><br><span class="line"> 7) &quot;david&quot;</span><br><span class="line"> 8) &quot;100&quot;</span><br><span class="line"> 9) &quot;xym&quot;</span><br><span class="line">10) &quot;110&quot;</span><br></pre></td></tr></table></figure><p>如果指定的元素不存在，redis在执行命令前会先去建立并将它的分数赋为0再去执行操作。</p><h3 id="2、命令拾遗"><a href="#2、命令拾遗" class="headerlink" title="2、命令拾遗"></a>2、命令拾遗</h3><ul><li>获得集合中的元素的数量  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ZCARD key</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zcard scores</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; zrange scores 0 -1 withscores</span><br><span class="line"> 1) &quot;admin&quot;</span><br><span class="line"> 2) &quot;69&quot;</span><br><span class="line"> 3) &quot;peter&quot;</span><br><span class="line"> 4) &quot;76&quot;</span><br><span class="line"> 5) &quot;tom&quot;</span><br><span class="line"> 6) &quot;89&quot;</span><br><span class="line"> 7) &quot;david&quot;</span><br><span class="line"> 8) &quot;100&quot;</span><br><span class="line"> 9) &quot;xym&quot;</span><br><span class="line">10) &quot;110&quot;</span><br></pre></td></tr></table></figure><ul><li>获得指定分数范围内的元素个数  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zcount scores (80 +inf</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><ul><li>删除一个或多个元素  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member ...]</span><br></pre></td></tr></table></figure><p>ZREM 命令的返回值是成功删除的元素数量（不包含本来就不存在的元素）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange scores 0 -1 withscores</span><br><span class="line"> 1) &quot;admin&quot;</span><br><span class="line"> 2) &quot;69&quot;</span><br><span class="line"> 3) &quot;peter&quot;</span><br><span class="line"> 4) &quot;76&quot;</span><br><span class="line"> 5) &quot;tom&quot;</span><br><span class="line"> 6) &quot;89&quot;</span><br><span class="line"> 7) &quot;david&quot;</span><br><span class="line"> 8) &quot;100&quot;</span><br><span class="line"> 9) &quot;xym&quot;</span><br><span class="line">10) &quot;110&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrem scores tom</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange scores 0 -1 withscores</span><br><span class="line">1) &quot;admin&quot;</span><br><span class="line">2) &quot;69&quot;</span><br><span class="line">3) &quot;peter&quot;</span><br><span class="line">4) &quot;76&quot;</span><br><span class="line">5) &quot;david&quot;</span><br><span class="line">6) &quot;100&quot;</span><br><span class="line">7) &quot;xym&quot;</span><br><span class="line">8) &quot;110&quot;</span><br></pre></td></tr></table></figure><ul><li>按照排名范围删除元素  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYRANK key start top</span><br></pre></td></tr></table></figure><p>ZREMRANGEBYRANK命令按照元素的分数从小到大的顺序（即索引0表示最小的值）删除处在指定排名范围内的所有元素，并返回删除的元素数量。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange scores 0 -1 withscores</span><br><span class="line">1) &quot;admin&quot;</span><br><span class="line">2) &quot;69&quot;</span><br><span class="line">3) &quot;peter&quot;</span><br><span class="line">4) &quot;76&quot;</span><br><span class="line">5) &quot;david&quot;</span><br><span class="line">6) &quot;100&quot;</span><br><span class="line">7) &quot;xym&quot;</span><br><span class="line">8) &quot;110&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYRANK scores 0 1</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange scores 0 -1 withscores</span><br><span class="line">1) &quot;david&quot;</span><br><span class="line">2) &quot;100&quot;</span><br><span class="line">3) &quot;xym&quot;</span><br><span class="line">4) &quot;110&quot;</span><br></pre></td></tr></table></figure><ul><li>按照分数范围删除元素  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREMRANGEBYSCORE key min max</span><br></pre></td></tr></table></figure><p>ZREMRANGEBYSCORE命令会删除指定分数范围内所有元素，参数min和max的特性和ZRANGEBYSCORE命令中的一样。返回值是删除的元素数量。如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange scores 0 -1 withscores</span><br><span class="line">1) &quot;tom&quot;</span><br><span class="line">2) &quot;78&quot;</span><br><span class="line">3) &quot;admin&quot;</span><br><span class="line">4) &quot;98&quot;</span><br><span class="line">5) &quot;david&quot;</span><br><span class="line">6) &quot;100&quot;</span><br><span class="line">7) &quot;xym&quot;</span><br><span class="line">8) &quot;110&quot;</span><br><span class="line">127.0.0.1:6379&gt; zremrangebyscore scores (98 101</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange scores 0 -1 withscores</span><br><span class="line">1) &quot;tom&quot;</span><br><span class="line">2) &quot;78&quot;</span><br><span class="line">3) &quot;admin&quot;</span><br><span class="line">4) &quot;98&quot;</span><br><span class="line">5) &quot;xym&quot;</span><br><span class="line">6) &quot;110&quot;</span><br></pre></td></tr></table></figure><ul><li>获得元素排名  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZRANK key member</span><br><span class="line">ZREVRANK key member</span><br></pre></td></tr></table></figure><p>ZRANK命令会按照元素分数从小到大的顺序获得指定的元素的排名（从0开始，即分数最小的元素排名为0），ZREVRANK命名相反（分数最大的元素排名为0）。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange scores 0 -1 withscores</span><br><span class="line">1) &quot;tom&quot;</span><br><span class="line">2) &quot;78&quot;</span><br><span class="line">3) &quot;admin&quot;</span><br><span class="line">4) &quot;98&quot;</span><br><span class="line">5) &quot;xym&quot;</span><br><span class="line">6) &quot;110&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrank scores xym</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zrevrank scores xym</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><ul><li>计算有序集合的交集  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]</span><br></pre></td></tr></table></figure><p>ZINTERSTORE 命令用来计算多个有序集合的交集并将结果存储在destination键中（同样以有序集合的类型存储），返回值为destination键中元素的个数。destination键中元素的分数是由AGGREGATE参数决定的。<br>（1）当AGGREGATE时SUM（默认值）时，destination键中的元素的分数是每个参与计算的集合中该元素分数的和。如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd store1 1 a 2 b</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zadd store2 10 a 20 b</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; Zinterstore destStore 2 store1 store2</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange destStore 0 -1 withscores</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;11&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;22&quot;</span><br></pre></td></tr></table></figure><p>（2）当AGGREGATE时MIN时，destination键中的元素的分数是每个参与计算的集合中该元素分数的最小值。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zinterstore destStore 2 store1 store2 AGGREGATE min</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange destStore 0 -1 withscores</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;2&quot;</span><br></pre></td></tr></table></figure><p>（3）当AGGREGATE时MAX时，destination键中的元素的分数是每个参与计算的集合中该元素分数的最大值。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zinterstore destStore 2 store1 store2 AGGREGATE max</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange destStore 0 -1 withscores</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;10&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;20&quot;</span><br></pre></td></tr></table></figure><p>ZINTERSTORE 命令还能够通过WEIGHTS参数设置每个集合的权重，每个集合在参与计算时元素的分数会被乘上该集合的权重。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zinterstore destStore 2 store1 store2 WEIGHTS 1 0.1</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE destStore 0 -1 withscores</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrange store1 0 -1 withscores</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrange store2 0 -1 withscores</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;10&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;20&quot;</span><br></pre></td></tr></table></figure><p><strong>计算方式为：a分数1*1+10*0.1=2，b分数2*1+20*0.1=4，注意如果加WEIGHTS参数，则后面对应每一个有序集合的权重，是多值</strong><br>其他有序集合命令请查阅<a href="http://doc.redisfans.com/" target="_blank" rel="noopener">Redis命令中文在线参考</a></p>]]></content>
    
    <summary type="html">
    
      了解了redis基础后，本章主要介绍有序集合（zset）数据类型及相应的命令。命令拾遗部分会对其他比较有用的命令进行补充介绍
    
    </summary>
    
      <category term="redis系列" scheme="http://xym-loveit.github.io/categories/redis%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="redis命令" scheme="http://xym-loveit.github.io/tags/redis%E5%91%BD%E4%BB%A4/"/>
    
      <category term="redis五种数据类型" scheme="http://xym-loveit.github.io/tags/redis%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="有序集合（zset）" scheme="http://xym-loveit.github.io/tags/%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%88zset%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>redis入门指南-命令阶段II</title>
    <link href="http://xym-loveit.github.io/2017/05/23/redis%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E5%91%BD%E4%BB%A4%E9%98%B6%E6%AE%B5II/"/>
    <id>http://xym-loveit.github.io/2017/05/23/redis入门指南-命令阶段II/</id>
    <published>2017-05-23T13:41:20.000Z</published>
    <updated>2018-03-29T01:27:48.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h2><p>列表类型（list）可以存储一个有序的字符串列表，常用的操作是向列表二端添加元素或者获取列表的某一个片段。<br>列表类型内部是使用双向链表（double linked list）实现，所以向列表两端添加元素的时间复杂度为O（1），获取越接近两端的元素速度就越快。这意味着即使有几千万个元素的列表，获取头部或尾部的10条就也是极快的（和从只有20个元素的列表中获取头部或尾部的10条记录的速度是一样的）。<br>列表类型适合用来记录日志，可以保证新加入新日志不会受到已有日志数量的影响。列表还可以作为队列、栈结构来使用，与散列表类型最多能容纳字段数量相同，一个列表类型最多能容纳2的32次方-1个元素。</p><h3 id="1、命令"><a href="#1、命令" class="headerlink" title="1、命令"></a>1、命令</h3><ul><li>向列表两端增加元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key value [value ...]</span><br><span class="line">RPUSH key value [value ...]</span><br></pre></td></tr></table></figure><p>LPUSH 命令用来向列表左边添加元素，返回值表示增加元素后列表的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush numbers 1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>这时numbers 键中数据如下：</p><p><img src="http://op7wplti1.bkt.clouddn.com/lpush1.png" alt="lpush1之后数据机构模型"></p><p>LPUAH 命令还支持同时增加多个元素，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush numbers 2 3</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><p>LPUSH会先向列表左边加入“2”，然后再加入“3”，所以此时members 键中数据如下：</p><p><img src="http://op7wplti1.bkt.clouddn.com/lpush2.png" alt="lpush2之后数据机构模型"></p><p>向列表右边增加元素使用RPUSH命令，用法和LPUSH命令一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush numbers 2 3</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure><p>此时numbers键中的数据如下图：</p><p><img src="http://op7wplti1.bkt.clouddn.com/rpush.png" alt="rpush之后数据机构模型"></p><ul><li>从列表两端弹出元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPOP key </span><br><span class="line">RPOP key</span><br></pre></td></tr></table></figure><p>有进有出，lpop命令可以从列表左边弹出一个元素，lpop命令执行二步操作：第一步是将列表左边的元素从列表中移除，第二部是返回被移除的元素值。如：从numbers列表左边弹出一个元素（也就是“3”）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpop numbers</span><br><span class="line">&quot;3&quot;</span><br></pre></td></tr></table></figure><p>此时numbers键中的数据如下图：</p><p><img src="http://op7wplti1.bkt.clouddn.com/lpop.png" alt="lpop之后数据机构模型"></p><p>同样，rpop命令可以从右边弹出一个元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpop numbers</span><br><span class="line">&quot;-1&quot;</span><br></pre></td></tr></table></figure><p>此时numbers键中数据如下：</p><p><img src="http://op7wplti1.bkt.clouddn.com/rpop.png" alt="rpop之后数据机构模型"></p><p><strong>结合上面的4个命令可以使用列表类型来模拟栈和队列的操作：如果想把列表当做栈，则搭配LPUSH和LPOP或RPUSH和RPOP，如果想当成队列，则搭配使用LPUSH和RPOP或RPUSH和LPOP。</strong></p><ul><li>读取列表中元素个数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LLEN key</span><br></pre></td></tr></table></figure><p>当键不存在时LLEN返回0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; llen numbers</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></figure><ul><li>获取列表片段</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start stop</span><br></pre></td></tr></table></figure><p>LARNGE 命令是列表类型最常用的命令之一，它能够获得列表中的某一片段。LRANGE命令将返回索引从start到stop之间的所有元素（包含两端的元素）。与大多数人的直觉相同，redis的列表起始索引为0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange numbers 0 2</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;0&quot;</span><br></pre></td></tr></table></figure><p>LRANGE 命令也支持负索引，表示从右边开始计算序数，如“-1”表示最右边第一个元素，“-2”表示最右边第二个元素，以此类推：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange numbers -2 -1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;0&quot;</span><br></pre></td></tr></table></figure><p>显然，LRANGE numbers 0 -1 可以获取列表中所有元素。另外一些特殊情况如下：<br>（1）如果start的索引位置比stop的索引位置靠后，则会返回空列表<br>（2）如果stop大于实际的索引范围，则会返回到列表最后边的元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange number 2 1</span><br><span class="line">(empty list or set)</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lrange numbers 1 100</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;0&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><ul><li>删除列表中指定的值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LREM key count value</span><br></pre></td></tr></table></figure><p>LREM 命令会删除列表中前count个值为value的元素，返回值是实际删除的元素个数。<br>根据count值得不同，LREM命令执行的方式也会略有差异：  </p><pre><code>1. 当count&gt;0 时LREM命令会从列表左边开始删除前count个值为value的元素；  2. 当count&lt;0 时LREM命令会从列表右边开始删除前|count|个值为value的元素；  3. 当count=0 时LREM命令会删除所有值为value的元素。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush numbers 2</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange numbers 0 -1</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;0&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line"></span><br><span class="line">#从右边删除第一个值为&quot;2&quot;的元素</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lrem numbers -1 2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange numbers 0 -1</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;0&quot;</span><br></pre></td></tr></table></figure><h3 id="2、命令拾遗"><a href="#2、命令拾遗" class="headerlink" title="2、命令拾遗"></a>2、命令拾遗</h3><ul><li>获得/设置指定索引的元素值  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LINDEX key index --用来返回指定索引的元素，索引从0开始,如果index为负数则表示从右边开始计算索引，最右边元素索引为-1</span><br><span class="line"></span><br><span class="line">LSET key index value --将索引为index的元素赋值为value</span><br></pre></td></tr></table></figure><p>e.g:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange numbers 0 -1</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;0&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lindex numbers -2</span><br><span class="line">&quot;1&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lset numbers -2 20</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lrange numbers 0 -1</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;0&quot;</span><br></pre></td></tr></table></figure><ul><li>只保留列表指定片段<br>LTRIM key start end<br>LTRIM命令可以删除指定索引范围之外的所有元素，其指定列表范围的方法和LRANGE命令相同，如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange numbers 0 -1</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;0&quot;</span><br><span class="line">127.0.0.1:6379&gt; ltrim numbers 1 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange numbers 0 -1</span><br><span class="line">1) &quot;20&quot;</span><br><span class="line">2) &quot;0&quot;</span><br></pre></td></tr></table></figure><p>LTRIM命令常和LPUSH命令一起使用来限制列表中元素的数量，比如记录日志时我们希望只保留最近100条日志，则每次加入新元素时调用一次LTRIM命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPUSH logs $newLog</span><br><span class="line">LTRIM logs 0 99</span><br></pre></td></tr></table></figure><ul><li>向列表中插入元素  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LINSERT key BEFORE|AFTER pivot value</span><br></pre></td></tr></table></figure><p>LINSERT命令会首先在列表中从左到右查找值为pivot的元素，然后根据第二个参数是BEFORE还是AFTER来决定将value插入到该元素的前面还是后面。LINSERT命令的返回值为插入后列表元素的个数。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange numbers 0 -1</span><br><span class="line">1) &quot;20&quot;</span><br><span class="line">2) &quot;0&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange numbers 0 -1</span><br><span class="line">1) &quot;20&quot;</span><br><span class="line">2) &quot;0&quot;</span><br><span class="line">127.0.0.1:6379&gt; linsert numbers Before 20 110</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange numbers 0 -1</span><br><span class="line">1) &quot;110&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;0&quot;</span><br><span class="line">127.0.0.1:6379&gt; linsert numbers AFTER 20 21 </span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange numbers 0 -1</span><br><span class="line">1) &quot;110&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;21&quot;</span><br><span class="line">4) &quot;0&quot;</span><br></pre></td></tr></table></figure><ul><li>将元素从一个列表转到另一个列表  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPOPLPUSH source destination</span><br></pre></td></tr></table></figure><p>RPOPLPUSH是个很有意思的命令，从名字就可以看出它的功能：先执行RPOP命令再执行LPUSH命令。RPOPLPUSH命令会先从source列表类型键的右边弹出一个元素，然后将其将入到destination列表类型键的左边，并返回这个元素的值，整个过程是原子的。</p><p>当把列表类型作为队列使用时，RPOPLPUSH命令可以很直观地在多个队列中传递数据。当source和destination相同时，RPOPLPUSH命令会不断的将队尾的元素移到队首借助这个特性我们可以实现一个网站监控系统：使用一个队列存储需要监控的网址，然后监控程序不断地使用RPOPLPUSH命令循环取出一个网址来测试可用性。这里使用RPOPLPUSH命令的好处在于程序执行过程中仍然可以不断地向网址列表中加入新网址，而且整个系统容易扩展，允许多个客户端同事处理队列。</p><h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><p>集合类型和列表类型有相似之处，但很容易将他们区分开来，见下表：</p><p>集合类型和列表类型对比</p><table><thead><tr><th>特性</th><th>集合类型</th><th>列表类型</th></tr></thead><tbody><tr><td>存储内容</td><td>至多2的32次方-1</td><td>至多2的32次方-1</td></tr><tr><td>有序性</td><td>否</td><td>是</td></tr><tr><td>唯一性</td><td>是</td><td>否</td></tr></tbody></table><p>集合类型的常用操作是向集合中加入或删除元素，判断某个元素是否存在等，由于集合类型在redis内部是使用值为空的散列表（hash table）实现，所以这些操作的时间复杂度都是O（1）。最方便的是多个集合类型键之间还可以进行并集、交集和差集运算。</p><h3 id="1、命令-1"><a href="#1、命令-1" class="headerlink" title="1、命令"></a>1、命令</h3><ul><li>增加/删除元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SADD key member [member ...]</span><br><span class="line">SREM key member [member ...]</span><br></pre></td></tr></table></figure><p>SADD命令用来向集合中增加一个或多个元素，如果键不存在则会自动创建。因为在yige<br> 集合中不能有相同的元素，所以如果要加入的元素已经存在于集合中就会忽略这个元素。<br> 本命令的返回值是成功加入的元素数量（怒略的元素不计算在内）。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd letters a</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd letters a b c</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><p>第二条命令返回值为2是因为元素“a” 已经存在，所以实际加入了2个元素。<br>SREM 用来从集合中删除一个或多个元素，返回值为成功删除个数，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; srem letters c d</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>由于“d”在集合中不存在，所以只删除了一个元素，返回值为1。</p><ul><li>获得集合中所有元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></table></figure><p>SMEMBERS命令返回集合中所有元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers letters</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;a&quot;</span><br></pre></td></tr></table></figure><ul><li>判断元素是否在集合中<br>SISMEMBER key member<br>判断一个元素是否在集合是一个时间复杂度为O（1）的操作，无论集合中有多少元素，SISMEMBER命令始终可以极快返回结果。当值存在时SISMEMBER返回为1，当值不存在或键不存在时返回0，如：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sismember letters a</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember letters d</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><ul><li>集合间运算</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDIFF key [key ...]</span><br><span class="line">SINTER key [key ...]</span><br><span class="line">SUNION key [key ...]</span><br></pre></td></tr></table></figure><p>（1）SDIFF命令用来对多个集合执行差集运算。集合A与集合B差集表示为A-B，代表所有属于A且不属于B的元素构成的集合即A-B={x∈A且x∉B }。如图</p><p><img src="http://op7wplti1.bkt.clouddn.com/sdiff.png" alt="sdiff集合差集"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd setA 1 2 3</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; sadd setB 2 3 4</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; Sdiff setA setB</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; Sdiff setB setA</span><br><span class="line">1) &quot;4&quot;</span><br></pre></td></tr></table></figure><p>SDIFF命令支持同时传入多个键，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd setC 2 3</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; Sdiff setB setA setC</span><br><span class="line">1) &quot;4&quot;</span><br></pre></td></tr></table></figure><p>计算顺序是先计算setA-setB，再将计算结果与setC做差集。<br>（2）SINTER命令用来对多个集合执行交集运算。集合A与集合B交集表示为A∩B，代表所有属于A且属于B的元素构成的集合，即A∩B={x|x∈A且x∈B}。如图</p><p><img src="http://op7wplti1.bkt.clouddn.com/sinter.png" alt="sinter集合交集"> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sinter setA setB</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; sinter setA setB setC</span><br><span class="line">1) &quot;2&quot;</span><br><span class="line">2) &quot;3&quot;</span><br></pre></td></tr></table></figure><p>（3）SUNION命令用来对多个集合执行并集运算。集合A与集合B的并集表示为A∪B，代表所有<br>    属于A或属于B的元素构成的集合，即A∪B={x|x∈A或x∈B }。如    </p><p><img src="http://op7wplti1.bkt.clouddn.com/sunion.png" alt="sunion 集合并集"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sunion setA setB</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line">127.0.0.1:6379&gt; sunion setA setB setC</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br></pre></td></tr></table></figure><h3 id="2、命令拾遗-1"><a href="#2、命令拾遗-1" class="headerlink" title="2、命令拾遗"></a>2、命令拾遗</h3><ul><li>获得集合中元素个数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SCARD key</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; smembers letters</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; scard letters</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><ul><li>进行集合运算并将结果存储</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SDIFFSTORE destination key [key ...]</span><br><span class="line">SINTERSTORE destination key [key ...]</span><br><span class="line">SUNIONSTORE destination key [key ...]</span><br></pre></td></tr></table></figure><p>SDIFFSTORE命令和SDIFF命令功能一样，唯一的区别就是前者不会直接返回运算结果，而是将结果存储在destination键中。<br>SINTERSTORE命令常用于需要进行多步集合运算的场景中，如需要先计算差集再将结果和其他键计算交集。</p><ul><li>随机获得集合中的元素  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRANDMEMBER key [count]</span><br></pre></td></tr></table></figure><p>SRANDMEMBER命令用来随机从集合中获取一个元素，如：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; srandmember letters</span><br><span class="line">&quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; srandmember letters</span><br><span class="line">&quot;b&quot;</span><br></pre></td></tr></table></figure><p>还可以通过传递count参数来一次随机获取多个元素，根据count的正负不同，具体表现也不同。<br>（1）当count为正数时，SRANDMEMBER会随机从集合里获得count个不重复的元素，如果count值大于集合中的元素个数，则SRANDMEMBER会返回集合中全部元素。  </p><p>（2）当count为负数时，SRANDMEMBER会随机从集合里获得|count|个元素，这些元素有可能相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; srandmember letters 2</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;d&quot;</span><br><span class="line">127.0.0.1:6379&gt; srandmember letters 2</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">127.0.0.1:6379&gt; srandmember letters -2</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">127.0.0.1:6379&gt; srandmember letters -2</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">127.0.0.1:6379&gt; srandmember letters -10</span><br><span class="line"> 1) &quot;b&quot;</span><br><span class="line"> 2) &quot;c&quot;</span><br><span class="line"> 3) &quot;a&quot;</span><br><span class="line"> 4) &quot;b&quot;</span><br><span class="line"> 5) &quot;c&quot;</span><br><span class="line"> 6) &quot;c&quot;</span><br><span class="line"> 7) &quot;b&quot;</span><br><span class="line"> 8) &quot;b&quot;</span><br><span class="line"> 9) &quot;d&quot;</span><br><span class="line">10) &quot;a&quot;</span><br></pre></td></tr></table></figure><p>b出现的 几率比较大（原因参见redis入门指南第65页）</p><ul><li>从集合中弹出一个元素      </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SPOP key</span><br></pre></td></tr></table></figure><p>spop会随机选择一个元素从集合中弹出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers letters</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; spop letters</span><br><span class="line">&quot;c&quot;</span><br><span class="line">127.0.0.1:6379&gt; smembers letters</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;a&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      了解了redis基础后，本章主要介绍redis列表（list）和集合（set）数据类型及相应的命令。命令拾遗部分会对其他比较有用的命令进行补充介绍。
    
    </summary>
    
      <category term="redis系列" scheme="http://xym-loveit.github.io/categories/redis%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="redis命令" scheme="http://xym-loveit.github.io/tags/redis%E5%91%BD%E4%BB%A4/"/>
    
      <category term="redis五种数据类型" scheme="http://xym-loveit.github.io/tags/redis%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="列表（list）" scheme="http://xym-loveit.github.io/tags/%E5%88%97%E8%A1%A8%EF%BC%88list%EF%BC%89/"/>
    
      <category term="集合（set）" scheme="http://xym-loveit.github.io/tags/%E9%9B%86%E5%90%88%EF%BC%88set%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>redis入门指南-命令阶段I</title>
    <link href="http://xym-loveit.github.io/2017/05/23/redis%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E5%91%BD%E4%BB%A4%E9%98%B6%E6%AE%B5I/"/>
    <id>http://xym-loveit.github.io/2017/05/23/redis入门指南-命令阶段I/</id>
    <published>2017-05-23T07:48:38.000Z</published>
    <updated>2018-03-29T01:27:48.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令热身"><a href="#命令热身" class="headerlink" title="命令热身"></a>命令热身</h2><h3 id="1-获得符合规则的键名列表"><a href="#1-获得符合规则的键名列表" class="headerlink" title="1. 获得符合规则的键名列表"></a>1. 获得符合规则的键名列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEYS pattern</span><br></pre></td></tr></table></figure><p>pattern支持glob风格通配符格式，具体规则如下表：<br>符号|含义<br>—|—<br>？|匹配一个字符<br>*|匹配任意个（包括0个）字符<br>[]|匹配括号间任意字符，可以使用“-”符号表示一个范围，如a[b-d]可以匹配ab、ac、ad<br>\x|匹配字符x，用于转义符号。如要匹配？就需要使用 \?</p><h3 id="2-判断键是否存在"><a href="#2-判断键是否存在" class="headerlink" title="2. 判断键是否存在"></a>2. 判断键是否存在</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXISTS key</span><br></pre></td></tr></table></figure><p>如果存在返回1，否则返回0。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists test</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; exists noexists</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><h3 id="3-删除键"><a href="#3-删除键" class="headerlink" title="3. 删除键"></a>3. 删除键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEL key [key ...]</span><br></pre></td></tr></table></figure><p>可以删除一个或多个键，返回数字是删除键的个数。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del test</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; del test</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>第二次执行del命令返回0，因为test已经被删除了，实际并没有删除任何键，所以返回值为0。</p><p><strong>技巧：DEL 命令的参数不支持通配符，但我们可以结合linux的管道和xargs命令自己实现删除所有符合规则的键。比如要删除所有以”user:*“开头的键,就可以执行redis-cli KEYS “user:*“|xargs redis-cli DEL。另外由于DEL命令支持多个键作为参数，所以还可以执行redis-cli DEL ‘redis-cli KEYS “user:*“‘ 来达到同样的效果，但是性能更好。</strong></p><h3 id="4-获得键值的数据类型"><a href="#4-获得键值的数据类型" class="headerlink" title="4. 获得键值的数据类型"></a>4. 获得键值的数据类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TYPE key</span><br></pre></td></tr></table></figure><p>TYPE 命令用来获取键值的数据类型，返回值可能是string（字符串类型）、hash（散列类型）、list（列表类型）、set（集合类型）、zset（有序集合类型）。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set str str123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; type str</span><br><span class="line">string --字符串</span><br><span class="line">127.0.0.1:6379&gt; lpush list1 l1 l2 l3 l4</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; type list1</span><br><span class="line">list --列表</span><br><span class="line">127.0.0.1:6379&gt; hmset people:1 name zhangsan age 22 work javacoder</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; type people:1</span><br><span class="line">hash --散列</span><br><span class="line">127.0.0.1:6379&gt; zadd zset1 101 a 102 b</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; type zset1</span><br><span class="line">zset --有序集合</span><br><span class="line">127.0.0.1:6379&gt; sadd set1 java oracle servet spring hibernate</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; type set1</span><br><span class="line">set --集合</span><br></pre></td></tr></table></figure><hr><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>字符串类型是redis中最基本的数据类型，它能存储任何形式的字符串，包括二进制数据。你可以用其存储用户邮箱、json化的对象甚至是一张图片。一个字符串类型键允许存储的数据最大容量是512MB。<br>字符串类型是其他4中数据类型的基础，其他数据类型和字符串的差别从某种角度来说只是组织字符串的形式不同。</p><h3 id="1、命令"><a href="#1、命令" class="headerlink" title="1、命令"></a>1、命令</h3><ul><li>取值赋值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET key value</span><br><span class="line">GET key</span><br></pre></td></tr></table></figure><ul><li>递增数字</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR key</span><br></pre></td></tr></table></figure><p>前面说过字符串可以存储任何形式的字符串，当存储的字符串是整数形式时，redis提供了一个使用的命令INCR，其作用是让当前键值递增，并返回递增后的值，用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; incr num</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; incr num</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><p>包括INCR在内的所有redis命令都是原子操作，无论有多少客户端连接到redis执行命令都不可能出现竞态条件。</p><h3 id="2、实践"><a href="#2、实践" class="headerlink" title="2、实践"></a>2、实践</h3><p>提示：redis对于键的命名并没有强制的要求，但比较好的实践是用“对象类型:对象ID:对象属性”来命名一个键，如使用键user:1:friends来存储ID为1的用户的好友列表，对于多个单词则推荐使用“.”分隔，一方面是沿用以前的习惯（redis之前的版本键名不能包含空格等特殊符号），另一方面是在redis-cli中容易输入，无需使用双引号包裹。另外为了日后维护方便，键的命名一定要有意义，如u:f:1的可读性显然不如user:1:friends好（虽然采用较短的名称可以节省存储空间，但由于键值的长度往往大于键名的长度，所以这部分的节省大部分情况下并不如可读性来得重要）。</p><h3 id="3、命令拾遗"><a href="#3、命令拾遗" class="headerlink" title="3、命令拾遗"></a>3、命令拾遗</h3><ul><li>增加指定整数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBY key increment</span><br></pre></td></tr></table></figure><p>INCRBY命令与INCR命令基本一样，只不过前者可以通过increment 参数指定一次增加的数值，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; incrby num 20</span><br><span class="line">(integer) 22</span><br><span class="line">127.0.0.1:6379&gt; incrby num 30</span><br><span class="line">(integer) 52</span><br></pre></td></tr></table></figure><ul><li>减少指定的整数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECR key</span><br><span class="line">DECRBY key decrement</span><br></pre></td></tr></table></figure><p>DECR命令与INCR命令用法相同，只不过时让键值递减，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; decr num</span><br><span class="line">(integer) 51</span><br><span class="line">127.0.0.1:6379&gt; decrby num 30</span><br><span class="line">(integer) 21</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure><p>DECR和INCR及DECRBY和INCRBY是相反的操作，可通过正负数字实现对方相同的功能。</p><ul><li>指定增加浮点数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBYFLOAT key increment</span><br></pre></td></tr></table></figure><p>INCRBYFLOAT命令类似INCRBY 命令，差别是前者可以递增一个双精度浮点数，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; incrbyfloat fnum 2.764</span><br><span class="line">&quot;2.764&quot;</span><br><span class="line">127.0.0.1:6379&gt; incrbyfloat fnum 2E+4</span><br><span class="line">&quot;20002.76399999999999935&quot;</span><br></pre></td></tr></table></figure><ul><li>向尾部追加值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPEND key value</span><br></pre></td></tr></table></figure><p>APPEND作用是向键值的末尾追加value。如果键不存在则将改键的值设为value，即相当于SET key value。返回值是追加后的字符串长度。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; append key &quot; world&quot;</span><br><span class="line">(integer) 11</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">&quot;hello world&quot;</span><br></pre></td></tr></table></figure><p>append命令的第二个参数加双引号，原因是该参数包含了空格，在redis-cli中输入需要双引号以示区分。</p><ul><li>获取字符串长度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STRLEN key</span><br></pre></td></tr></table></figure><p>STRLEN命令返回键值的长度，如果键不存在则返回0。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key 你好</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key</span><br><span class="line">&quot;\xe4\xbd\xa0\xe5\xa5\xbd&quot;</span><br><span class="line">127.0.0.1:6379&gt; strlen key</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure><ul><li>同时获得/设置多个键值  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MGET key[key ...]</span><br><span class="line">MSET key value [key value ...]</span><br></pre></td></tr></table></figure><p>MGET/MSET与GET/SET相似，不过MGET/MSET可以同时获得/设置多个键的键值，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3 k4 v4</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">&quot;v3&quot;</span><br><span class="line">127.0.0.1:6379&gt; get k4</span><br><span class="line">&quot;v4&quot;</span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3 k4</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">3) &quot;v3&quot;</span><br><span class="line">4) &quot;v4&quot;</span><br></pre></td></tr></table></figure><ul><li>位操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GETBIT key offset --获取字符串类型键指定位置的二进制位的值（0或1），索引从0开始</span><br><span class="line">SETBIT key offset value --设置字符串类型键指定位置的二进制值，返回改位置旧值</span><br><span class="line">BITCOUNT key [start] [end] --获得字符串类型键中值为1的二进制位个数</span><br><span class="line">BITOP operation destkey key [key ...]--对多个字符串类型键进行位运算，并将结果存储在destkey参数指定的键中，bitop支持的操作命令（operation参数）有AND/OR/XOR/NOT。</span><br></pre></td></tr></table></figure><p>一个字节有8个二进制位组成，Redis通过以上命令可以直接对二进制位进行操作。为演示首先准备将foo赋值为bar：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set foo bar</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>bar的三个字母对应的ASCII码分别为98/97/114转换为二进制如下：  </p><p><img src="http://op7wplti1.bkt.clouddn.com/barbin.png" alt="bar的二进制"></p><p>GETBIT命令可以获得一个字符串类型键值指定位置的二进制的值（0/1）索引从0开始：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit foo 0</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit foo 6</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p>如果需要获取的二进制的索引超出了键值的二进制的实际长度则默认位值是0：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit foo 100</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>SETBIT命令可以设置字符串类型键值指定位置的二进制位的值，返回值是该位置的旧值。如我们要将foo键值设置为aar，可以通过操作将foo键的二进制位的索引第6位设为0，第7位设为1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit foo 6 0</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setbit foo 7 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get foo</span><br><span class="line">&quot;aar&quot;</span><br></pre></td></tr></table></figure><p>BITCOUNT 命令可以获得字符串类型键中值是1的二进制位个数，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount foo</span><br><span class="line">(integer) 10</span><br></pre></td></tr></table></figure><p>可以通过参数来限制统计字符的范围，如我们只希望统计前2个字节（即“aa”）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount foo 0 1</span><br><span class="line">(integer) 6</span><br></pre></td></tr></table></figure><p>通过BITOP命令我们可以对bar和aar进行or运算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set foo1 bar</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set foo2 aar</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; bitop or res foo1 foo2</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; get res</span><br><span class="line">&quot;car&quot;</span><br></pre></td></tr></table></figure><p>运算过程如下图：  </p><p><img src="http://op7wplti1.bkt.clouddn.com/orcalc.png" alt="bit的or操作运算过程"></p><h2 id="散列类型"><a href="#散列类型" class="headerlink" title="散列类型"></a>散列类型</h2><p>redis是采用字典结构以键值对的形式存储数据，而散列类型（hash）的健值也是一种字典结构，其存储了字段（field）和字段值的映射，但字段值只能是字符串，不支持其他类型数据，换句话说，散列类型不能嵌套其他的数据类型。一个散列类型键可以包含至多2的32次方-1个字段。</p><p><em>提示：除了散列类型，redis的其他数据类型同样不支持数据类型嵌套。比如集合类型的每个元素都只能是字符串，不能是另一个集合或散列表等。</em></p><p>散列类型适合存储对象：使用对象类别和ID构成键名，使用字段表示对象属性，而字段值则存储属性值。例如要存储ID为2的汽车对象，可以分别使用名为color、name和price的3个字段来存储该辆汽车的颜色、名称和价格。存储结构如图：</p><p><img src="http://op7wplti1.bkt.clouddn.com/hashcar.png" alt="散列表存储汽车对象模型"></p><p>相比关系型数据库（数据是以二维表的形式存储，要求所有记录都拥有同样的属性，无法单独为某条记录增减属性）redis散列类型不存在字段冗余等问题。redis并不要求每个键都依据固定的结构存储，我们完全可以自由的为任何键增减字段而不影响其他键。</p><h3 id="1、命令-1"><a href="#1、命令-1" class="headerlink" title="1、命令"></a>1、命令</h3><ul><li>赋值与取值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value --</span><br><span class="line">HGET key field --根据field获取对应键值</span><br><span class="line">HMSET key field value [field value ...]</span><br><span class="line">HMGET key field [field ...]</span><br><span class="line">HGETALL key</span><br></pre></td></tr></table></figure><p>HSET命令用来给字段赋值，而HGET命令用来获得字段值。用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HSET car price 500</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HSET car name BMW</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HGET car name</span><br><span class="line">&quot;BMW&quot;</span><br></pre></td></tr></table></figure><p>HSET命令方便之处在于不区分插入和更新操作，这意味着修改数据时不用事先判断字段是否存在再来决定执行的是插入操作（insert）还是更新（update）操作。当执行的是插入操作时（即之前的字段不存在）HSET命令返回1，当执行的是更新操作时（即之前字段存在）HSET命令返回0。更进一步，当键本身不存在时，HSET命令还会自动创建它。</p><p>当需要同时设置多个字段的值时，可以使用HMSET命令。例如，下面语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HSET key field1 value1</span><br><span class="line">HSET key field2 value2</span><br></pre></td></tr></table></figure><p>可以用HMSET命令改写成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMSET key field1 value1 field2 value2</span><br></pre></td></tr></table></figure><p>相应地，HMGET命令可以同时获得多个字段的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HMGET car name price</span><br><span class="line">1) &quot;BMW&quot;</span><br><span class="line">2) &quot;500&quot;</span><br></pre></td></tr></table></figure><p>如果想获取键中所有字段和字段值却不知道键中有哪些字段时（如汽车对象的例子，每个对象拥有的属性都未必相同）应该使用HGETALL命令。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HGETALL car</span><br><span class="line">1) &quot;price&quot;</span><br><span class="line">2) &quot;500&quot;</span><br><span class="line">3) &quot;name&quot;</span><br><span class="line">4) &quot;BMW&quot;</span><br></pre></td></tr></table></figure><ul><li>判断字段是否存在</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEXISTS key field</span><br></pre></td></tr></table></figure><p>HEXISTS 命令用来判断一个字段是否存在。如果存在则返回1，否则返回0（如果键不存在也返回0）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; Hexists car model</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; HSET car model c200</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; Hexists car model</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><ul><li>当字段不存在时赋值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSETNX key field value</span><br></pre></td></tr></table></figure><p>HSETNX命令和HSET命令类似，区别在于如果字段已经存在，HSETNX命令将不执行任何操作。<br>HSETNX 命令是原子操作，不用担心竞态条件。</p><ul><li>增加数字</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY key field increment</span><br><span class="line">127.0.0.1:6379&gt; Hincrby person score 60</span><br><span class="line">(integer) 60</span><br></pre></td></tr></table></figure><ul><li>删除字段</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HDEL key field [field ...]</span><br></pre></td></tr></table></figure><p>HDEL命令可以删除一个或多个字段，返回值是被删除的字段个数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HDEL car price</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; Hgetall car</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;BMW&quot;</span><br><span class="line">3) &quot;model&quot;</span><br><span class="line">4) &quot;c200&quot;</span><br></pre></td></tr></table></figure><h3 id="2、命令拾遗"><a href="#2、命令拾遗" class="headerlink" title="2、命令拾遗"></a>2、命令拾遗</h3><ul><li>只获取字段名或字段值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HKEYS key</span><br><span class="line">HVALS key</span><br></pre></td></tr></table></figure><p>有时仅仅需要获取键中所有字段的名字而不需要字段值，那么可以使用HKEYS命令，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; Hkeys car</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;model&quot;</span><br></pre></td></tr></table></figure><p>HVALS命令和HKEYS命令相对应，HVALS命令用来获得键中的所有字段值，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HVALS car</span><br><span class="line">1) &quot;BMW&quot;</span><br><span class="line">2) &quot;c200&quot;</span><br></pre></td></tr></table></figure><ul><li>获得字段数量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HLEN key</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; Hlen car</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      了解了redis基础后，本章主要介绍redis字符串（string）、散列表（hash）数据类型及相应的命令。命令拾遗部分会对其他比较有用的命令进行补充介绍。
    
    </summary>
    
      <category term="redis系列" scheme="http://xym-loveit.github.io/categories/redis%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="redis命令" scheme="http://xym-loveit.github.io/tags/redis%E5%91%BD%E4%BB%A4/"/>
    
      <category term="redis五种数据类型" scheme="http://xym-loveit.github.io/tags/redis%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="字符串（string）" scheme="http://xym-loveit.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88string%EF%BC%89/"/>
    
      <category term="散列表（hash）" scheme="http://xym-loveit.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88hash%EF%BC%89/"/>
    
  </entry>
  
  <entry>
    <title>redis入门指南-准备阶段</title>
    <link href="http://xym-loveit.github.io/2017/05/23/redis%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97-%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5/"/>
    <id>http://xym-loveit.github.io/2017/05/23/redis入门指南-准备阶段/</id>
    <published>2017-05-23T02:26:22.000Z</published>
    <updated>2018-03-29T01:27:48.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、启动和停止"><a href="#一、启动和停止" class="headerlink" title="一、启动和停止"></a>一、启动和停止</h2><p>redis 可执行文件说明  </p><table><thead><tr><th>文件名</th><th>说明</th></tr></thead><tbody><tr><td>redis-server</td><td>Redis服务器</td></tr><tr><td>redis-cli</td><td>Redis命令行客户端</td></tr><tr><td>redis-benchmark</td><td>Redis性能测试工具</td></tr><tr><td>redis-check-aof</td><td>AOF文件修复工具</td></tr></tbody></table><h3 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h3><hr><h4 id="直接启动"><a href="#直接启动" class="headerlink" title="直接启动"></a>直接启动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --port 6379</span><br></pre></td></tr></table></figure><p>redis 默认使用6379,通过port参数可自定义端口号</p><h4 id="通过初始化脚本启动redis"><a href="#通过初始化脚本启动redis" class="headerlink" title="通过初始化脚本启动redis"></a>通过初始化脚本启动redis</h4><p>在redis的源代码目录utils下有一个名为redis_init_script的初始化脚本文件，我们需要配置redis的运行方式和持久化文件、日志文件的存储位置等，步骤如下：</p><ol><li><p>配置初始化脚本。将初始化文件复制到/etc/init.d目录中，并更名为redis_端口号，其中端口号表示redis监听的端口号，客户端通过该端口号链接redis。然后修改脚本第6行REDISPORT变量值为同样的端口号。</p></li><li><p>建立需要的文件夹。</p></li></ol><p>需要建立目录及说明</p><table><thead><tr><th>目录名</th><th>说明</th></tr></thead><tbody><tr><td>/etc/redis</td><td>存放redis配置文件</td></tr><tr><td>/var/redis/端口号</td><td>存放redis持久化文件</td></tr></tbody></table><ol start="3"><li>修改配置文件。将配置文件模板复制到/etc/redis目录中，依端口号命名(如：“6379.conf”),然后按下表对文件参数进行编辑。</li></ol><table><thead><tr><th>参数</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>daemonize</td><td>yes</td><td>使redis依守护进程模式启动</td></tr><tr><td>pidfile</td><td>/var/run/redis_端口号.pid</td><td>设置redis的pid文件位置</td></tr><tr><td>port</td><td>端口号</td><td>设置redis监听的端口号</td></tr><tr><td>dir</td><td>/var/redis/端口号</td><td>设置持久化文件存储位置</td></tr></tbody></table><p>现在就可以使用/etc/init.d/redis_端口号 start来启动redis了，然后执行下面命令让redis随系统自启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-rc.d redis_端口号 defaults</span><br></pre></td></tr></table></figure><hr><h3 id="停止redis"><a href="#停止redis" class="headerlink" title="停止redis"></a>停止redis</h3><p>考虑到redis有可能正在将内存中的数据同步到磁盘中，强制终止redis进程可能导致丢失数据。正确停止redis的方式应该是向redis发送shutdown命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure><p>当redis接受到shutdown命令后，会先断开所有的客户端连接，然后根据配置执行持久化，最后完成退出。</p><p>redis可以妥善处理sigterm信号，所以使用<strong>kill redis 的pid</strong>也可以正常完成退出，效果和使用shutdown命令一样。</p><hr><h2 id="二、Redis的客户端命令"><a href="#二、Redis的客户端命令" class="headerlink" title="二、Redis的客户端命令"></a>二、Redis的客户端命令</h2><p>redis-cli（Redis Command Line Interface）是redis自带的基于命令行的客户端。使用Redis-cli向redis发送命令可以观察不同类型的命令。</p><h3 id="发送命令"><a href="#发送命令" class="headerlink" title="发送命令"></a>发送命令</h3><ol><li>将命令作为redis-cli 的参数执行，如：redis-cli shutdown。redis执行的时候会按照默认配置（服务器地址：127.0.0.1，端口号：6379，链接redis），通过-h和-p参数可以自定义地址和端口号。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379</span><br></pre></td></tr></table></figure><p>可以通过redis-cli ping在测试redis是否和客户端连接正常，如果正常会受到pong。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli ping</span><br><span class="line">pong</span><br></pre></td></tr></table></figure><ol start="2"><li>不带参数运行redis-cli，进入交互模式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ redis-cli</span><br><span class="line">127.0.0.1:6379&gt;ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt;echo hi</span><br><span class="line">&quot;hi&quot;</span><br></pre></td></tr></table></figure><p>这种方式可以输入多次命令，比较方便</p><h3 id="命令返回值"><a href="#命令返回值" class="headerlink" title="命令返回值"></a>命令返回值</h3><ol><li>状态回复 </li></ol><p>最简单的回复，例如向redis执行set命令redis回复OK，ping命令返回pong，状态回复直接显示状态信息。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PING</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><ol start="2"><li>错误回复</li></ol><p>当出现命令不存在或命令格式有错误等情况时redis会返回错误回复（error reply），错误回复以（error）开否并在后面跟上错误信息。如执行一个不存在的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ERRORCOMMAND</span><br><span class="line">(error) ERR unknown command &apos;ERRORCOMMAND&apos;</span><br></pre></td></tr></table></figure><ol start="3"><li>整数回复</li></ol><p>redis虽然没有整数类型，但却提供了一些用于操作整数的命令，如递增键值的incr命令会以整数形式返回递增后的键值。除此之外还有一些其他命令也会返回整数，如可以获取当前数据库中键的数据量的DBSIZE命令等。整数回复（integer reply）以（integer）开头，后面跟上整数数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; incr test</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; dbsize</span><br><span class="line">(integer) 23</span><br></pre></td></tr></table></figure><ol start="4"><li>字符串回复</li></ol><p>字符串回复（bulk reply），为最常见的回复类型，当请求一个字符串类型键的键值或一个其他类型键中某个元素的时候就会得到字符串回复。字符串回复以双引号包裹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get test</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; hget car:1 speed</span><br><span class="line">&quot;200km/h&quot;</span><br></pre></td></tr></table></figure><p>特殊情况时当请求的键值不存在时，会得到一个空结果，显示为（nil）。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get noexists</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><ol start="5"><li>多行字符串回复</li></ol><p>多行字符串回复（multi-bulk reply）也比较常见，当请求一个非字符串类型键的元素列表时就会收到多行字符串回复。多行字符串中每行都以一个序号开头，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line"> 1) &quot;homepageZhdll_20175rank2&quot;</span><br><span class="line"> 2) &quot;clueUserKey:363:4:321102&quot;</span><br><span class="line"> 3) &quot;car:1&quot;</span><br><span class="line"> 4) &quot;homepageCyph_20175rank2&quot;</span><br></pre></td></tr></table></figure><p>特殊情况,当数据库中为空时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br></pre></td></tr></table></figure><h2 id="三、配置"><a href="#三、配置" class="headerlink" title="三、配置"></a>三、配置</h2><p> redis支持通过配置文件来设置参数选项。启用配置文件的方法是在启动时将配置文件路径作为参数传递给redis-server，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /path/to/redis.conf</span><br></pre></td></tr></table></figure><p>通过启动参数传递同名的配置选项会覆盖配置文件中的参数，像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /path/to/redis.conf --loglevel warning</span><br></pre></td></tr></table></figure><p>redis提供了配置文件模板位于源代码的根目录中。<br>除此之外还可以在redis运行时通过 config set命令在不重新启动redis服务的情况下动态修改部分redis配置，就像<br>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config set loglevel warning</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>并不是所有的命令都可以使用config set命令动态修改，同样在运行的时候也可以使用config get 命令获得redis当前的配置情况，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get loglevel</span><br><span class="line">1) &quot;loglevel&quot;</span><br><span class="line">2) &quot;warning&quot;</span><br></pre></td></tr></table></figure><p>第一行为选项名，第二行选项值</p><h2 id="四、多数据库"><a href="#四、多数据库" class="headerlink" title="四、多数据库"></a>四、多数据库</h2><p>每个数据库对外都是以0开始的递增命名，redis默认支持16个数据库（0,1,2,3…15）可以通过配置参数databases来修改。客户端与redis建立连接后会自动选择0号数据库，不过可以通过select 命令更换数据库如：选择一号数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; select 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; get test</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><p>然而这些以数字命名的数据库又与我们理解的数据库有所区别。首选redis不支持自定义数据库名字，每个数据库都以编号命名，开发者必须自己记录哪些数据库存储了哪些数据。另外redis也不支持为每个数据库设置不同的访问密码，所以一个客户端要么可以访问全部数据库，要么连一个数据库也没有权限访问。最重要的一点是多个数据库之间并不是完全隔离的，比如flushall 命令可以清空一个redis实例中所有数据库中的数据。综上所述，这些数据库更像是一种命名空间，而不适宜存储不同应用程序的数据。比如可以使用0号数据库存储某个应用生产环境中的数据，使用1号数据库存储测试环境中的数据，但不适宜使用0号数据库存储A应用的数据，而使用1号数据库存储B应用的数据，不同的应用应该使用不同的redis实例存储数据。由于redis非常轻量级，一个空的redis实例占用的内存只有1MB左右，所以不用担心多个redis实例会额外占用很多内存。</p>]]></content>
    
    <summary type="html">
    
      介绍运行redis及其redis的基础知识；学习redis的最好的办法就是动手尝试她。
    
    </summary>
    
      <category term="redis系列" scheme="http://xym-loveit.github.io/categories/redis%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="redis配置" scheme="http://xym-loveit.github.io/tags/redis%E9%85%8D%E7%BD%AE/"/>
    
      <category term="redis多数据库" scheme="http://xym-loveit.github.io/tags/redis%E5%A4%9A%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>常用 Git 命令清单</title>
    <link href="http://xym-loveit.github.io/2017/05/04/%E5%B8%B8%E7%94%A8-Git-%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/"/>
    <id>http://xym-loveit.github.io/2017/05/04/常用-Git-命令清单/</id>
    <published>2017-05-03T16:28:11.000Z</published>
    <updated>2018-03-29T01:27:48.648Z</updated>
    
    <content type="html"><![CDATA[<h4 id="作者：-阮一峰"><a href="#作者：-阮一峰" class="headerlink" title="作者： 阮一峰"></a>作者： 阮一峰</h4><h4 id="日期：-2015年12月-9日"><a href="#日期：-2015年12月-9日" class="headerlink" title="日期： 2015年12月 9日"></a>日期： 2015年12月 9日</h4><h4 id="原文：http-www-ruanyifeng-com-blog-2015-12-git-cheat-sheet-html"><a href="#原文：http-www-ruanyifeng-com-blog-2015-12-git-cheat-sheet-html" class="headerlink" title="原文：http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html"></a>原文：<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a></h4><p>我每天使用 Git ，但是很多命令记不住。<br>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p><p><img src="http://op7wplti1.bkt.clouddn.com/bg2015120901.png" alt="Git三大区域"></p><p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。<br>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p><h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><h5 id="在当前目录新建一个Git代码库"><a href="#在当前目录新建一个Git代码库" class="headerlink" title="在当前目录新建一个Git代码库"></a>在当前目录新建一个Git代码库</h5><pre><code>$ git init</code></pre><h5 id="新建一个目录，将其初始化为Git代码库"><a href="#新建一个目录，将其初始化为Git代码库" class="headerlink" title="新建一个目录，将其初始化为Git代码库"></a>新建一个目录，将其初始化为Git代码库</h5><pre><code>$ git init [project-name]</code></pre><h5 id="下载一个项目和它的整个代码历史"><a href="#下载一个项目和它的整个代码历史" class="headerlink" title="下载一个项目和它的整个代码历史"></a>下载一个项目和它的整个代码历史</h5><pre><code>$ git clone [url]</code></pre><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><h5 id="显示当前的Git配置"><a href="#显示当前的Git配置" class="headerlink" title="显示当前的Git配置"></a>显示当前的Git配置</h5><pre><code>$ git config --list</code></pre><h5 id="编辑Git配置文件"><a href="#编辑Git配置文件" class="headerlink" title="编辑Git配置文件"></a>编辑Git配置文件</h5><pre><code>$ git config -e [--global]</code></pre><h5 id="设置提交代码时的用户信息"><a href="#设置提交代码时的用户信息" class="headerlink" title="设置提交代码时的用户信息"></a>设置提交代码时的用户信息</h5><pre><code>$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot;</code></pre><h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><h5 id="添加指定文件到暂存区"><a href="#添加指定文件到暂存区" class="headerlink" title="添加指定文件到暂存区"></a>添加指定文件到暂存区</h5><pre><code>$ git add [file1] [file2] ...</code></pre><h5 id="添加指定目录到暂存区，包括子目录"><a href="#添加指定目录到暂存区，包括子目录" class="headerlink" title="添加指定目录到暂存区，包括子目录"></a>添加指定目录到暂存区，包括子目录</h5><pre><code>$ git add [dir]</code></pre><h5 id="添加当前目录的所有文件到暂存区"><a href="#添加当前目录的所有文件到暂存区" class="headerlink" title="添加当前目录的所有文件到暂存区"></a>添加当前目录的所有文件到暂存区</h5><pre><code>$ git add .</code></pre><h5 id="添加每个变化前，都会要求确认"><a href="#添加每个变化前，都会要求确认" class="headerlink" title="添加每个变化前，都会要求确认"></a>添加每个变化前，都会要求确认</h5><h5 id="对于同一个文件的多处变化，可以实现分次提交"><a href="#对于同一个文件的多处变化，可以实现分次提交" class="headerlink" title="对于同一个文件的多处变化，可以实现分次提交"></a>对于同一个文件的多处变化，可以实现分次提交</h5><pre><code>$ git add -p</code></pre><h5 id="删除工作区文件，并且将这次删除放入暂存区"><a href="#删除工作区文件，并且将这次删除放入暂存区" class="headerlink" title="删除工作区文件，并且将这次删除放入暂存区"></a>删除工作区文件，并且将这次删除放入暂存区</h5><pre><code>$ git rm [file1] [file2] ...</code></pre><h5 id="停止追踪指定文件，但该文件会保留在工作区"><a href="#停止追踪指定文件，但该文件会保留在工作区" class="headerlink" title="停止追踪指定文件，但该文件会保留在工作区"></a>停止追踪指定文件，但该文件会保留在工作区</h5><pre><code>$ git rm --cached [file]</code></pre><h5 id="改名文件，并且将这个改名放入暂存区"><a href="#改名文件，并且将这个改名放入暂存区" class="headerlink" title="改名文件，并且将这个改名放入暂存区"></a>改名文件，并且将这个改名放入暂存区</h5><pre><code>$ git mv [file-original] [file-renamed]</code></pre><h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><h5 id="提交暂存区到仓库区"><a href="#提交暂存区到仓库区" class="headerlink" title="提交暂存区到仓库区"></a>提交暂存区到仓库区</h5><pre><code>$ git commit -m [message]</code></pre><h5 id="提交暂存区的指定文件到仓库区"><a href="#提交暂存区的指定文件到仓库区" class="headerlink" title="提交暂存区的指定文件到仓库区"></a>提交暂存区的指定文件到仓库区</h5><pre><code>$ git commit [file1] [file2] ... -m [message]</code></pre><h5 id="提交工作区自上次commit之后的变化，直接到仓库区"><a href="#提交工作区自上次commit之后的变化，直接到仓库区" class="headerlink" title="提交工作区自上次commit之后的变化，直接到仓库区"></a>提交工作区自上次commit之后的变化，直接到仓库区</h5><pre><code>$ git commit -a</code></pre><h5 id="提交时显示所有diff信息"><a href="#提交时显示所有diff信息" class="headerlink" title="提交时显示所有diff信息"></a>提交时显示所有diff信息</h5><pre><code>$ git commit -v</code></pre><h5 id="使用一次新的commit，替代上一次提交"><a href="#使用一次新的commit，替代上一次提交" class="headerlink" title="使用一次新的commit，替代上一次提交"></a>使用一次新的commit，替代上一次提交</h5><h5 id="如果代码没有任何新变化，则用来改写上一次commit的提交信息"><a href="#如果代码没有任何新变化，则用来改写上一次commit的提交信息" class="headerlink" title="如果代码没有任何新变化，则用来改写上一次commit的提交信息"></a>如果代码没有任何新变化，则用来改写上一次commit的提交信息</h5><pre><code>$ git commit --amend -m [message]</code></pre><h5 id="重做上一次commit，并包括指定文件的新变化"><a href="#重做上一次commit，并包括指定文件的新变化" class="headerlink" title="重做上一次commit，并包括指定文件的新变化"></a>重做上一次commit，并包括指定文件的新变化</h5><pre><code>$ git commit --amend [file1] [file2] ...</code></pre><h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><h5 id="列出所有本地分支"><a href="#列出所有本地分支" class="headerlink" title="列出所有本地分支"></a>列出所有本地分支</h5><pre><code>$ git branch</code></pre><h5 id="列出所有远程分支"><a href="#列出所有远程分支" class="headerlink" title="列出所有远程分支"></a>列出所有远程分支</h5><pre><code>$ git branch -r</code></pre><h5 id="列出所有本地分支和远程分支"><a href="#列出所有本地分支和远程分支" class="headerlink" title="列出所有本地分支和远程分支"></a>列出所有本地分支和远程分支</h5><pre><code>$ git branch -a</code></pre><h5 id="新建一个分支，但依然停留在当前分支"><a href="#新建一个分支，但依然停留在当前分支" class="headerlink" title="新建一个分支，但依然停留在当前分支"></a>新建一个分支，但依然停留在当前分支</h5><pre><code>$ git branch [branch-name]</code></pre><h5 id="新建一个分支，并切换到该分支"><a href="#新建一个分支，并切换到该分支" class="headerlink" title="新建一个分支，并切换到该分支"></a>新建一个分支，并切换到该分支</h5><pre><code>$ git checkout -b [branch]</code></pre><h5 id="新建一个分支，指向指定commit"><a href="#新建一个分支，指向指定commit" class="headerlink" title="新建一个分支，指向指定commit"></a>新建一个分支，指向指定commit</h5><pre><code>$ git branch [branch] [commit]</code></pre><h5 id="新建一个分支，与指定的远程分支建立追踪关系"><a href="#新建一个分支，与指定的远程分支建立追踪关系" class="headerlink" title="新建一个分支，与指定的远程分支建立追踪关系"></a>新建一个分支，与指定的远程分支建立追踪关系</h5><pre><code>$ git branch --track [branch] [remote-branch]</code></pre><h5 id="切换到指定分支，并更新工作区"><a href="#切换到指定分支，并更新工作区" class="headerlink" title="切换到指定分支，并更新工作区"></a>切换到指定分支，并更新工作区</h5><pre><code>$ git checkout [branch-name]</code></pre><h5 id="切换到上一个分支"><a href="#切换到上一个分支" class="headerlink" title="切换到上一个分支"></a>切换到上一个分支</h5><pre><code>$ git checkout -</code></pre><h5 id="建立追踪关系，在现有分支与指定的远程分支之间"><a href="#建立追踪关系，在现有分支与指定的远程分支之间" class="headerlink" title="建立追踪关系，在现有分支与指定的远程分支之间"></a>建立追踪关系，在现有分支与指定的远程分支之间</h5><pre><code>$ git branch --set-upstream [branch] [remote-branch]</code></pre><h5 id="合并指定分支到当前分支"><a href="#合并指定分支到当前分支" class="headerlink" title="合并指定分支到当前分支"></a>合并指定分支到当前分支</h5><pre><code>$ git merge [branch]</code></pre><h5 id="选择一个commit，合并进当前分支"><a href="#选择一个commit，合并进当前分支" class="headerlink" title="选择一个commit，合并进当前分支"></a>选择一个commit，合并进当前分支</h5><pre><code>$ git cherry-pick [commit]</code></pre><h5 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h5><pre><code>$ git branch -d [branch-name]</code></pre><h5 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h5><pre><code>$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]</code></pre><h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><h5 id="列出所有tag"><a href="#列出所有tag" class="headerlink" title="列出所有tag"></a>列出所有tag</h5><pre><code>$ git tag</code></pre><h5 id="新建一个tag在当前commit"><a href="#新建一个tag在当前commit" class="headerlink" title="新建一个tag在当前commit"></a>新建一个tag在当前commit</h5><pre><code>$ git tag [tag]</code></pre><h5 id="新建一个tag在指定commit"><a href="#新建一个tag在指定commit" class="headerlink" title="新建一个tag在指定commit"></a>新建一个tag在指定commit</h5><pre><code>$ git tag [tag] [commit]</code></pre><h5 id="删除本地tag"><a href="#删除本地tag" class="headerlink" title="删除本地tag"></a>删除本地tag</h5><pre><code>$ git tag -d [tag]</code></pre><h5 id="删除远程tag"><a href="#删除远程tag" class="headerlink" title="删除远程tag"></a>删除远程tag</h5><pre><code>$ git push origin :refs/tags/[tagName]</code></pre><h5 id="查看tag信息"><a href="#查看tag信息" class="headerlink" title="查看tag信息"></a>查看tag信息</h5><pre><code>$ git show [tag]</code></pre><h5 id="提交指定tag"><a href="#提交指定tag" class="headerlink" title="提交指定tag"></a>提交指定tag</h5><pre><code>$ git push [remote] [tag]</code></pre><h5 id="提交所有tag"><a href="#提交所有tag" class="headerlink" title="提交所有tag"></a>提交所有tag</h5><pre><code>$ git push [remote] --tags</code></pre><h5 id="新建一个分支，指向某个tag"><a href="#新建一个分支，指向某个tag" class="headerlink" title="新建一个分支，指向某个tag"></a>新建一个分支，指向某个tag</h5><pre><code>$ git checkout -b [branch] [tag]</code></pre><h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><h5 id="显示有变更的文件"><a href="#显示有变更的文件" class="headerlink" title="显示有变更的文件"></a>显示有变更的文件</h5><pre><code>$ git status</code></pre><h5 id="显示当前分支的版本历史"><a href="#显示当前分支的版本历史" class="headerlink" title="显示当前分支的版本历史"></a>显示当前分支的版本历史</h5><pre><code>$ git log</code></pre><h5 id="显示commit历史，以及每次commit发生变更的文件"><a href="#显示commit历史，以及每次commit发生变更的文件" class="headerlink" title="显示commit历史，以及每次commit发生变更的文件"></a>显示commit历史，以及每次commit发生变更的文件</h5><pre><code>$ git log --stat</code></pre><h5 id="搜索提交历史，根据关键词"><a href="#搜索提交历史，根据关键词" class="headerlink" title="搜索提交历史，根据关键词"></a>搜索提交历史，根据关键词</h5><pre><code>$ git log -S [keyword]</code></pre><h5 id="显示某个commit之后的所有变动，每个commit占据一行"><a href="#显示某个commit之后的所有变动，每个commit占据一行" class="headerlink" title="显示某个commit之后的所有变动，每个commit占据一行"></a>显示某个commit之后的所有变动，每个commit占据一行</h5><pre><code>$ git log [tag] HEAD --pretty=format:%s</code></pre><h5 id="显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件"><a href="#显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件" class="headerlink" title="显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件"></a>显示某个commit之后的所有变动，其”提交说明”必须符合搜索条件</h5><pre><code>$ git log [tag] HEAD --grep feature</code></pre><h5 id="显示某个文件的版本历史，包括文件改名"><a href="#显示某个文件的版本历史，包括文件改名" class="headerlink" title="显示某个文件的版本历史，包括文件改名"></a>显示某个文件的版本历史，包括文件改名</h5><pre><code>$ git log --follow [file]$ git whatchanged [file]</code></pre><h5 id="显示指定文件相关的每一次diff"><a href="#显示指定文件相关的每一次diff" class="headerlink" title="显示指定文件相关的每一次diff"></a>显示指定文件相关的每一次diff</h5><pre><code>$ git log -p [file]</code></pre><h5 id="显示过去5次提交"><a href="#显示过去5次提交" class="headerlink" title="显示过去5次提交"></a>显示过去5次提交</h5><pre><code>$ git log -5 --pretty --oneline</code></pre><h5 id="显示所有提交过的用户，按提交次数排序"><a href="#显示所有提交过的用户，按提交次数排序" class="headerlink" title="显示所有提交过的用户，按提交次数排序"></a>显示所有提交过的用户，按提交次数排序</h5><pre><code>$ git shortlog -sn</code></pre><h5 id="显示指定文件是什么人在什么时间修改过"><a href="#显示指定文件是什么人在什么时间修改过" class="headerlink" title="显示指定文件是什么人在什么时间修改过"></a>显示指定文件是什么人在什么时间修改过</h5><pre><code>$ git blame [file]</code></pre><h5 id="显示暂存区和工作区的差异"><a href="#显示暂存区和工作区的差异" class="headerlink" title="显示暂存区和工作区的差异"></a>显示暂存区和工作区的差异</h5><pre><code>$ git diff</code></pre><h5 id="显示暂存区和上一个commit的差异"><a href="#显示暂存区和上一个commit的差异" class="headerlink" title="显示暂存区和上一个commit的差异"></a>显示暂存区和上一个commit的差异</h5><pre><code>$ git diff --cached [file]</code></pre><h5 id="显示工作区与当前分支最新commit之间的差异"><a href="#显示工作区与当前分支最新commit之间的差异" class="headerlink" title="显示工作区与当前分支最新commit之间的差异"></a>显示工作区与当前分支最新commit之间的差异</h5><pre><code>$ git diff HEAD</code></pre><h5 id="显示两次提交之间的差异"><a href="#显示两次提交之间的差异" class="headerlink" title="显示两次提交之间的差异"></a>显示两次提交之间的差异</h5><pre><code>$ git diff [first-branch]...[second-branch]</code></pre><h5 id="显示今天你写了多少行代码"><a href="#显示今天你写了多少行代码" class="headerlink" title="显示今天你写了多少行代码"></a>显示今天你写了多少行代码</h5><pre><code>$ git diff --shortstat &quot;@{0 day ago}&quot;</code></pre><h5 id="显示某次提交的元数据和内容变化"><a href="#显示某次提交的元数据和内容变化" class="headerlink" title="显示某次提交的元数据和内容变化"></a>显示某次提交的元数据和内容变化</h5><pre><code>$ git show [commit]</code></pre><h5 id="显示某次提交发生变化的文件"><a href="#显示某次提交发生变化的文件" class="headerlink" title="显示某次提交发生变化的文件"></a>显示某次提交发生变化的文件</h5><pre><code>$ git show --name-only [commit]</code></pre><h5 id="显示某次提交时，某个文件的内容"><a href="#显示某次提交时，某个文件的内容" class="headerlink" title="显示某次提交时，某个文件的内容"></a>显示某次提交时，某个文件的内容</h5><pre><code>$ git show [commit]:[filename]</code></pre><h5 id="显示当前分支的最近几次提交"><a href="#显示当前分支的最近几次提交" class="headerlink" title="显示当前分支的最近几次提交"></a>显示当前分支的最近几次提交</h5><pre><code>$ git reflog</code></pre><h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><h5 id="下载远程仓库的所有变动"><a href="#下载远程仓库的所有变动" class="headerlink" title="下载远程仓库的所有变动"></a>下载远程仓库的所有变动</h5><pre><code>$ git fetch [remote]</code></pre><h5 id="显示所有远程仓库"><a href="#显示所有远程仓库" class="headerlink" title="显示所有远程仓库"></a>显示所有远程仓库</h5><pre><code>$ git remote -v</code></pre><h5 id="显示某个远程仓库的信息"><a href="#显示某个远程仓库的信息" class="headerlink" title="显示某个远程仓库的信息"></a>显示某个远程仓库的信息</h5><pre><code>$ git remote show [remote]</code></pre><h5 id="增加一个新的远程仓库，并命名"><a href="#增加一个新的远程仓库，并命名" class="headerlink" title="增加一个新的远程仓库，并命名"></a>增加一个新的远程仓库，并命名</h5><pre><code>$ git remote add [shortname] [url]</code></pre><h5 id="取回远程仓库的变化，并与本地分支合并"><a href="#取回远程仓库的变化，并与本地分支合并" class="headerlink" title="取回远程仓库的变化，并与本地分支合并"></a>取回远程仓库的变化，并与本地分支合并</h5><pre><code>$ git pull [remote] [branch]</code></pre><h5 id="上传本地指定分支到远程仓库"><a href="#上传本地指定分支到远程仓库" class="headerlink" title="上传本地指定分支到远程仓库"></a>上传本地指定分支到远程仓库</h5><pre><code>$ git push [remote] [branch]</code></pre><h5 id="强行推送当前分支到远程仓库，即使有冲突"><a href="#强行推送当前分支到远程仓库，即使有冲突" class="headerlink" title="强行推送当前分支到远程仓库，即使有冲突"></a>强行推送当前分支到远程仓库，即使有冲突</h5><pre><code>$ git push [remote] --force</code></pre><h5 id="推送所有分支到远程仓库"><a href="#推送所有分支到远程仓库" class="headerlink" title="推送所有分支到远程仓库"></a>推送所有分支到远程仓库</h5><pre><code>$ git push [remote] --all</code></pre><h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><h5 id="恢复暂存区的指定文件到工作区"><a href="#恢复暂存区的指定文件到工作区" class="headerlink" title="恢复暂存区的指定文件到工作区"></a>恢复暂存区的指定文件到工作区</h5><pre><code>$ git checkout [file]</code></pre><h5 id="恢复某个commit的指定文件到暂存区和工作区"><a href="#恢复某个commit的指定文件到暂存区和工作区" class="headerlink" title="恢复某个commit的指定文件到暂存区和工作区"></a>恢复某个commit的指定文件到暂存区和工作区</h5><pre><code>$ git checkout [commit] [file]</code></pre><h5 id="恢复暂存区的所有文件到工作区"><a href="#恢复暂存区的所有文件到工作区" class="headerlink" title="恢复暂存区的所有文件到工作区"></a>恢复暂存区的所有文件到工作区</h5><pre><code>$ git checkout .</code></pre><h5 id="重置暂存区的指定文件，与上一次commit保持一致，但工作区不变"><a href="#重置暂存区的指定文件，与上一次commit保持一致，但工作区不变" class="headerlink" title="重置暂存区的指定文件，与上一次commit保持一致，但工作区不变"></a>重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</h5><pre><code>$ git reset [file]</code></pre><h5 id="重置暂存区与工作区，与上一次commit保持一致"><a href="#重置暂存区与工作区，与上一次commit保持一致" class="headerlink" title="重置暂存区与工作区，与上一次commit保持一致"></a>重置暂存区与工作区，与上一次commit保持一致</h5><pre><code>$ git reset --hard</code></pre><h5 id="重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变"><a href="#重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变" class="headerlink" title="重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变"></a>重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</h5><pre><code>$ git reset [commit]</code></pre><h5 id="重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致"><a href="#重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致" class="headerlink" title="重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致"></a>重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</h5><pre><code>$ git reset --hard [commit]</code></pre><h5 id="重置当前HEAD为指定commit，但保持暂存区和工作区不变"><a href="#重置当前HEAD为指定commit，但保持暂存区和工作区不变" class="headerlink" title="重置当前HEAD为指定commit，但保持暂存区和工作区不变"></a>重置当前HEAD为指定commit，但保持暂存区和工作区不变</h5><pre><code>$ git reset --keep [commit]</code></pre><h5 id="新建一个commit，用来撤销指定commit"><a href="#新建一个commit，用来撤销指定commit" class="headerlink" title="新建一个commit，用来撤销指定commit"></a>新建一个commit，用来撤销指定commit</h5><h5 id="后者的所有变化都将被前者抵消，并且应用到当前分支"><a href="#后者的所有变化都将被前者抵消，并且应用到当前分支" class="headerlink" title="后者的所有变化都将被前者抵消，并且应用到当前分支"></a>后者的所有变化都将被前者抵消，并且应用到当前分支</h5><pre><code>$ git revert [commit]</code></pre><h5 id="暂时将未提交的变化移除，稍后再移入"><a href="#暂时将未提交的变化移除，稍后再移入" class="headerlink" title="暂时将未提交的变化移除，稍后再移入"></a>暂时将未提交的变化移除，稍后再移入</h5><pre><code>$ git stash$ git stash pop</code></pre><h5 id="放弃本地修改强制更新-git-fetch-只是下载远程的库的内容，不做任何的合并-git-reset-把HEAD指向刚刚下载的最新的版本"><a href="#放弃本地修改强制更新-git-fetch-只是下载远程的库的内容，不做任何的合并-git-reset-把HEAD指向刚刚下载的最新的版本" class="headerlink" title="放弃本地修改强制更新(git fetch 只是下载远程的库的内容，不做任何的合并 git reset 把HEAD指向刚刚下载的最新的版本)"></a>放弃本地修改强制更新(git fetch 只是下载远程的库的内容，不做任何的合并 git reset 把HEAD指向刚刚下载的最新的版本)</h5><pre><code>$ git fetch --all$ git reset --hard origin/master </code></pre><h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><h5 id="生成一个可供发布的压缩包"><a href="#生成一个可供发布的压缩包" class="headerlink" title="生成一个可供发布的压缩包"></a>生成一个可供发布的压缩包</h5><pre><code>$ git archive</code></pre>]]></content>
    
    <summary type="html">
    
      我每天使用 Git ，但是很多命令记不住，一般来说，日常使用只要记住下图6个命令，就可以了。
    
    </summary>
    
      <category term="Git命令" scheme="http://xym-loveit.github.io/categories/Git%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Git命令" scheme="http://xym-loveit.github.io/tags/Git%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Git" scheme="http://xym-loveit.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git 常用命令整理</title>
    <link href="http://xym-loveit.github.io/2017/05/03/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://xym-loveit.github.io/2017/05/03/Git-常用命令/</id>
    <published>2017-05-02T16:39:39.000Z</published>
    <updated>2018-03-29T01:27:48.619Z</updated>
    
    <content type="html"><![CDATA[<p>全局配置用户名称、邮箱<br>git config –global user.name ‘xxx’<br>git config –global user.email ‘xxx’</p><p>git init# 初始化Git仓库<br>git add &lt;hello.txt&gt;  # 把所有要提交的文件修改放到暂存区<br>git commit -m ‘add a file’ # 把暂存区的所有内容提交到当前分支<br>git status #掌握工作区状态<br>git diff #查看文件修改内容<br>git log #查看提交历史<br>git log –pretty=oneline  </p><p>git reset –hard HEAD^ #回退到上一个版本<br>HEAD^^(上上版本),HEAD~100(往上100个版本)<br>commit id(版本号) 可回到指定版本<br>git reflog #查看历史命令<br>工作区（Working Directory）<br>版本库（Repository） #.git<br>    stage(index) 暂存区<br>    master Git自动创建的分支<br>    HEAD 指针<br>git diff HEAD – <file> #查看工作区和版本库里最新版本的区别<br>git checkout – <file> #用版本库的版本替换工作区的版本，无论是工作区的修改还是删除，都可以’一键还原’  </file></file></p><pre><code>#丢弃工作区的修改（让文件回到最近一次的git commit或git add时的状态）  </code></pre><p>git reset HEAD <file> #把暂存区的修改撤销掉，重新放回工作区。<br>git rm <file> #删除文件，若文件已提交到版本库，不用担心误删，但是只能恢复文件到最新版本  </file></file></p><p>ssh-keygen -t rsa -C <a href="mailto:&#39;user@example.com" target="_blank" rel="noopener">&#39;user@example.com</a>‘ #创建SSH Key<br>git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:username/repostery.git #关联本地仓库，远程库的名字为origin  </p><pre><code>#第一次使用Git的clone或者push命令连接GitHub时需确认  </code></pre><p>git push -u origin master   #第一次把当前分支master推送到远程，-u参数不但推送，而且将本地的分支和远程的分支关联起来<br>git push origin master #把当前分支master推送到远程<br>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:username/repostery.git #从远程库克隆一个到本地库  </p><pre><code>#git支持多种协议，包括https，但通过试试支持原生git协议速度最快  </code></pre><p>分支<br>git checkout -b dev #创建并切换分支  </p><pre><code>#相当于git branch dev 和git checkout dev   </code></pre><p>git branch #查看当前分支，当前分支前有个*号<br>git branch <name> #创建分支<br>git checkout <name> #切换分支<br>git merge <name> #合并某个分支到当前分支<br>git branch -d <name> #删除分支<br>git log –graph #查看分支合并图<br>git merge –no-ff -m ‘message’ dev #禁用Fast forward合并dev分支  </name></name></name></name></p><pre><code>#本次合并要创建新的commit，所以要加上-m参数，把commit描述写进去  #Fast forward合并不可查看合并记录  </code></pre><p>git stash #隐藏当前工作现场，等恢复后继续工作<br>git stash list #查看stash记录<br>git stash apply #仅恢复现场，不删除stash内容<br>git stash drop #删除stash内容<br>git stash pop #恢复现场的同时删除stash内容<br>git branch -D <name> #强行删除某个未合并的分支  </name></p><pre><code>#开发新feature最好新建一个分支  </code></pre><p>git remote #查看远程仓库<br>git remote -v #查看远程库详细信息  </p><p>git pull #抓取远程提交<br>git checkout -b branch-name origin/branch-name #在本地创建和远程分支对应的分支<br>git branch –set-upstream branch-name origin/branch-name #建立本地分支和远程分支的关联  </p><p>标签<br>git tag v1.0 #给当前分支最新的commit打标签<br>git tag v0.9 36df530 #给历史提交的commit打标签<br>git tag -a v0.1 -m ‘version 0.1 released’ 3628164 #-a指定标签名，-m指定说明文字<br>git tag -s <tagname> -m ‘blabla’ #可以用PGP签名标签<br>git tag #查看所有标签<br>git show v1.0 #查看标签信息<br>git tag -d v0.1 #删除标签<br>git push origin <tagname> #推送某个标签到远程<br>git push origin –tags #推送所有尚未推送的本地标签  </tagname></tagname></p><p>删除远程标签<br>git tag -d v0.2 #先删除本地标签<br>git push origin :refs/tags/v0.2 #删除远程标签    </p><p>自定义git<br>git config –global color.ui true<br>编写.gitignore文件来忽略某些文件，此文件本身要放到版本库内，并可对其做版本管理<br>git add -f hello.pyc #-f参数强制添加到Git<br>git check-ignore -v hello.pyc　＃检查.gitignore文件的规则<br>简写命令<br>git config –global alias.co checkout #简写checkout命令<br>git config –global alias.st status<br>git config –global alias.ci commit<br>git config –global alias.br branch<br>git config –global alias.unstage ‘reset HEAD’ #撤销暂存区的修改<br>git config –global alias.last ‘log -1’ #查看最近一次的提交<br>git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit”<br>配置文件<br>–global参数时针对当前用户起作用，如果不加，仅针对当前仓库起作用<br>每个仓库的Git配置文件在 .git/config 文件中<br>当前用户的Git配置文件在用户主目录下的 .gitconfig 文件中  </p><p>搭建Git服务器<br>1、安装git sudo apt install git<br>2、创建git用户 sudo adduser git<br>3、创建证书登录，将所有需要登录的用户的公钥导入到/home/git/.ssh/authorized_keys文件，每行一个<br>4、初始化Git仓库<br>    在仓库目录下输入命令 sudo git init –bare sample.git 创建裸仓库（没有工作区）<br>    把owner改为git sudo chown -R git:git sample.git<br>5、禁用shell登录，修改/etc/passwd文件<br>    git:x:1001:1001:,,,:/home/git:/bin/bash<br>    改为：<br>    git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell  </p><p>6、克隆远程仓库<br>git clone git@server:/srv/sample.git  </p><p>附：<br><a href="http://op7wplti1.bkt.clouddn.com/atlassian_git_cheatsheet.pdf" target="_blank" rel="noopener">Git备忘录1</a><br><a href="http://op7wplti1.bkt.clouddn.com/github-git-cheat-sheet.pdf" target="_blank" rel="noopener">Git备忘录2</a></p>]]></content>
    
    <summary type="html">
    
      git常用命令收集,附在线pdf版
    
    </summary>
    
      <category term="Git命令" scheme="http://xym-loveit.github.io/categories/Git%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="Git命令" scheme="http://xym-loveit.github.io/tags/Git%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Git" scheme="http://xym-loveit.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程：Callable、Future和FutureTask</title>
    <link href="http://xym-loveit.github.io/2017/05/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9ACallable%E3%80%81Future%E5%92%8CFutureTask/"/>
    <id>http://xym-loveit.github.io/2017/05/01/Java并发编程：Callable、Future和FutureTask/</id>
    <published>2017-05-01T14:49:34.000Z</published>
    <updated>2018-03-29T01:27:48.621Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>在前面的文章中我们讲述了创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。</p><p>　　这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。</p><p>　　如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。</p><p>　　而自从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。</p><p>　　今天我们就来讨论一下Callable、Future和FutureTask三个类的使用方法。以下是本文的目录大纲：</p><p>　　一.Callable与Runnable</p><p>　　二.Future</p><p>　　三.FutureTask</p><p>　　四.使用示例</p><p>　　若有不正之处请多多谅解，并欢迎批评指正。</p><p>　　请尊重作者劳动成果，转载请标明原文链接：</p><p>　　<a href="http://www.cnblogs.com/dolphin0520/p/3949310.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3949310.html</a></p><p>　　</p><h2 id="一-Callable与Runnable"><a href="#一-Callable与Runnable" class="headerlink" title="一.Callable与Runnable"></a>一.Callable与Runnable</h2><p>　　先说一下java.lang.Runnable吧，它是一个接口，在它里面只声明了一个run()方法：  </p><pre><code>public interface Runnable {    public abstract void run();}  </code></pre><p> 　　由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。</p><p>　　Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()：  </p><pre><code>public interface Callable&lt;V&gt; {    /**     * Computes a result, or throws an exception if unable to do so.     *     * @return computed result     * @throws Exception if unable to compute a result     */    V call() throws Exception;}  </code></pre><p> 　　可以看到，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。</p><p>　　那么怎么使用Callable呢？一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本：  </p><pre><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);Future&lt;?&gt; submit(Runnable task);  </code></pre><p>　　第一个submit方法里面的参数类型就是Callable。</p><p>　　暂时只需要知道Callable一般是和ExecutorService配合来使用的，具体的使用方法讲在后面讲述。</p><p>　　一般情况下我们使用第一个submit方法和第三个submit方法，第二个submit方法很少使用。</p><h2 id="二-Future"><a href="#二-Future" class="headerlink" title="二.Future"></a>二.Future</h2><p>　　Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p><p>　　Future类位于java.util.concurrent包下，它是一个接口：  </p><pre><code>public interface Future&lt;V&gt; {    boolean cancel(boolean mayInterruptIfRunning);    boolean isCancelled();    boolean isDone();    V get() throws InterruptedException, ExecutionException;    V get(long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException;}  </code></pre><p> 　　在Future接口中声明了5个方法，下面依次解释每个方法的作用：</p><ul><li>cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</li><li>isCancelled方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li><li>isDone方法表示任务是否已经完成，若任务完成，则返回true；</li><li>get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li><li>get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。<br>　　也就是说Future提供了三种功能：</li></ul><p>　　1）判断任务是否完成；</p><p>　　2）能够中断任务；</p><p>　　3）能够获取任务执行结果。</p><p>　　因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。</p><h2 id="三-FutureTask"><a href="#三-FutureTask" class="headerlink" title="三.FutureTask"></a>三.FutureTask</h2><p>　　我们先来看一下FutureTask的实现：  </p><pre><code>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</code></pre><p> 　　FutureTask类实现了RunnableFuture接口，我们看一下RunnableFuture接口的实现：  </p><pre><code>public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {    void run();}  </code></pre><p> 　　可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p><p>　　FutureTask提供了2个构造器：  </p><pre><code>public FutureTask(Callable&lt;V&gt; callable) {}public FutureTask(Runnable runnable, V result) {}  </code></pre><p>　　事实上，FutureTask是Future接口的一个唯一实现类。</p><h2 id="四-使用示例"><a href="#四-使用示例" class="headerlink" title="四.使用示例"></a>四.使用示例</h2><p>　　1.使用Callable+Future获取执行结果  </p><pre><code>public class Test {    public static void main(String[] args) {        ExecutorService executor = Executors.newCachedThreadPool();        Task task = new Task();        Future&lt;Integer&gt; result = executor.submit(task);        executor.shutdown();        try {            Thread.sleep(1000);        } catch (InterruptedException e1) {            e1.printStackTrace();        }        System.out.println(&quot;主线程在执行任务&quot;);        try {            System.out.println(&quot;task运行结果&quot;+result.get());        } catch (InterruptedException e) {            e.printStackTrace();        } catch (ExecutionException e) {            e.printStackTrace();        }        System.out.println(&quot;所有任务执行完毕&quot;);    }}class Task implements Callable&lt;Integer&gt;{    @Override    public Integer call() throws Exception {        System.out.println(&quot;子线程在进行计算&quot;);        Thread.sleep(3000);        int sum = 0;        for(int i=0;i&lt;100;i++)            sum += i;        return sum;    }}  </code></pre><p> 　　执行结果：</p><pre><code>子线程在进行计算主线程在执行任务task运行结果4950所有任务执行完毕  </code></pre><p>　　2.使用Callable+FutureTask获取执行结果  </p><pre><code>public class Test {    public static void main(String[] args) {        //第一种方式        ExecutorService executor = Executors.newCachedThreadPool();        Task task = new Task();        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);        executor.submit(futureTask);        executor.shutdown();        //第二种方式，注意这种方式和第一种方式效果是类似的，只不过一个使用的是ExecutorService，一个使用的是Thread        /*Task task = new Task();        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);        Thread thread = new Thread(futureTask);        thread.start();*/        try {            Thread.sleep(1000);        } catch (InterruptedException e1) {            e1.printStackTrace();        }        System.out.println(&quot;主线程在执行任务&quot;);        try {            System.out.println(&quot;task运行结果&quot;+futureTask.get());        } catch (InterruptedException e) {            e.printStackTrace();        } catch (ExecutionException e) {            e.printStackTrace();        }        System.out.println(&quot;所有任务执行完毕&quot;);    }}class Task implements Callable&lt;Integer&gt;{    @Override    public Integer call() throws Exception {        System.out.println(&quot;子线程在进行计算&quot;);        Thread.sleep(3000);        int sum = 0;        for(int i=0;i&lt;100;i++)            sum += i;        return sum;    }}  </code></pre><p> 　　如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明 Future&lt;?&gt; 形式类型、并返回 null 作为底层任务的结果。</p>]]></content>
    
    <summary type="html">
    
      在前面的文章中我们讲述了创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口 这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果,而自从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果
    
    </summary>
    
      <category term="Java并发编程系列" scheme="http://xym-loveit.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="java多线程" scheme="http://xym-loveit.github.io/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Callable" scheme="http://xym-loveit.github.io/tags/Callable/"/>
    
      <category term="Future" scheme="http://xym-loveit.github.io/tags/Future/"/>
    
      <category term="FutureTask" scheme="http://xym-loveit.github.io/tags/FutureTask/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程：CountDownLatch、CyclicBarrier和Semaphore</title>
    <link href="http://xym-loveit.github.io/2017/05/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9ACountDownLatch%E3%80%81CyclicBarrier%E5%92%8CSemaphore/"/>
    <id>http://xym-loveit.github.io/2017/05/01/Java并发编程：CountDownLatch、CyclicBarrier和Semaphore/</id>
    <published>2017-05-01T14:12:32.000Z</published>
    <updated>2018-03-29T01:27:48.623Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>在java1.5中，提供了一些非常有用的辅助类来帮助我们进行并发编程，比如CountDownLatch，CyclicBarrier和Semaphore，今天我们就来学习一下这三个辅助类的用法。</p><p>　　以下是本文目录大纲：</p><p>　　一.CountDownLatch用法</p><p>　　二.CyclicBarrier用法</p><p>　　三.Semaphore用法</p><p>　　若有不正之处请多多谅解，并欢迎批评指正。</p><p>　　请尊重作者劳动成果，转载请标明原文链接：</p><p>　　<a href="http://www.cnblogs.com/dolphin0520/p/3920397.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3920397.html</a></p><p>　　</p><h2 id="一-CountDownLatch用法"><a href="#一-CountDownLatch用法" class="headerlink" title="一.CountDownLatch用法"></a>一.CountDownLatch用法</h2><p>　　CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。</p><p>　　CountDownLatch类只提供了一个构造器：</p><pre><code>public CountDownLatch(int count) {  };  //参数count为计数值   　然后下面这3个方法是CountDownLatch类中最重要的方法：public void await() throws InterruptedException { };   //调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行public boolean await(long timeout, TimeUnit unit) throws InterruptedException { };  //和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行public void countDown() { };  //将count值减1  </code></pre><p> 　　下面看一个例子大家就清楚CountDownLatch的用法了：  </p><pre><code>public class Test {     public static void main(String[] args) {            final CountDownLatch latch = new CountDownLatch(2);         new Thread(){             public void run() {                 try {                     System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;);                    Thread.sleep(3000);                    System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;);                    latch.countDown();                } catch (InterruptedException e) {                    e.printStackTrace();                }             };         }.start();         new Thread(){             public void run() {                 try {                     System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;正在执行&quot;);                     Thread.sleep(3000);                     System.out.println(&quot;子线程&quot;+Thread.currentThread().getName()+&quot;执行完毕&quot;);                     latch.countDown();                } catch (InterruptedException e) {                    e.printStackTrace();                }             };         }.start();         try {             System.out.println(&quot;等待2个子线程执行完毕...&quot;);            latch.await();            System.out.println(&quot;2个子线程已经执行完毕&quot;);            System.out.println(&quot;继续执行主线程&quot;);        } catch (InterruptedException e) {            e.printStackTrace();        }     }}  </code></pre><p> 　　执行结果：</p><pre><code>线程Thread-0正在执行线程Thread-1正在执行等待2个子线程执行完毕...线程Thread-0执行完毕线程Thread-1执行完毕2个子线程已经执行完毕继续执行主线程</code></pre><h2 id="二-CyclicBarrier用法"><a href="#二-CyclicBarrier用法" class="headerlink" title="二.CyclicBarrier用法"></a>二.CyclicBarrier用法</h2><p>　　字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。</p><p>　　CyclicBarrier类位于java.util.concurrent包下，CyclicBarrier提供2个构造器：  </p><pre><code>public CyclicBarrier(int parties, Runnable barrierAction) {}public CyclicBarrier(int parties) {}  </code></pre><p>　　参数parties指让多少个线程或者任务等待至barrier状态；参数barrierAction为当这些线程都达到barrier状态时会执行的内容。</p><p>　　然后CyclicBarrier中最重要的方法就是await方法，它有2个重载版本：  </p><pre><code>public int await() throws InterruptedException, BrokenBarrierException { };public int await(long timeout, TimeUnit unit)throws InterruptedException,BrokenBarrierException,TimeoutException { };  </code></pre><p> 　　第一个版本比较常用，用来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务；</p><p>　　第二个版本是让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。</p><p>　　下面举几个例子就明白了：</p><p>　　假若有若干个线程都要进行写数据操作，并且只有所有线程都完成写数据操作之后，这些线程才能继续做后面的事情，此时就可以利用CyclicBarrier了：  </p><pre><code>public class Test {    public static void main(String[] args) {        int N = 4;        CyclicBarrier barrier  = new CyclicBarrier(N);        for(int i=0;i&lt;N;i++)            new Writer(barrier).start();    }    static class Writer extends Thread{        private CyclicBarrier cyclicBarrier;        public Writer(CyclicBarrier cyclicBarrier) {            this.cyclicBarrier = cyclicBarrier;        }        @Override        public void run() {            System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;正在写入数据...&quot;);            try {                Thread.sleep(5000);      //以睡眠来模拟写入数据操作                System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;写入数据完毕，等待其他线程写入完毕&quot;);                cyclicBarrier.await();            } catch (InterruptedException e) {                e.printStackTrace();            }catch(BrokenBarrierException e){                e.printStackTrace();            }            System.out.println(&quot;所有线程写入完毕，继续处理其他任务...&quot;);        }    }}  </code></pre><p> 　　执行结果：  </p><pre><code>线程Thread-0正在写入数据...线程Thread-3正在写入数据...线程Thread-2正在写入数据...线程Thread-1正在写入数据...线程Thread-2写入数据完毕，等待其他线程写入完毕线程Thread-0写入数据完毕，等待其他线程写入完毕线程Thread-3写入数据完毕，等待其他线程写入完毕线程Thread-1写入数据完毕，等待其他线程写入完毕所有线程写入完毕，继续处理其他任务...所有线程写入完毕，继续处理其他任务...所有线程写入完毕，继续处理其他任务...所有线程写入完毕，继续处理其他任务...  </code></pre><p>　　从上面输出结果可以看出，每个写入线程执行完写数据操作之后，就在等待其他线程写入操作完毕。</p><p>　　当所有线程线程写入操作完毕之后，所有线程就继续进行后续的操作了。</p><p>　　如果说想在所有线程写入操作完之后，进行额外的其他操作可以为CyclicBarrier提供Runnable参数：  </p><pre><code>public class Test {    public static void main(String[] args) {        int N = 4;        CyclicBarrier barrier  = new CyclicBarrier(N,new Runnable() {            @Override            public void run() {                System.out.println(&quot;当前线程&quot;+Thread.currentThread().getName());               }        });        for(int i=0;i&lt;N;i++)            new Writer(barrier).start();    }    static class Writer extends Thread{        private CyclicBarrier cyclicBarrier;        public Writer(CyclicBarrier cyclicBarrier) {            this.cyclicBarrier = cyclicBarrier;        }        @Override        public void run() {            System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;正在写入数据...&quot;);            try {                Thread.sleep(5000);      //以睡眠来模拟写入数据操作                System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;写入数据完毕，等待其他线程写入完毕&quot;);                cyclicBarrier.await();            } catch (InterruptedException e) {                e.printStackTrace();            }catch(BrokenBarrierException e){                e.printStackTrace();            }            System.out.println(&quot;所有线程写入完毕，继续处理其他任务...&quot;);        }    }}  </code></pre><p> 　　运行结果：  </p><pre><code>线程Thread-0正在写入数据...线程Thread-1正在写入数据...线程Thread-2正在写入数据...线程Thread-3正在写入数据...线程Thread-0写入数据完毕，等待其他线程写入完毕线程Thread-1写入数据完毕，等待其他线程写入完毕线程Thread-2写入数据完毕，等待其他线程写入完毕线程Thread-3写入数据完毕，等待其他线程写入完毕当前线程Thread-3所有线程写入完毕，继续处理其他任务...所有线程写入完毕，继续处理其他任务...所有线程写入完毕，继续处理其他任务...所有线程写入完毕，继续处理其他任务...  </code></pre><p>　　从结果可以看出，当四个线程都到达barrier状态后，会从四个线程中选择一个线程去执行Runnable。</p><p> 　　下面看一下为await指定时间的效果：  </p><pre><code>public class Test {    public static void main(String[] args) {        int N = 4;        CyclicBarrier barrier  = new CyclicBarrier(N);        for(int i=0;i&lt;N;i++) {            if(i&lt;N-1)                new Writer(barrier).start();            else {                try {                    Thread.sleep(5000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                new Writer(barrier).start();            }        }    }    static class Writer extends Thread{        private CyclicBarrier cyclicBarrier;        public Writer(CyclicBarrier cyclicBarrier) {            this.cyclicBarrier = cyclicBarrier;        }        @Override        public void run() {            System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;正在写入数据...&quot;);            try {                Thread.sleep(5000);      //以睡眠来模拟写入数据操作                System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;写入数据完毕，等待其他线程写入完毕&quot;);                try {                    cyclicBarrier.await(2000, TimeUnit.MILLISECONDS);                } catch (TimeoutException e) {                    // TODO Auto-generated catch block                    e.printStackTrace();                }            } catch (InterruptedException e) {                e.printStackTrace();            }catch(BrokenBarrierException e){                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName()+&quot;所有线程写入完毕，继续处理其他任务...&quot;);        }    }}  </code></pre><p> 　　执行结果：  </p><pre><code>线程Thread-0正在写入数据...线程Thread-2正在写入数据...线程Thread-1正在写入数据...线程Thread-2写入数据完毕，等待其他线程写入完毕线程Thread-0写入数据完毕，等待其他线程写入完毕线程Thread-1写入数据完毕，等待其他线程写入完毕线程Thread-3正在写入数据...java.util.concurrent.TimeoutExceptionThread-1所有线程写入完毕，继续处理其他任务...Thread-0所有线程写入完毕，继续处理其他任务...    at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)    at java.util.concurrent.CyclicBarrier.await(Unknown Source)    at com.cxh.test1.Test$Writer.run(Test.java:58)java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)    at java.util.concurrent.CyclicBarrier.await(Unknown Source)    at com.cxh.test1.Test$Writer.run(Test.java:58)java.util.concurrent.BrokenBarrierException    at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)    at java.util.concurrent.CyclicBarrier.await(Unknown Source)    at com.cxh.test1.Test$Writer.run(Test.java:58)Thread-2所有线程写入完毕，继续处理其他任务...java.util.concurrent.BrokenBarrierException线程Thread-3写入数据完毕，等待其他线程写入完毕    at java.util.concurrent.CyclicBarrier.dowait(Unknown Source)    at java.util.concurrent.CyclicBarrier.await(Unknown Source)    at com.cxh.test1.Test$Writer.run(Test.java:58)Thread-3所有线程写入完毕，继续处理其他任务...  </code></pre><p>　　上面的代码在main方法的for循环中，故意让最后一个线程启动延迟，因为在前面三个线程都达到barrier之后，等待了指定的时间发现第四个线程还没有达到barrier，就抛出异常并继续执行后面的任务。</p><p>　　另外CyclicBarrier是可以重用的，看下面这个例子：<br>    public class Test {<br>        public static void main(String[] args) {<br>            int N = 4;<br>            CyclicBarrier barrier  = new CyclicBarrier(N);</p><pre><code>        for(int i=0;i&lt;N;i++) {            new Writer(barrier).start();        }        try {            Thread.sleep(25000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(&quot;CyclicBarrier重用&quot;);        for(int i=0;i&lt;N;i++) {            new Writer(barrier).start();        }    }    static class Writer extends Thread{        private CyclicBarrier cyclicBarrier;        public Writer(CyclicBarrier cyclicBarrier) {            this.cyclicBarrier = cyclicBarrier;        }        @Override        public void run() {            System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;正在写入数据...&quot;);            try {                Thread.sleep(5000);      //以睡眠来模拟写入数据操作                System.out.println(&quot;线程&quot;+Thread.currentThread().getName()+&quot;写入数据完毕，等待其他线程写入完毕&quot;);                cyclicBarrier.await();            } catch (InterruptedException e) {                e.printStackTrace();            }catch(BrokenBarrierException e){                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName()+&quot;所有线程写入完毕，继续处理其他任务...&quot;);        }    }}  </code></pre><p> 　　执行结果：  </p><pre><code>线程Thread-0正在写入数据...线程Thread-1正在写入数据...线程Thread-3正在写入数据...线程Thread-2正在写入数据...线程Thread-1写入数据完毕，等待其他线程写入完毕线程Thread-3写入数据完毕，等待其他线程写入完毕线程Thread-2写入数据完毕，等待其他线程写入完毕线程Thread-0写入数据完毕，等待其他线程写入完毕Thread-0所有线程写入完毕，继续处理其他任务...Thread-3所有线程写入完毕，继续处理其他任务...Thread-1所有线程写入完毕，继续处理其他任务...Thread-2所有线程写入完毕，继续处理其他任务...CyclicBarrier重用线程Thread-4正在写入数据...线程Thread-5正在写入数据...线程Thread-6正在写入数据...线程Thread-7正在写入数据...线程Thread-7写入数据完毕，等待其他线程写入完毕线程Thread-5写入数据完毕，等待其他线程写入完毕线程Thread-6写入数据完毕，等待其他线程写入完毕线程Thread-4写入数据完毕，等待其他线程写入完毕Thread-4所有线程写入完毕，继续处理其他任务...Thread-5所有线程写入完毕，继续处理其他任务...Thread-6所有线程写入完毕，继续处理其他任务...Thread-7所有线程写入完毕，继续处理其他任务...  </code></pre><p>　　从执行结果可以看出，在初次的4个线程越过barrier状态后，又可以用来进行新一轮的使用。而CountDownLatch无法进行重复使用。</p><h2 id="三-Semaphore用法"><a href="#三-Semaphore用法" class="headerlink" title="三.Semaphore用法"></a>三.Semaphore用法</h2><p>　　Semaphore翻译成字面意思为 信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</p><p>　　Semaphore类位于java.util.concurrent包下，它提供了2个构造器：  </p><pre><code>public Semaphore(int permits) {          //参数permits表示许可数目，即同时可以允许多少线程进行访问    sync = new NonfairSync(permits);}public Semaphore(int permits, boolean fair) {    //这个多了一个参数fair表示是否是公平的，即等待时间越久的越先获取许可    sync = (fair)? new FairSync(permits) : new NonfairSync(permits);}  </code></pre><p> 　　下面说一下Semaphore类中比较重要的几个方法，首先是acquire()、release()方法：  </p><pre><code>public void acquire() throws InterruptedException {  }     //获取一个许可public void acquire(int permits) throws InterruptedException { }    //获取permits个许可public void release() { }          //释放一个许可public void release(int permits) { }    //释放permits个许可  </code></pre><p>　　acquire()用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。</p><p>　　release()用来释放许可。注意，在释放许可之前，必须先获获得许可。</p><p>　　这4个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法：  </p><pre><code>public boolean tryAcquire() { };    //尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回falsepublic boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException { };  //尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回falsepublic boolean tryAcquire(int permits) { }; //尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回falsepublic boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException { }; //尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false  </code></pre><p> 　　另外还可以通过availablePermits()方法得到可用的许可数目。</p><p>　　下面通过一个例子来看一下Semaphore的具体使用：</p><p>　　假若一个工厂有5台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过Semaphore来实现：  </p><pre><code>public class Test {    public static void main(String[] args) {        int N = 8;            //工人数        Semaphore semaphore = new Semaphore(5); //机器数目        for(int i=0;i&lt;N;i++)            new Worker(i,semaphore).start();    }    static class Worker extends Thread{        private int num;        private Semaphore semaphore;        public Worker(int num,Semaphore semaphore){            this.num = num;            this.semaphore = semaphore;        }        @Override        public void run() {            try {                semaphore.acquire();                System.out.println(&quot;工人&quot;+this.num+&quot;占用一个机器在生产...&quot;);                Thread.sleep(2000);                System.out.println(&quot;工人&quot;+this.num+&quot;释放出机器&quot;);                semaphore.release();                       } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}  </code></pre><p>  　　执行结果：  </p><pre><code>工人0占用一个机器在生产...工人1占用一个机器在生产...工人2占用一个机器在生产...工人4占用一个机器在生产...工人5占用一个机器在生产...工人0释放出机器工人2释放出机器工人3占用一个机器在生产...工人7占用一个机器在生产...工人4释放出机器工人5释放出机器工人1释放出机器工人6占用一个机器在生产...工人3释放出机器工人7释放出机器工人6释放出机器</code></pre><p>　　</p><p>　　下面对上面说的三个辅助类进行一个总结：</p><p>　　1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：</p><p>　　　　CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；</p><p>　　　　而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</p><p>　　　　另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。</p><p>　　2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。</p><blockquote><p>参考资料：</p><p>《Java编程思想》</p><p><a href="http://www.itzhai.com/the-introduction-and-use-of-a-countdownlatch.html" target="_blank" rel="noopener">http://www.itzhai.com/the-introduction-and-use-of-a-countdownlatch.html</a></p><p><a href="http://leaver.me/archives/3220.html" target="_blank" rel="noopener">http://leaver.me/archives/3220.html</a></p><p><a href="http://developer.51cto.com/art/201403/432095.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201403/432095.htm</a></p><p><a href="http://blog.csdn.net/yanhandle/article/details/9016329" target="_blank" rel="noopener">http://blog.csdn.net/yanhandle/article/details/9016329</a></p><p><a href="http://blog.csdn.net/cutesource/article/details/5780740" target="_blank" rel="noopener">http://blog.csdn.net/cutesource/article/details/5780740</a></p><p><a href="http://www.cnblogs.com/whgw/archive/2011/09/29/2195555.html" target="_blank" rel="noopener">http://www.cnblogs.com/whgw/archive/2011/09/29/2195555.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限
    
    </summary>
    
      <category term="Java并发编程系列" scheme="http://xym-loveit.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="java多线程" scheme="http://xym-loveit.github.io/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="CountDownLatch" scheme="http://xym-loveit.github.io/tags/CountDownLatch/"/>
    
      <category term="CyclicBarrier" scheme="http://xym-loveit.github.io/tags/CyclicBarrier/"/>
    
      <category term="Semaphore" scheme="http://xym-loveit.github.io/tags/Semaphore/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程：线程池的使用</title>
    <link href="http://xym-loveit.github.io/2017/05/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://xym-loveit.github.io/2017/05/01/Java并发编程：线程池的使用/</id>
    <published>2017-05-01T12:59:38.000Z</published>
    <updated>2018-03-29T01:27:48.632Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的文章中，我们使用线程的时候就去创建一个线程，这样实现起来非常简便，但是就会有一个问题：</p><p>　　如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p><p>　　那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p><p>　　在Java中可以通过线程池来达到这样的效果。今天我们就来详细讲解一下Java的线程池，首先我们从最核心的ThreadPoolExecutor类中的方法讲起，然后再讲述它的实现原理，接着给出了它的使用示例，最后讨论了一下如何合理配置线程池的大小。</p><p>　　以下是本文的目录大纲：</p><p>　　一.Java中的ThreadPoolExecutor类</p><p>　　二.深入剖析线程池实现原理</p><p>　　三.使用示例</p><p>　　四.如何合理配置线程池的大小　</p><p>　　若有不正之处请多多谅解，并欢迎批评指正。</p><p>　　请尊重作者劳动成果，转载请标明原文链接：</p><p>　　<a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3932921.html</a></p><p>　</p><h2 id="一-Java中的ThreadPoolExecutor类"><a href="#一-Java中的ThreadPoolExecutor类" class="headerlink" title="一.Java中的ThreadPoolExecutor类"></a>一.Java中的ThreadPoolExecutor类</h2><p>　　<strong>java.uitl.concurrent.ThreadPoolExecutor</strong>类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。下面我们来看一下ThreadPoolExecutor类的具体实现源码。</p><p>　　在ThreadPoolExecutor类中提供了四个构造方法：</p><pre><code>public class ThreadPoolExecutor extends AbstractExecutorService {    .....    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,            BlockingQueue&lt;Runnable&gt; workQueue);    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory);    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler);    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);    ...}</code></pre><p> 　　从上面的代码可以得知，ThreadPoolExecutor继承了AbstractExecutorService类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。</p><p> 　　下面解释下一下构造器中各个参数的含义：</p><p>corePoolSize：核心池的大小，这个参数跟后面讲述的线程池的实现原理有非常大的关系。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，从这2个方法的名字就可以看出，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；<br>maximumPoolSize：线程池最大线程数，这个参数也是一个非常重要的参数，它表示在线程池中最多能创建多少个线程；<br>keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize，即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；<br>unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性：</p><pre><code>TimeUnit.DAYS;               //天TimeUnit.HOURS;             //小时TimeUnit.MINUTES;           //分钟TimeUnit.SECONDS;           //秒TimeUnit.MILLISECONDS;      //毫秒TimeUnit.MICROSECONDS;      //微妙TimeUnit.NANOSECONDS;       //纳秒</code></pre><p>workQueue：一个阻塞队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择： </p><pre><code>ArrayBlockingQueue;LinkedBlockingQueue;SynchronousQueue;  </code></pre><p>　　ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。</p><p>threadFactory：线程工厂，主要用来创建线程；<br>handler：表示当拒绝处理任务时的策略，有以下四种取值：  </p><pre><code>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务  </code></pre><p> 　　具体参数的配置与线程池的关系将在下一节讲述。</p><p>　　从上面给出的ThreadPoolExecutor类的代码可以知道，ThreadPoolExecutor继承了AbstractExecutorService，我们来看一下AbstractExecutorService的实现：</p><pre><code>public abstract class AbstractExecutorService implements ExecutorService {    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) { };    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) { };    public Future&lt;?&gt; submit(Runnable task) {};    public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) { };    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) { };    private &lt;T&gt; T doInvokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                            boolean timed, long nanos)        throws InterruptedException, ExecutionException, TimeoutException {    };    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException, ExecutionException {    };    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                           long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException {    };    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException {    };    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                                         long timeout, TimeUnit unit)        throws InterruptedException {    };}  </code></pre><p> 　　AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。</p><p>　　我们接着看ExecutorService接口的实现：</p><pre><code>public interface ExecutorService extends Executor {    void shutdown();    boolean isShutdown();    boolean isTerminated();    boolean awaitTermination(long timeout, TimeUnit unit)        throws InterruptedException;    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);    Future&lt;?&gt; submit(Runnable task);    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException;    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                                  long timeout, TimeUnit unit)        throws InterruptedException;    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException, ExecutionException;    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                    long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException;}        </code></pre><p> 　　而ExecutorService又是继承了Executor接口，我们看一下Executor接口的实现： </p><pre><code>public interface Executor {    void execute(Runnable command);}  </code></pre><p> 　　到这里，大家应该明白了ThreadPoolExecutor、AbstractExecutorService、ExecutorService和Executor几个之间的关系了。</p><p>　　Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的；</p><p>　　然后ExecutorService接口继承了Executor接口，并声明了一些方法：submit、invokeAll、invokeAny以及shutDown等；</p><p>　　抽象类AbstractExecutorService实现了ExecutorService接口，基本实现了ExecutorService中声明的所有方法；</p><p>　　然后ThreadPoolExecutor继承了类AbstractExecutorService。</p><p>　　在ThreadPoolExecutor类中有几个非常重要的方法：</p><pre><code>execute()submit()shutdown()shutdownNow()</code></pre><p> 　　execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</p><p>　　submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和execute()方法不同，它能够返回任务执行的结果，去看submit()方法的实现，会发现它实际上还是调用的execute()方法，只不过它利用了Future来获取任务执行结果（Future相关内容将在下一篇讲述）。</p><p>　　shutdown()和shutdownNow()是用来关闭线程池的。</p><p>　　还有很多其他的方法：</p><p>　　比如：getQueue() 、getPoolSize() 、getActiveCount()、getCompletedTaskCount()等获取与线程池相关属性的方法，有兴趣的朋友可以自行查阅API。</p><h2 id="二-深入剖析线程池实现原理"><a href="#二-深入剖析线程池实现原理" class="headerlink" title="二.深入剖析线程池实现原理"></a>二.深入剖析线程池实现原理</h2><p>　　在上一节我们从宏观上介绍了ThreadPoolExecutor，下面我们来深入解析一下线程池的具体实现原理，将从下面几个方面讲解：</p><p>　　1.线程池状态</p><p>　　2.任务的执行</p><p>　　3.线程池中的线程初始化</p><p>　　4.任务缓存队列及排队策略</p><p>　　5.任务拒绝策略</p><p>　　6.线程池的关闭</p><p>　　7.线程池容量的动态调整</p><p>1.线程池状态</p><p>　　在ThreadPoolExecutor中定义了一个volatile变量，另外定义了几个static final变量表示线程池的各个状态：</p><pre><code>volatile int runState;static final int RUNNING    = 0;static final int SHUTDOWN   = 1;static final int STOP       = 2;static final int TERMINATED = 3;  </code></pre><p> 　　runState表示当前线程池的状态，它是一个volatile变量用来保证线程之间的可见性；</p><p>　　下面的几个static final变量表示runState可能的几个取值。</p><p>　　当创建线程池后，初始时，线程池处于RUNNING状态；</p><p>　　如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；</p><p>　　如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；</p><p>　　当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。</p><p>2.任务的执行</p><p>　　在了解将任务提交给线程池到任务执行完毕整个过程之前，我们先来看一下ThreadPoolExecutor类中其他的一些比较重要成员变量：</p><pre><code>private final BlockingQueue&lt;Runnable&gt; workQueue;              //任务缓存队列，用来存放等待执行的任务private final ReentrantLock mainLock = new ReentrantLock();   //线程池的主要状态锁，对线程池状态（比如线程池大小                                                              //、runState等）的改变都要使用这个锁private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();  //用来存放工作集private volatile long  keepAliveTime;    //线程存货时间    private volatile boolean allowCoreThreadTimeOut;   //是否允许为核心线程设置存活时间private volatile int   corePoolSize;     //核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）private volatile int   maximumPoolSize;   //线程池最大能容忍的线程数private volatile int   poolSize;       //线程池中当前的线程数private volatile RejectedExecutionHandler handler; //任务拒绝策略private volatile ThreadFactory threadFactory;   //线程工厂，用来创建线程private int largestPoolSize;   //用来记录线程池中曾经出现过的最大线程数private long completedTaskCount;   //用来记录已经执行完毕的任务个数  </code></pre><p> 　　每个变量的作用都已经标明出来了，这里要重点解释一下corePoolSize、maximumPoolSize、largestPoolSize三个变量。</p><p>　　corePoolSize在很多地方被翻译成核心池大小，其实我的理解这个就是线程池的大小。举个简单的例子：</p><p>　　假如有一个工厂，工厂里面有10个工人，每个工人同时只能做一件任务。</p><p>　　因此只要当10个工人中有工人是空闲的，来了任务就分配给空闲的工人做；</p><p>　　当10个工人都有任务在做时，如果还来了任务，就把任务进行排队等待；</p><p>　　如果说新任务数目增长的速度远远大于工人做任务的速度，那么此时工厂主管可能会想补救措施，比如重新招4个临时工人进来；</p><p>　　然后就将任务也分配给这4个临时工人做；</p><p>　　如果说着14个工人做任务的速度还是不够，此时工厂主管可能就要考虑不再接收新的任务或者抛弃前面的一些任务了。</p><p>　　当这14个工人当中有人空闲时，而新任务增长的速度又比较缓慢，工厂主管可能就考虑辞掉4个临时工了，只保持原来的10个工人，毕竟请额外的工人是要花钱的。</p><p>　　这个例子中的corePoolSize就是10，而maximumPoolSize就是14（10+4）。</p><p>　　也就是说corePoolSize就是线程池大小，maximumPoolSize在我看来是线程池的一种补救措施，即任务量突然过大时的一种补救措施。</p><p>　　不过为了方便理解，在本文后面还是将corePoolSize翻译成核心池大小。</p><p>　　largestPoolSize只是一个用来起记录作用的变量，用来记录线程池中曾经有过的最大线程数目，跟线程池的容量没有任何关系。</p><p>　　下面我们进入正题，看一下任务从提交到最终执行完毕经历了哪些过程。</p><p>　　在ThreadPoolExecutor类中，最核心的任务提交方法是execute()方法，虽然通过submit也可以提交任务，但是实际上submit方法里面最终调用的还是execute()方法，所以我们只需要研究execute()方法的实现原理即可：</p><pre><code>public void execute(Runnable command) {    if (command == null)        throw new NullPointerException();    if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) {        if (runState == RUNNING &amp;&amp; workQueue.offer(command)) {            if (runState != RUNNING || poolSize == 0)                ensureQueuedTaskHandled(command);        }        else if (!addIfUnderMaximumPoolSize(command))            reject(command); // is shutdown or saturated    }}  </code></pre><p> 　　上面的代码可能看起来不是那么容易理解，下面我们一句一句解释：</p><p>　　首先，判断提交的任务command是否为null，若是null，则抛出空指针异常；</p><p>　　接着是这句，这句要好好理解一下：</p><pre><code>if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command))</code></pre><p> 　　由于是或条件运算符，所以先计算前半部分的值，如果线程池中当前线程数不小于核心池大小，那么就会直接进入下面的if语句块了。</p><p>　　如果线程池中当前线程数小于核心池大小，则接着执行后半部分，也就是执行</p><pre><code>addIfUnderCorePoolSize(command)</code></pre><p>　　如果执行完addIfUnderCorePoolSize这个方法返回false，则继续执行下面的if语句块，否则整个方法就直接执行完毕了。</p><p>　　如果执行完addIfUnderCorePoolSize这个方法返回false，然后接着判断：</p><pre><code>if (runState == RUNNING &amp;&amp; workQueue.offer(command))</code></pre><p> 　　如果当前线程池处于RUNNING状态，则将任务放入任务缓存队列；如果当前线程池不处于RUNNING状态或者任务放入缓存队列失败，则执行：</p><pre><code>addIfUnderMaximumPoolSize(command)  </code></pre><p>　　如果执行addIfUnderMaximumPoolSize方法失败，则执行reject()方法进行任务拒绝处理。</p><p>　　回到前面：</p><pre><code>if (runState == RUNNING &amp;&amp; workQueue.offer(command))  </code></pre><p> 　　这句的执行，如果说当前线程池处于RUNNING状态且将任务放入任务缓存队列成功，则继续进行判断：</p><pre><code>if (runState != RUNNING || poolSize == 0)  </code></pre><p> 　　这句判断是为了防止在将此任务添加进任务缓存队列的同时其他线程突然调用shutdown或者shutdownNow方法关闭了线程池的一种应急措施。如果是这样就执行：</p><pre><code>ensureQueuedTaskHandled(command)  </code></pre><p> 　　进行应急处理，从名字可以看出是保证 添加到任务缓存队列中的任务得到处理。</p><p>　　我们接着看2个关键方法的实现：addIfUnderCorePoolSize和addIfUnderMaximumPoolSize：</p><pre><code>private boolean addIfUnderCorePoolSize(Runnable firstTask) {    Thread t = null;    final ReentrantLock mainLock = this.mainLock;    mainLock.lock();    try {        if (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING)            t = addThread(firstTask);        //创建线程去执行firstTask任务            } finally {        mainLock.unlock();    }    if (t == null)        return false;    t.start();    return true;}</code></pre><p> 　　这个是addIfUnderCorePoolSize方法的具体实现，从名字可以看出它的意图就是当低于核心吃大小时执行的方法。下面看其具体实现，首先获取到锁，因为这地方涉及到线程池状态的变化，先通过if语句判断当前线程池中的线程数目是否小于核心池大小，有朋友也许会有疑问：前面在execute()方法中不是已经判断过了吗，只有线程池当前线程数目小于核心池大小才会执行addIfUnderCorePoolSize方法的，为何这地方还要继续判断？原因很简单，前面的判断过程中并没有加锁，因此可能在execute方法判断的时候poolSize小于corePoolSize，而判断完之后，在其他线程中又向线程池提交了任务，就可能导致poolSize不小于corePoolSize了，所以需要在这个地方继续判断。然后接着判断线程池的状态是否为RUNNING，原因也很简单，因为有可能在其他线程中调用了shutdown或者shutdownNow方法。然后就是执行</p><pre><code>t = addThread(firstTask);</code></pre><p> 　　这个方法也非常关键，传进去的参数为提交的任务，返回值为Thread类型。然后接着在下面判断t是否为空，为空则表明创建线程失败（即poolSize&gt;=corePoolSize或者runState不等于RUNNING），否则调用t.start()方法启动线程。</p><p>　　我们来看一下addThread方法的实现：</p><pre><code>private Thread addThread(Runnable firstTask) {    Worker w = new Worker(firstTask);    Thread t = threadFactory.newThread(w);  //创建一个线程，执行任务        if (t != null) {        w.thread = t;            //将创建的线程的引用赋值为w的成员变量                workers.add(w);        int nt = ++poolSize;     //当前线程数加1                if (nt &gt; largestPoolSize)            largestPoolSize = nt;    }    return t;}</code></pre><p> 　　在addThread方法中，首先用提交的任务创建了一个Worker对象，然后调用线程工厂threadFactory创建了一个新的线程t，然后将线程t的引用赋值给了Worker对象的成员变量thread，接着通过workers.add(w)将Worker对象添加到工作集当中。</p><p>　　下面我们看一下Worker类的实现：</p><pre><code>private final class Worker implements Runnable {    private final ReentrantLock runLock = new ReentrantLock();    private Runnable firstTask;    volatile long completedTasks;    Thread thread;    Worker(Runnable firstTask) {        this.firstTask = firstTask;    }    boolean isActive() {        return runLock.isLocked();    }    void interruptIfIdle() {        final ReentrantLock runLock = this.runLock;        if (runLock.tryLock()) {            try {        if (thread != Thread.currentThread())        thread.interrupt();            } finally {                runLock.unlock();            }        }    }    void interruptNow() {        thread.interrupt();    }    private void runTask(Runnable task) {        final ReentrantLock runLock = this.runLock;        runLock.lock();        try {            if (runState &lt; STOP &amp;&amp;                Thread.interrupted() &amp;&amp;                runState &gt;= STOP)            boolean ran = false;            beforeExecute(thread, task);   //beforeExecute方法是ThreadPoolExecutor类的一个方法，没有具体实现，用户可以根据            //自己需要重载这个方法和后面的afterExecute方法来进行一些统计信息，比如某个任务的执行时间等                        try {                task.run();                ran = true;                afterExecute(task, null);                ++completedTasks;            } catch (RuntimeException ex) {                if (!ran)                    afterExecute(task, ex);                throw ex;            }        } finally {            runLock.unlock();        }    }    public void run() {        try {            Runnable task = firstTask;            firstTask = null;            while (task != null || (task = getTask()) != null) {                runTask(task);                task = null;            }        } finally {            workerDone(this);   //当任务队列中没有任务时，进行清理工作                }    }}  </code></pre><p> 　　它实际上实现了Runnable接口，因此上面的Thread t = threadFactory.newThread(w);效果跟下面这句的效果基本一样：</p><pre><code>Thread t = new Thread(w);  </code></pre><p> 　　相当于传进去了一个Runnable任务，在线程t中执行这个Runnable。</p><p>　　既然Worker实现了Runnable接口，那么自然最核心的方法便是run()方法了：</p><pre><code>public void run() {    try {        Runnable task = firstTask;        firstTask = null;        while (task != null || (task = getTask()) != null) {            runTask(task);            task = null;        }    } finally {        workerDone(this);    }}</code></pre><p> 　　从run方法的实现可以看出，它首先执行的是通过构造器传进来的任务firstTask，在调用runTask()执行完firstTask之后，在while循环里面不断通过getTask()去取新的任务来执行，那么去哪里取呢？自然是从任务缓存队列里面去取，getTask是ThreadPoolExecutor类中的方法，并不是Worker类中的方法，下面是getTask方法的实现：</p><pre><code>Runnable getTask() {    for (;;) {        try {            int state = runState;            if (state &gt; SHUTDOWN)                return null;            Runnable r;            if (state == SHUTDOWN)  // Help drain queue                r = workQueue.poll();            else if (poolSize &gt; corePoolSize || allowCoreThreadTimeOut) //如果线程数大于核心池大小或者允许为核心池线程设置空闲时间，                //则通过poll取任务，若等待一定的时间取不到任务，则返回null                r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);            else                r = workQueue.take();            if (r != null)                return r;            if (workerCanExit()) {    //如果没取到任务，即r为null，则判断当前的worker是否可以退出                if (runState &gt;= SHUTDOWN) // Wake up others                    interruptIdleWorkers();   //中断处于空闲状态的worker                return null;            }            // Else retry        } catch (InterruptedException ie) {            // On interruption, re-check runState        }    }}</code></pre><p> 　　在getTask中，先判断当前线程池状态，如果runState大于SHUTDOWN（即为STOP或者TERMINATED），则直接返回null。</p><p>　　如果runState为SHUTDOWN或者RUNNING，则从任务缓存队列取任务。</p><p>　　如果当前线程池的线程数大于核心池大小corePoolSize或者允许为核心池中的线程设置空闲存活时间，则调用poll(time,timeUnit)来取任务，这个方法会等待一定的时间，如果取不到任务就返回null。</p><p>　　然后判断取到的任务r是否为null，为null则通过调用workerCanExit()方法来判断当前worker是否可以退出，我们看一下workerCanExit()的实现：</p><pre><code>private boolean workerCanExit() {    final ReentrantLock mainLock = this.mainLock;    mainLock.lock();    boolean canExit;    //如果runState大于等于STOP，或者任务缓存队列为空了    //或者  允许为核心池线程设置空闲存活时间并且线程池中的线程数目大于1    try {        canExit = runState &gt;= STOP ||            workQueue.isEmpty() ||            (allowCoreThreadTimeOut &amp;&amp;             poolSize &gt; Math.max(1, corePoolSize));    } finally {        mainLock.unlock();    }    return canExit;}</code></pre><p> 　　也就是说如果线程池处于STOP状态、或者任务队列已为空或者允许为核心池线程设置空闲存活时间并且线程数大于1时，允许worker退出。如果允许worker退出，则调用interruptIdleWorkers()中断处于空闲状态的worker，我们看一下interruptIdleWorkers()的实现：</p><pre><code>void interruptIdleWorkers() {    final ReentrantLock mainLock = this.mainLock;    mainLock.lock();    try {        for (Worker w : workers)  //实际上调用的是worker的interruptIfIdle()方法            w.interruptIfIdle();    } finally {        mainLock.unlock();    }}  </code></pre><p> 　　从实现可以看出，它实际上调用的是worker的interruptIfIdle()方法，在worker的interruptIfIdle()方法中：</p><pre><code>void interruptIfIdle() {    final ReentrantLock runLock = this.runLock;    if (runLock.tryLock()) {    //注意这里，是调用tryLock()来获取锁的，因为如果当前worker正在执行任务，锁已经被获取了，是无法获取到锁的                                //如果成功获取了锁，说明当前worker处于空闲状态        try {    if (thread != Thread.currentThread())       thread.interrupt();        } finally {            runLock.unlock();        }    }}</code></pre><p>  　　这里有一个非常巧妙的设计方式，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里直接让执行完任务的线程去任务缓存队列里面取任务来执行。</p><p> 　　我们再看addIfUnderMaximumPoolSize方法的实现，这个方法的实现思想和addIfUnderCorePoolSize方法的实现思想非常相似，唯一的区别在于addIfUnderMaximumPoolSize方法是在线程池中的线程数达到了核心池大小并且往任务队列中添加任务失败的情况下执行的：</p><pre><code>private boolean addIfUnderMaximumPoolSize(Runnable firstTask) {    Thread t = null;    final ReentrantLock mainLock = this.mainLock;    mainLock.lock();    try {        if (poolSize &lt; maximumPoolSize &amp;&amp; runState == RUNNING)            t = addThread(firstTask);    } finally {        mainLock.unlock();    }    if (t == null)        return false;    t.start();    return true;}  </code></pre><p> 　　看到没有，其实它和addIfUnderCorePoolSize方法的实现基本一模一样，只是if语句判断条件中的poolSize &lt; maximumPoolSize不同而已。</p><p>　　到这里，大部分朋友应该对任务提交给线程池之后到被执行的整个过程有了一个基本的了解，下面总结一下：</p><p>　　1）首先，要清楚corePoolSize和maximumPoolSize的含义；</p><p>　　2）其次，要知道Worker是用来起到什么作用的；</p><p>　　3）要知道任务提交给线程池之后的处理策略，这里总结一下主要有4点：</p><ul><li>如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；</li><li>如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</li><li>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；</li><li>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。<br>3.线程池中的线程初始化</li></ul><p>　　默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。</p><p>　　在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：</p><ul><li>prestartCoreThread()：初始化一个核心线程；</li><li><p>prestartAllCoreThreads()：初始化所有核心线程<br>　　下面是这2个方法的实现：</p><p>  public boolean prestartCoreThread() {</p><pre><code>return addIfUnderCorePoolSize(null); //注意传进去的参数是null</code></pre><p>  }</p><p>  public int prestartAllCoreThreads() {</p><pre><code>int n = 0;while (addIfUnderCorePoolSize(null))//注意传进去的参数是null    ++n;return n;</code></pre><p>  }<br>　　注意上面传进去的参数是null，根据第2小节的分析可知如果传进去的参数为null，则最后执行线程会阻塞在getTask方法中的</p><p>r = workQueue.take();<br>　　即等待任务队列中有任务。</p></li></ul><p>4.任务缓存队列及排队策略</p><p>　　在前面我们多次提到了任务缓存队列，即workQueue，它用来存放等待执行的任务。</p><p>　　workQueue的类型为BlockingQueue<runnable>，通常可以取下面三种类型：</runnable></p><p>　　1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；</p><p>　　2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；</p><p>　　3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</p><p>5.任务拒绝策略</p><p>　　当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：</p><pre><code>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务  </code></pre><p>6.线程池的关闭</p><p>　　ThreadPoolExecutor提供了两个方法，用于线程池的关闭，分别是shutdown()和shutdownNow()，其中：</p><ul><li>shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</li><li>shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务<br>7.线程池容量的动态调整</li></ul><p>　　ThreadPoolExecutor提供了动态调整线程池容量大小的方法：setCorePoolSize()和setMaximumPoolSize()，</p><ul><li>setCorePoolSize：设置核心池大小</li><li>setMaximumPoolSize：设置线程池最大能创建的线程数目大小<br>　　当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。</li></ul><h2 id="三-使用示例"><a href="#三-使用示例" class="headerlink" title="三.使用示例"></a>三.使用示例</h2><p>　　前面我们讨论了关于线程池的实现原理，这一节我们来看一下它的具体使用：</p><pre><code>public class Test {     public static void main(String[] args) {             ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS,                  new ArrayBlockingQueue&lt;Runnable&gt;(5));         for(int i=0;i&lt;15;i++){             MyTask myTask = new MyTask(i);             executor.execute(myTask);             System.out.println(&quot;线程池中线程数目：&quot;+executor.getPoolSize()+&quot;，队列中等待执行的任务数目：&quot;+             executor.getQueue().size()+&quot;，已执行玩别的任务数目：&quot;+executor.getCompletedTaskCount());         }         executor.shutdown();     } }class MyTask implements Runnable {    private int taskNum;    public MyTask(int num) {        this.taskNum = num;    }    @Override    public void run() {        System.out.println(&quot;正在执行task &quot;+taskNum);        try {            Thread.currentThread().sleep(4000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(&quot;task &quot;+taskNum+&quot;执行完毕&quot;);    }}</code></pre><p> 　　执行结果：</p><pre><code>正在执行task 0线程池中线程数目：1，队列中等待执行的任务数目：0，已执行玩别的任务数目：0线程池中线程数目：2，队列中等待执行的任务数目：0，已执行玩别的任务数目：0正在执行task 1线程池中线程数目：3，队列中等待执行的任务数目：0，已执行玩别的任务数目：0正在执行task 2线程池中线程数目：4，队列中等待执行的任务数目：0，已执行玩别的任务数目：0正在执行task 3线程池中线程数目：5，队列中等待执行的任务数目：0，已执行玩别的任务数目：0正在执行task 4线程池中线程数目：5，队列中等待执行的任务数目：1，已执行玩别的任务数目：0线程池中线程数目：5，队列中等待执行的任务数目：2，已执行玩别的任务数目：0线程池中线程数目：5，队列中等待执行的任务数目：3，已执行玩别的任务数目：0线程池中线程数目：5，队列中等待执行的任务数目：4，已执行玩别的任务数目：0线程池中线程数目：5，队列中等待执行的任务数目：5，已执行玩别的任务数目：0线程池中线程数目：6，队列中等待执行的任务数目：5，已执行玩别的任务数目：0正在执行task 10线程池中线程数目：7，队列中等待执行的任务数目：5，已执行玩别的任务数目：0正在执行task 11线程池中线程数目：8，队列中等待执行的任务数目：5，已执行玩别的任务数目：0正在执行task 12线程池中线程数目：9，队列中等待执行的任务数目：5，已执行玩别的任务数目：0正在执行task 13线程池中线程数目：10，队列中等待执行的任务数目：5，已执行玩别的任务数目：0正在执行task 14task 3执行完毕task 0执行完毕task 2执行完毕task 1执行完毕正在执行task 8正在执行task 7正在执行task 6正在执行task 5task 4执行完毕task 10执行完毕task 11执行完毕task 13执行完毕task 12执行完毕正在执行task 9task 14执行完毕task 8执行完毕task 5执行完毕task 7执行完毕task 6执行完毕task 9执行完毕</code></pre><p>　　从执行结果可以看出，当线程池中线程的数目大于5时，便将任务放入任务缓存队列里面，当任务缓存队列满了之后，便创建新的线程。如果上面程序中，将for循环中改成执行20个任务，就会抛出任务拒绝异常了。</p><p>　　不过在javadoc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池：</p><pre><code>Executors.newCachedThreadPool();        //创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUEExecutors.newSingleThreadExecutor();   //创建容量为1的缓冲池Executors.newFixedThreadPool(int);    //创建固定容量大小的缓冲池  </code></pre><p> 　　下面是这三个静态方法的具体实现;</p><pre><code>public static ExecutorService newFixedThreadPool(int nThreads) {    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;());}public static ExecutorService newSingleThreadExecutor() {    return new FinalizableDelegatedExecutorService        (new ThreadPoolExecutor(1, 1,                                0L, TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;()));}public static ExecutorService newCachedThreadPool() {    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());}  </code></pre><p>　　从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。</p><p>　　newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue；</p><p>　　newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue；</p><p>　　newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</p><p>　　实际中，如果Executors提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置ThreadPoolExecutor的参数有点麻烦，要根据实际任务的类型和数量来进行配置。</p><p>　　另外，如果ThreadPoolExecutor达不到要求，可以自己继承ThreadPoolExecutor类进行重写。</p><h2 id="四-如何合理配置线程池的大小"><a href="#四-如何合理配置线程池的大小" class="headerlink" title="四.如何合理配置线程池的大小"></a>四.如何合理配置线程池的大小</h2><p>　　本节来讨论一个比较重要的话题：如何合理配置线程池大小，仅供参考。</p><p>　　一般需要根据任务的类型来配置线程池大小：</p><p>　　如果是CPU密集型任务，就需要尽量压榨CPU，参考值可以设为 NCPU+1</p><p>　　如果是IO密集型任务，参考值可以设置为2*NCPU</p><p>　　当然，这只是一个参考值，具体的设置还需要根据实际情况进行调整，比如可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。 </p><blockquote><p>参考资料：</p><p><a href="http://ifeve.com/java-threadpool/" target="_blank" rel="noopener">http://ifeve.com/java-threadpool/</a></p><p><a href="http://blog.163.com/among_1985/blog/static/275005232012618849266/" target="_blank" rel="noopener">http://blog.163.com/among_1985/blog/static/275005232012618849266/</a></p><p><a href="http://developer.51cto.com/art/201203/321885.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201203/321885.htm</a></p><p><a href="http://blog.csdn.net/java2000_wl/article/details/22097059" target="_blank" rel="noopener">http://blog.csdn.net/java2000_wl/article/details/22097059</a></p><p><a href="http://blog.csdn.net/cutesource/article/details/6061229" target="_blank" rel="noopener">http://blog.csdn.net/cutesource/article/details/6061229</a></p><p><a href="http://blog.csdn.net/xieyuooo/article/details/8718741" target="_blank" rel="noopener">http://blog.csdn.net/xieyuooo/article/details/8718741</a></p><p>《JDK API 1.6》</p></blockquote>]]></content>
    
    <summary type="html">
    
      那么有没有一种办法使得线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？我们从最核心的ThreadPoolExecutor类中的方法讲起，然后再讲述它的实现原理，接着给出了它的使用示例，最后讨论了一下如何合理配置线程池的大小
    
    </summary>
    
      <category term="Java并发编程系列" scheme="http://xym-loveit.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="java多线程" scheme="http://xym-loveit.github.io/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="阻塞队列" scheme="http://xym-loveit.github.io/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
      <category term="Executors" scheme="http://xym-loveit.github.io/tags/Executors/"/>
    
      <category term="ThreadPoolExecutor" scheme="http://xym-loveit.github.io/tags/ThreadPoolExecutor/"/>
    
      <category term="AbstractExecutorService" scheme="http://xym-loveit.github.io/tags/AbstractExecutorService/"/>
    
      <category term="ExecutorService" scheme="http://xym-loveit.github.io/tags/ExecutorService/"/>
    
      <category term="Executor" scheme="http://xym-loveit.github.io/tags/Executor/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程：阻塞队列</title>
    <link href="http://xym-loveit.github.io/2017/05/01/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9A%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://xym-loveit.github.io/2017/05/01/Java并发编程：阻塞队列/</id>
    <published>2017-05-01T08:52:26.000Z</published>
    <updated>2018-03-29T01:27:48.633Z</updated>
    
    <content type="html"><![CDATA[<p>在前面几篇文章中，我们讨论了同步容器(Hashtable、Vector），也讨论了并发容器（ConcurrentHashMap、CopyOnWriteArrayList），这些工具都为我们编写多线程程序提供了很大的方便。今天我们来讨论另外一类容器：阻塞队列。</p><p>　　在前面我们接触的队列都是非阻塞队列，比如PriorityQueue、LinkedList（LinkedList是双向链表，它实现了Dequeue接口）。</p><p>　　使用非阻塞队列的时候有一个很大问题就是：它不会对当前线程产生阻塞，那么在面对类似消费者-生产者的模型时，就必须额外地实现同步策略以及线程间唤醒策略，这个实现起来就非常麻烦。但是有了阻塞队列就不一样了，它会对当前线程产生阻塞，比如一个线程从一个空的阻塞队列中取元素，此时线程会被阻塞直到阻塞队列中有了元素。当队列中有元素后，被阻塞的线程会自动被唤醒（不需要我们编写代码去唤醒）。这样提供了极大的方便性。</p><p>　　本文先讲述一下java.util.concurrent包下提供主要的几种阻塞队列，然后分析了阻塞队列和非阻塞队列的中的各个方法，接着分析了阻塞队列的实现原理，最后给出了一个实际例子和几个使用场景。</p><p>　　一.几种主要的阻塞队列</p><p>　　二.阻塞队列中的方法 VS 非阻塞队列中的方法</p><p>　　三.阻塞队列的实现原理</p><p>　　四.示例和使用场景</p><p>　　若有不正之处请多多谅解，并欢迎批评指正。</p><p>　　请尊重作者劳动成果，转载请标明原文链接：</p><p> 　　<a href="http://www.cnblogs.com/dolphin0520/p/3932906.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3932906.html</a></p><h2 id="一-几种主要的阻塞队列"><a href="#一-几种主要的阻塞队列" class="headerlink" title="一.几种主要的阻塞队列"></a>一.几种主要的阻塞队列</h2><p>　　自从Java 1.5之后，在java.util.concurrent包下提供了若干个阻塞队列，主要有以下几个：</p><p>　　ArrayBlockingQueue：基于数组实现的一个阻塞队列，在创建ArrayBlockingQueue对象时必须制定容量大小。并且可以指定公平性与非公平性，默认情况下为非公平的，即不保证等待时间最长的队列最优先能够访问队列。</p><p>　　LinkedBlockingQueue：基于链表实现的一个阻塞队列，在创建LinkedBlockingQueue对象时如果不指定容量大小，则默认大小为Integer.MAX_VALUE。</p><p>　　PriorityBlockingQueue：以上2种队列都是先进先出队列，而PriorityBlockingQueue却不是，它会按照元素的优先级对元素进行排序，按照优先级顺序出队，每次出队的元素都是优先级最高的元素。注意，此阻塞队列为无界阻塞队列，即容量没有上限（通过源码就可以知道，它没有容器满的信号标志），前面2种都是有界队列。</p><p>　　DelayQueue：基于PriorityQueue，一种延时阻塞队列，DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue也是一个无界队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p><h2 id="二-阻塞队列中的方法-VS-非阻塞队列中的方法"><a href="#二-阻塞队列中的方法-VS-非阻塞队列中的方法" class="headerlink" title="二.阻塞队列中的方法 VS 非阻塞队列中的方法"></a>二.阻塞队列中的方法 VS 非阻塞队列中的方法</h2><p>1.非阻塞队列中的几个主要方法：</p><p>　　add(E e):将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则会抛出异常；</p><p>　　remove()：移除队首元素，若移除成功，则返回true；如果移除失败（队列为空），则会抛出异常；</p><p>　　offer(E e)：将元素e插入到队列末尾，如果插入成功，则返回true；如果插入失败（即队列已满），则返回false；</p><p>　　poll()：移除并获取队首元素，若成功，则返回队首元素；否则返回null；</p><p>　　peek()：获取队首元素，若成功，则返回队首元素；否则返回null</p><p>　　对于非阻塞队列，一般情况下建议使用offer、poll和peek三个方法，不建议使用add和remove方法。因为使用offer、poll和peek三个方法可以通过返回值判断操作成功与否，而使用add和remove方法却不能达到这样的效果。注意，非阻塞队列中的方法都没有进行同步措施。</p><p>2.阻塞队列中的几个主要方法：</p><p>　　阻塞队列包括了非阻塞队列中的大部分方法，上面列举的5个方法在阻塞队列中都存在，但是要注意这5个方法在阻塞队列中都进行了同步措施。除此之外，阻塞队列提供了另外4个非常有用的方法：</p><p>　　put(E e)</p><p>　　take()</p><p>　　offer(E e,long timeout, TimeUnit unit)</p><p>　　poll(long timeout, TimeUnit unit)</p><p>　　</p><p>　　put方法用来向队尾存入元素，如果队列满，则等待；</p><p>　　take方法用来从队首取元素，如果队列为空，则等待；</p><p>　　offer方法用来向队尾存入元素，如果队列满，则等待一定的时间，当时间期限达到时，如果还没有插入成功，则返回false；否则返回true；</p><p>　　poll方法用来从队首取元素，如果队列空，则等待一定的时间，当时间期限达到时，如果取到，则返回null；否则返回取得的元素；</p><h2 id="三-阻塞队列的实现原理"><a href="#三-阻塞队列的实现原理" class="headerlink" title="三.阻塞队列的实现原理"></a>三.阻塞队列的实现原理</h2><p>　　前面谈到了非阻塞队列和阻塞队列中常用的方法，下面来探讨阻塞队列的实现原理，本文以ArrayBlockingQueue为例，其他阻塞队列实现原理可能和ArrayBlockingQueue有一些差别，但是大体思路应该类似，有兴趣的朋友可自行查看其他阻塞队列的实现源码。</p><p>　　首先看一下ArrayBlockingQueue类中的几个成员变量：  </p><pre><code>public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;,java.io.Serializable {    private static final long serialVersionUID = -817911632652898426L;    /** The queued items  */    private final E[] items;    /** items index for next take, poll or remove */    private int takeIndex;    /** items index for next put, offer, or add. */    private int putIndex;    /** Number of items in the queue */    private int count;    /*    * Concurrency control uses the classic two-condition algorithm    * found in any textbook.    */    /** Main lock guarding all access */    private final ReentrantLock lock;    /** Condition for waiting takes */    private final Condition notEmpty;    /** Condition for waiting puts */    private final Condition notFull;}</code></pre><p> 　　可以看出，ArrayBlockingQueue中用来存储元素的实际上是一个数组，takeIndex和putIndex分别表示队首元素和队尾元素的下标，count表示队列中元素的个数。</p><p>　　lock是一个可重入锁，notEmpty和notFull是等待条件。</p><p>　　下面看一下ArrayBlockingQueue的构造器，构造器有三个重载版本：  </p><pre><code>public ArrayBlockingQueue(int capacity) {}public ArrayBlockingQueue(int capacity, boolean fair) {}public ArrayBlockingQueue(int capacity, boolean fair,                          Collection&lt;? extends E&gt; c) {}</code></pre><p> 　　第一个构造器只有一个参数用来指定容量，第二个构造器可以指定容量和公平性，第三个构造器可以指定容量、公平性以及用另外一个集合进行初始化。</p><p>　　然后看它的两个关键方法的实现：put()和take()：  </p><pre><code>public void put(E e) throws InterruptedException {    if (e == null) throw new NullPointerException();    final E[] items = this.items;    final ReentrantLock lock = this.lock;    lock.lockInterruptibly();    try {        try {            while (count == items.length)                notFull.await();        } catch (InterruptedException ie) {            notFull.signal(); // propagate to non-interrupted thread            throw ie;        }        insert(e);    } finally {        lock.unlock();    }}</code></pre><p> 　　从put方法的实现可以看出，它先获取了锁，并且获取的是可中断锁，然后判断当前元素个数是否等于数组的长度，如果相等，则调用notFull.await()进行等待，如果捕获到中断异常，则唤醒线程并抛出异常。</p><p>　　当被其他线程唤醒时，通过insert(e)方法插入元素，最后解锁。</p><p>　　我们看一下insert方法的实现：  </p><pre><code>private void insert(E x) {    items[putIndex] = x;    putIndex = inc(putIndex);    ++count;    notEmpty.signal();}</code></pre><p> 　　它是一个private方法，插入成功后，通过notEmpty唤醒正在等待取元素的线程。</p><p>　　下面是take()方法的实现：  </p><pre><code>public E take() throws InterruptedException {    final ReentrantLock lock = this.lock;    lock.lockInterruptibly();    try {        try {            while (count == 0)                notEmpty.await();        } catch (InterruptedException ie) {            notEmpty.signal(); // propagate to non-interrupted thread            throw ie;        }        E x = extract();        return x;    } finally {        lock.unlock();    }}</code></pre><p> 　　跟put方法实现很类似，只不过put方法等待的是notFull信号，而take方法等待的是notEmpty信号。在take方法中，如果可以取元素，则通过extract方法取得元素，下面是extract方法的实现：  </p><pre><code>private E extract() {    final E[] items = this.items;    E x = items[takeIndex];    items[takeIndex] = null;    takeIndex = inc(takeIndex);    --count;    notFull.signal();    return x;}  </code></pre><p> 　　跟insert方法也很类似。</p><p>　　其实从这里大家应该明白了阻塞队列的实现原理，事实它和我们用Object.wait()、Object.notify()和非阻塞队列实现生产者-消费者的思路类似，只不过它把这些工作一起集成到了阻塞队列中实现。</p><h2 id="四-示例和使用场景"><a href="#四-示例和使用场景" class="headerlink" title="四.示例和使用场景"></a>四.示例和使用场景</h2><p>　　下面先使用Object.wait()和Object.notify()、非阻塞队列实现生产者-消费者模式：  </p><pre><code>public class Test {    private int queueSize = 10;    private PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;(queueSize);    public static void main(String[] args)  {        Test test = new Test();        Producer producer = test.new Producer();        Consumer consumer = test.new Consumer();        producer.start();        consumer.start();    }    class Consumer extends Thread{        @Override        public void run() {            consume();        }        private void consume() {            while(true){                synchronized (queue) {                    while(queue.size() == 0){                        try {                            System.out.println(&quot;队列空，等待数据&quot;);                            queue.wait();                        } catch (InterruptedException e) {                            e.printStackTrace();                            queue.notify();                        }                    }                    queue.poll();          //每次移走队首元素                    queue.notify();                    System.out.println(&quot;从队列取走一个元素，队列剩余&quot;+queue.size()+&quot;个元素&quot;);                }            }        }    }    class Producer extends Thread{        @Override        public void run() {            produce();        }        private void produce() {            while(true){                synchronized (queue) {                    while(queue.size() == queueSize){                        try {                            System.out.println(&quot;队列满，等待有空余空间&quot;);                            queue.wait();                        } catch (InterruptedException e) {                            e.printStackTrace();                            queue.notify();                        }                    }                    queue.offer(1);        //每次插入一个元素                    queue.notify();                    System.out.println(&quot;向队列取中插入一个元素，队列剩余空间：&quot;+(queueSize-queue.size()));                }            }        }    }}</code></pre><p> 　　这个是经典的生产者-消费者模式，通过阻塞队列和Object.wait()和Object.notify()实现，wait()和notify()主要用来实现线程间通信。</p><p>　　具体的线程间通信方式（wait和notify的使用）在后续问章中会讲述到。</p><p>　　下面是使用阻塞队列实现的生产者-消费者模式：  </p><pre><code>public class Test {    private int queueSize = 10;    private ArrayBlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;Integer&gt;(queueSize);    public static void main(String[] args)  {        Test test = new Test();        Producer producer = test.new Producer();        Consumer consumer = test.new Consumer();        producer.start();        consumer.start();    }    class Consumer extends Thread{        @Override        public void run() {            consume();        }        private void consume() {            while(true){                try {                    queue.take();                    System.out.println(&quot;从队列取走一个元素，队列剩余&quot;+queue.size()+&quot;个元素&quot;);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }    class Producer extends Thread{        @Override        public void run() {            produce();        }        private void produce() {            while(true){                try {                    queue.put(1);                    System.out.println(&quot;向队列取中插入一个元素，队列剩余空间：&quot;+(queueSize-queue.size()));                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }}  </code></pre><p> 　　有没有发现，使用阻塞队列代码要简单得多，不需要再单独考虑同步和线程间通信的问题。</p><p>　　在并发编程中，一般推荐使用阻塞队列，这样实现可以尽量地避免程序出现意外的错误。</p><p>　　阻塞队列使用最经典的场景就是socket客户端数据的读取和解析，读取数据的线程不断将数据放入队列，然后解析线程不断从队列取数据解析。还有其他类似的场景，只要符合生产者-消费者模型的都可以使用阻塞队列。</p><p>　　参考资料：</p><p>　　《Java编程实战》</p><p>　　<a href="http://ifeve.com/java-blocking-queue/" target="_blank" rel="noopener">http://ifeve.com/java-blocking-queue/</a></p><p>　　<a href="http://endual.iteye.com/blog/1412212" target="_blank" rel="noopener">http://endual.iteye.com/blog/1412212</a></p><p>　　<a href="http://blog.csdn.net/zzp_403184692/article/details/8021615" target="_blank" rel="noopener">http://blog.csdn.net/zzp_403184692/article/details/8021615</a></p><p>　　<a href="http://www.cnblogs.com/juepei/p/3922401.html" target="_blank" rel="noopener">http://www.cnblogs.com/juepei/p/3922401.html</a></p>]]></content>
    
    <summary type="html">
    
      使用非阻塞队列的时候有一个很大问题就是：它不会对当前线程产生阻塞，那么在面对类似消费者-生产者的模型时，就必须额外地实现同步策略以及线程间唤醒策略，这个实现起来就非常麻烦。但是有了阻塞队列就不一样了，它会对当前线程产生阻塞，比如一个线程从一个空的阻塞队列中取元素，此时线程会被阻塞直到阻塞队列中有了元素。当队列中有元素后，被阻塞的线程会自动被唤醒（不需要我们编写代码去唤醒）
    
    </summary>
    
      <category term="Java并发编程系列" scheme="http://xym-loveit.github.io/categories/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="java多线程" scheme="http://xym-loveit.github.io/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="阻塞队列" scheme="http://xym-loveit.github.io/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
      <category term="ArrayBlockingQueue" scheme="http://xym-loveit.github.io/tags/ArrayBlockingQueue/"/>
    
  </entry>
  
</feed>
