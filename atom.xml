<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>放肆的青春</title>
  
  <subtitle>要变得和大叔一样强</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xym-loveit.github.io/"/>
  <updated>2018-04-26T16:37:46.772Z</updated>
  <id>http://xym-loveit.github.io/</id>
  
  <author>
    <name>xym</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker基础-docker compose网络</title>
    <link href="http://xym-loveit.github.io/2018/04/26/Docker%E5%9F%BA%E7%A1%80-docker-compose%E7%BD%91%E7%BB%9C/"/>
    <id>http://xym-loveit.github.io/2018/04/26/Docker基础-docker-compose网络/</id>
    <published>2018-04-26T08:46:31.000Z</published>
    <updated>2018-04-26T16:37:46.772Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注意： 本文涉及的compose只适用于compose文件格式为version 2的版本，v1(旧的)不支持网络功能</p></blockquote><p>默认<code>compose</code>会为你的app配置一个单独的网络。服务中的每个容器加入到这个默认的网络且在这个网络的容器都能互相通信，它们也能通过与容器名称相同的主机名发现对方。</p><blockquote><p>注意： app的网络基于”项目名称”设置网络名称，这个项目名称基于项目所处的目录名。可以使用–project-name选项或COMPOSE_PROJECT_NAME环境变量来覆盖。</p></blockquote><p>例如，假设app在一个名为<code>myapp</code>的目录，<code>docker-compose.yml</code>内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8000:8000&quot;</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure><p>当执行<code>docker-compose up</code>时，网络部分设置如下： 1.创建了称之为myapp_default的网络 2.使用web的配置创建容器，然后这个容器加入到myapp_default网络 3.使用db的配置创建容器，这个容器加入到myapp_default网络</p><p>每个容器现在能直接查找主机名web或db来得到容器的IP地址。例如，web应用程序的代码可以连接URL postgres://db:5432并开始使用postgres数据库。 由于web明确的映射了一个端口，外部网络也就能通过在docker主机的网络接口的8000端口连接容器。</p><h2 id="容器更新"><a href="#容器更新" class="headerlink" title="容器更新"></a>容器更新</h2><p>如果更改了服务的配置并执行<code>docker-compose up</code>来更新它，将删除旧的容器并且新的容器会加入到相同的网络，分配到了不同的IP地址，不过主机名不变。运行中的容器应该能够查找主机名并连接到新的地址，不过旧的地址将失效。</p><p>如果任何一个容器与旧容器有连接，它们会被关闭掉。容器有责任检测这种情况然后重新查找旧容器的主机来重新连接。</p><h2 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h2><p>links可以为一个容器定义一个额外的别名。即使服务没有启动，它们也能进行通信。默认任何服务都可以通过该服务的名称访问其他的服务。例如：在web容器中可以通过db和database访问db容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    links:</span><br><span class="line">      - &quot;db:database&quot;</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure><h2 id="多主机网络"><a href="#多主机网络" class="headerlink" title="多主机网络"></a>多主机网络</h2><p>当在swarm集群中部署compose app的时候，你可以使用内置的overlaydriver来启用容器之间的多主机通信，这不会更改你的compose文件和app code。</p><p>请参阅Getting started with multi-host networking<a href="https://docs.docker.com/network/overlay-standalone.swarm/" target="_blank" rel="noopener">Getting started with multi-host networking</a>来了解怎么配置swarm集群。swarm默认是使用overlay网络驱动，当然你也可以自己自定义。详情在下一段</p><h2 id="指定自定义网络"><a href="#指定自定义网络" class="headerlink" title="指定自定义网络"></a>指定自定义网络</h2><p>除了使用默认的app网络之外，还可以使用最顶层的<code>networks</code>关键字来指定自定义的网络。这让你可以创建更复杂的网络并制定自定义网络驱动及其选项。也可以使用它将服务连接到不是有compose管理的外部网络。</p><p>每个服务都能指定由networks关键字配置的网络，可以配置service级别和top级的网络。</p><p>下面的示例compose文件定义了两个自定义网络。proxy服务与db服务隔离，因为它们没有指定相同的网络。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  proxy:</span><br><span class="line">    build: ./proxy</span><br><span class="line">    networks:</span><br><span class="line">      - front</span><br><span class="line">  app:</span><br><span class="line">    build: ./app</span><br><span class="line">    networks:</span><br><span class="line">      - front</span><br><span class="line">      - back</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line">    networks:</span><br><span class="line">      - back</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  front:</span><br><span class="line">    # Use a custom driver</span><br><span class="line">    driver: custom-driver-1</span><br><span class="line">  back:</span><br><span class="line">    # Use a custom driver which takes special options</span><br><span class="line">    driver: custom-driver-2</span><br><span class="line">    driver_opts:</span><br><span class="line">      foo: &quot;1&quot;</span><br><span class="line">      bar: &quot;2&quot;</span><br></pre></td></tr></table></figure><h2 id="配置默认网络"><a href="#配置默认网络" class="headerlink" title="配置默认网络"></a>配置默认网络</h2><p>除了指定你自己的网络之外，还可以通过在名为default的网络下定义一个条目来更改应用范围内的默认网络设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8000:8000&quot;</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    # Use a custom driver</span><br><span class="line">    driver: custom-driver-1</span><br></pre></td></tr></table></figure></p><h2 id="使用预先存在的网络"><a href="#使用预先存在的网络" class="headerlink" title="使用预先存在的网络"></a>使用预先存在的网络</h2><p>如果你希望你的容器加入一个预先存在的网络，使用external选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    external:</span><br><span class="line">      name: my-pre-existing-network</span><br></pre></td></tr></table></figure><p>compose检测到有external选项后，不会创建名为[PROJECTNAME]_default的网络，而是会查找一个名为my-pre-existing-network的网络，并将应用程序连接到它。</p>]]></content>
    
    <summary type="html">
    
      docker compose网络配置。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="compose网络" scheme="http://xym-loveit.github.io/tags/compose%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础-docker 容器日志命名</title>
    <link href="http://xym-loveit.github.io/2018/04/26/Docker%E5%9F%BA%E7%A1%80-docker-%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97%E5%91%BD%E5%90%8D/"/>
    <id>http://xym-loveit.github.io/2018/04/26/Docker基础-docker-容器日志命名/</id>
    <published>2018-04-26T08:22:19.000Z</published>
    <updated>2018-04-26T08:37:34.165Z</updated>
    
    <content type="html"><![CDATA[<p>tag 选项指定你该为容器的日志如何命名。默认是容器ID的前12个字符。要覆盖默认值，可指定一个tag选项:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --log-driver=fluentd --log-opt fluentd-address=myhost.local:24224 --log-opt tag=&quot;mailer&quot;</span><br></pre></td></tr></table></figure></p><p>docker支持一些特殊的标记模板，你可以在指定的时候使用</p><table><thead><tr><th>标记</th><th>描述</th></tr></thead><tbody><tr><td>{ { .ID } }</td><td>容器ID的前12个字符</td></tr><tr><td>{ { .FullID } }</td><td>容器的全部ID</td></tr><tr><td>{ { .Name } }</td><td>容器名</td></tr><tr><td>{ { .ImageID } }</td><td>Image ID 前12个字符</td></tr><tr><td>{ { .ImageFullID } }</td><td>全部的Image ID</td></tr><tr><td>{ { .ImageName } }</td><td>Image 名</td></tr><tr><td>{ { .DaemonName } }</td><td>docker 进程的名称</td></tr></tbody></table><p>例如：指定一个 <code>--log-opt tag=&quot;{ { .ImageName } }/{ { .Name } }/{ { .ID } }&quot;</code>,让其输出到syslog，那么最终他输出的内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aug  7 18:33:19 HOSTNAME docker/hello-world/foobar/5790672ab6a0[9103]: Hello from Docker</span><br></pre></td></tr></table></figure></p><p>在启动时，系统会在<code>tag</code>中设置<code>container_name</code> 字段和<code>{ { .name } }</code>字段，如果你使用<code>docker rename</code>重命名容器，新名称不会反映在日志消息中，这些消息会继续使用原来的容器名。</p><p>更高级的用法，可以去参考<a href="https://golang.org/pkg/text/template/" target="_blank" rel="noopener">go templates</a>和<a href="https://github.com/moby/moby/tree/master/daemon/logger" target="_blank" rel="noopener">container’s logging context</a></p><p>下面是一个syslog的例子，如果我们使用下面的内容,就会得到如下的日志内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm \</span><br><span class="line">    --log-driver syslog \</span><br><span class="line">    --log-opt tag=&quot;&#123; &#123;  (.ExtraAttributes nil).SOME_ENV_VAR  &#125; &#125;&quot; \</span><br><span class="line">    --log-opt env=SOME_ENV_VAR \</span><br><span class="line">    -e SOME_ENV_VAR=logtester.1234 \</span><br><span class="line">    flyinprogrammer/logtester</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apr  1 15:22:17 ip-10-27-39-73 docker/logtester.1234[45499]: + exec app</span><br><span class="line">Apr  1 15:22:17 ip-10-27-39-73 docker/logtester.1234[45499]: 2016-04-01 15:22:17.075416751 +0000 UTC stderr msg: 1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Docker容器日志命名配置。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="docker容器日志" scheme="http://xym-loveit.github.io/tags/docker%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础-docker limit资源限制</title>
    <link href="http://xym-loveit.github.io/2018/04/26/Docker%E5%9F%BA%E7%A1%80-docker-limit%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6/"/>
    <id>http://xym-loveit.github.io/2018/04/26/Docker基础-docker-limit资源限制/</id>
    <published>2018-04-26T07:57:00.000Z</published>
    <updated>2018-04-26T08:21:00.975Z</updated>
    
    <content type="html"><![CDATA[<p>默认情况下，容器没有资源约束，可以使用与主机的内核调度程序允许的的资源一样多的资源。docker提供了在运行<code>docker run</code>指定选项来控制容器内存，cpu或IO的方法。这部分提供了有关何时应该设置这类限制以及设置这些限制可能有什么影响的详细信息。</p><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>Docker 可以强制执行硬内存限制，其允许容器使用不超过用户或系统给定的内存大小，或者软限制，允许容器在满足条件的情况下使用所需内存，例如,当内核检测到主机上的内存不足或有争抢。下面的选项单独使用或集中使用会有不同的效果。 这些选项中大部分都是采用正整数，后面跟一个后缀b,k,m,g，表示字节，千字节，兆字节，千兆字节。</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>-m or –memory=</td><td>容器可以使用的最大内存大小，如果你设置了这个选项，那么内存最小也要4m</td></tr><tr><td>–memory-swarp*</td><td>容器可以交换到硬盘的内存大小，可参考<a href="https://docs.docker.com/config/containers/resource_constraints/" target="_blank" rel="noopener">–memory-swap details</a></td></tr><tr><td>–memory-swappiness</td><td>默认情况下，主机内核可以交换容器使用的匿名页面的百分比，可以在0-100之间设置<code>--memory-swappiness</code>的百分比，可参考<a href="https://docs.docker.com/config/containers/resource_constraints/#--memory-swappiness-details" target="_blank" rel="noopener">–memory-swappiness details</a></td></tr><tr><td>–memory-reservation</td><td>允许你指定一个小于–memory的软限制，当docker在主机上检测到争用或低内存时激活该限制。如果使用–memory-reservation，则必须将其设置为低于–memory，以使其优先。因为它是一个软限制，不保证容器不会超过限制。</td></tr><tr><td>–kernel-memory</td><td>容器可以使用的最大内核内存，最小值是4m。因为内核内存无法交换出来，一个缺少内核内存的容器可能会阻塞主机资源，这会对主机和其他容器产生副作用</td></tr><tr><td>–oom-kill-disable</td><td>默认情况下，如果发生内存不足(OOM)错误，内核会杀死容器中的进程。我们可以使用–oom-kill-disable选项来改变设置，如果你设置了-m/–memory选项，那么容器会一直耗尽到-m限制的内存大小。而如果你没有设定-m，主机会尽可能的耗尽内存，内核可能需要杀死主机系统的进程以释放内存。</td></tr></tbody></table><h3 id="–memory-swap-details"><a href="#–memory-swap-details" class="headerlink" title="–memory-swap details"></a>–memory-swap details</h3><ul><li>如果没有设置–memory-swap，而设置了–memory，容器能够使用–memory值的两倍的swap。例如：–memory=300m,–memory-swap没有设置，那么容器能够使用300m内存和600m swap。</li><li>如果–memory和–memory-swap都设置了，–memory-swap表示能够使用内存和swap的总数，–memory控制非swap的内存大小。例如：–memory=300m,–memory-swap=1g，那么容器能够使用300m内存和700m的swap。</li><li>如果设置为-1(默认)，表示容器可以无限使用swap</li></ul><h3 id="–memory-swappiness-details"><a href="#–memory-swappiness-details" class="headerlink" title="–memory-swappiness details"></a>–memory-swappiness details</h3><ul><li>如果值为0，关闭匿名页面交换</li><li>值100，将所有匿名页面设置为可交换</li><li>默认情况下，如果不设置<code>--memory-swappiness</code>，容器将继承主机计算机的值</li></ul><h3 id="–kernel-memory-details"><a href="#–kernel-memory-details" class="headerlink" title="–kernel-memory details"></a>–kernel-memory details</h3><p>内核内存限制以分配给容器的总内存来表示，有以下几种场景：</p><ul><li>没有限制–memory，没有限制–kernel-memory： 这是默认值</li><li>没有限制–memory，有限制–kernel-memory: 当所有的cgroups所需的内存量超过主机实际拥有的内存量时，适合设置为这样子。你可以设置内核内存不超过主机可用内存，容器需要更多内存只能等待了。</li><li>有限制–memory，没有限制–kernel-memory：总内存是限制的，不过内核内存无限制</li><li>有限制–memory，有限制–kernel-memory：用户和内核限制都限制时，对调试内存相关问题会有帮助。如果一个容器用完了这两种内存之中的一种，它不会影响到其他的容器和主机。如果内核内存限制比用户内存低，使用完内核内存后，会导致容器长生OOM错误，反之，则不会。</li></ul><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>默认情况下，所有容器获得CPU周期的比例相同，你可以通过下面的选项来对容器的CPU使用进行调整。</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>–cpu-shares</td><td>设置权重，修改默认的1024增大或者减小。当其他容器有空闲CPU时，其他容器可使用空闲CPU时间</td></tr><tr><td>–cpu-period</td><td>容器的一个逻辑CPU的调度周期。默认值是100000（100ms），当然我们也可以自己设置CPU周期，限制容器CPU用量，通常和<code>--cpu-quota</code>参数使用</td></tr><tr><td>–cpu-quota</td><td>在由<code>--cpu-period</code>设置的时间段内，容器可以调度的最大CPU使用量，默认是0，以为着允许容器获得1个CPU的100%的资源量。设置50000限制CPU资源的50%</td></tr><tr><td>–cpuset-cpus</td><td>定容器允许运行的CPU号(在多核心系统中)</td></tr></tbody></table><h2 id="Block-IO"><a href="#Block-IO" class="headerlink" title="Block IO"></a>Block IO</h2><p>有两个选项可用于调整容器对直连块IO设备的访问。你还可以按照每秒字节数或每秒IO操作来指定带宽限制。</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>blkio-weight</td><td>默认情况下，每个容器可以使用相同比例的IO带宽。默认权重是500，要提高或者降低，可以设置–blkio-weight来设置介于10-1000之间的值，此设置会平等的影响到所有块IO设备</td></tr><tr><td>blkio-weight-device</td><td>与<code>--blkio-weight</code>相同，但你可以使用<code>--blkio-weight-device=DEVICE_NAME:WEGITH</code>为每个设备设置权重。</td></tr><tr><td>–device-read-bps和–device-write-bps</td><td>根据大小限制设备读取或写入的速率，使用kb，mb或gb后缀</td></tr><tr><td>–device-read-iops和–device-write-iops</td><td>通过IO操作/秒限制设备读取或写入的速率</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      Docker资源限制配置参数（MEMORY/IO/CPU）详解。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker资源限制" scheme="http://xym-loveit.github.io/tags/Docker%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6/"/>
    
      <category term="Docker limit" scheme="http://xym-loveit.github.io/tags/Docker-limit/"/>
    
      <category term="Memory limit" scheme="http://xym-loveit.github.io/tags/Memory-limit/"/>
    
      <category term="CPU limit" scheme="http://xym-loveit.github.io/tags/CPU-limit/"/>
    
      <category term="IO limit" scheme="http://xym-loveit.github.io/tags/IO-limit/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础-当docker daemon停止时依然保持容器运行</title>
    <link href="http://xym-loveit.github.io/2018/04/26/Docker%E5%9F%BA%E7%A1%80-%E5%BD%93docker-daemon%E5%81%9C%E6%AD%A2%E6%97%B6%E4%BE%9D%E7%84%B6%E4%BF%9D%E6%8C%81%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C/"/>
    <id>http://xym-loveit.github.io/2018/04/26/Docker基础-当docker-daemon停止时依然保持容器运行/</id>
    <published>2018-04-26T07:45:28.000Z</published>
    <updated>2018-04-26T07:53:11.270Z</updated>
    
    <content type="html"><![CDATA[<p>默认情况下，当docker daemon停止，它会关闭所有正在运行的容器。从docker1.12起，你可以配置当docker daemon不可用时依然保持容器继续运行。<code>live restore</code>选项有助于减少由于docker daemon崩溃，中断或升级而导致的容器停机时间。</p><blockquote><p>Note: live restore不支持windows容器，但是它支持运行在windows上的linux容器。</p></blockquote><h2 id="开启live-restore选项"><a href="#开启live-restore选项" class="headerlink" title="开启live restore选项"></a>开启live restore选项</h2><p>有两种方式开启<code>live restore</code>:</p><ul><li>如果<code>docker daemon</code>正在运行并且你不想停止它，你可以添加配置到<code>docker daemon</code>的配置文件。例如：在linux系统上默认的配置文件是<code>/etc/docker/daemon.json</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;live-restore&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>你必须传递一个<code>SIGHUP</code>信号给daemon进程来重载配置。更多有关使用config.json来配置docker daemon的信息，可以参考<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file" target="_blank" rel="noopener">daemon configuration file</a></p><ul><li>在使用dockerd启动时指定<code>--live-restore</code>选项<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dockerd --live-restore</span><br></pre></td></tr></table></figure></li></ul><h2 id="升级docker-daemon-时的Live-restore"><a href="#升级docker-daemon-时的Live-restore" class="headerlink" title="升级docker daemon 时的Live restore"></a>升级docker daemon 时的Live restore</h2><p><code>live restore</code>支持当升级<code>docker daemon</code>后，还原容器到docker</p><h2 id="重启时的live-restore"><a href="#重启时的live-restore" class="headerlink" title="重启时的live restore"></a>重启时的live restore</h2><p>live restore只支持还原到和原docker daemon一样的docker daemon。比如：如果新的docker daemon使用不同的网桥IP重新启动，则live restore不起作用。</p><h2 id="live-restore-对正在运行的容器的影响"><a href="#live-restore-对正在运行的容器的影响" class="headerlink" title="live restore 对正在运行的容器的影响"></a>live restore 对正在运行的容器的影响</h2><p>长时间缺少docker daemon可能会影响正在运行的容器。容器写入FIFO日志在daemon消耗时。如果daemon不能用于输出，缓冲区将填满并阻止对日志的进一步写入，因为阻塞该进程直到有更多的可用空间，默认缓冲区大小通常为64K。 你必须重启docker来刷新buffers 你可以修改<code>/proc/sys/fs/pipe-max-size</code>来修改内核buffer 大小</p><h2 id="live-restore-和-swarm-模式"><a href="#live-restore-和-swarm-模式" class="headerlink" title="live restore 和 swarm 模式"></a>live restore 和 swarm 模式</h2><p>live restore 和docker swarm模式不兼容。当docker 运行在swarm模式下时，是由编排功能来管理任务并使容器根据服务规范运行的。</p>]]></content>
    
    <summary type="html">
    
      Docker daemon的 live restore选项配置。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="live restore配置" scheme="http://xym-loveit.github.io/tags/live-restore%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础-docker 环境变量在compose文件中的使用</title>
    <link href="http://xym-loveit.github.io/2018/04/26/Docker%E5%9F%BA%E7%A1%80-docker-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%9C%A8compose%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://xym-loveit.github.io/2018/04/26/Docker基础-docker-环境变量在compose文件中的使用/</id>
    <published>2018-04-26T07:30:25.000Z</published>
    <updated>2018-04-26T07:43:18.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在compose文件中引用环境变量"><a href="#在compose文件中引用环境变量" class="headerlink" title="在compose文件中引用环境变量"></a>在compose文件中引用环境变量</h2><p>可以在compose文件中引用运行<code>docker-compose</code>所在的shell中的环境变量，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">web:</span><br><span class="line">  image: &quot;webapp:$&#123;TAG&#125;&quot;</span><br></pre></td></tr></table></figure></p><h2 id="在容器中设置环境变量"><a href="#在容器中设置环境变量" class="headerlink" title="在容器中设置环境变量"></a>在容器中设置环境变量</h2><p>可以在compose文件中的<code>environment</code>关键字下设置容器的环境变量，就像使用<code>docker run -e VARIABLE=VALUE</code>一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">web:</span><br><span class="line">  environment:</span><br><span class="line">    - DEBUG=1</span><br></pre></td></tr></table></figure></p><h2 id="将环境变量传递到容器"><a href="#将环境变量传递到容器" class="headerlink" title="将环境变量传递到容器"></a>将环境变量传递到容器</h2><p>可以在compose文件中的<code>environment</code>关键字下定义一个环境变量而不是直接赋值，就像是<code>docker run -e VARIABLE</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">web:</span><br><span class="line">  environment:</span><br><span class="line">    - DEBUG</span><br></pre></td></tr></table></figure></p><h2 id="env-file配置选项"><a href="#env-file配置选项" class="headerlink" title="env_file配置选项"></a>env_file配置选项</h2><p>可以使用compose文件中的<code>env_file</code>选项从一个外部文件传递多个环境变量到容器中，就像<code>docker run --env-file=FILE</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">web:</span><br><span class="line">  env_file:</span><br><span class="line">    - web-variables.env</span><br></pre></td></tr></table></figure><p>使用<code>docker-compose run</code>设置环境变量<br>就像<code>docker run -e</code>,可以使用<code>docker-compose run -e</code>为一次性容器设置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose run -e DEBUG=1 web python console.py</span><br></pre></td></tr></table></figure><p>也可以不赋值，直接从shell变量中取值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose run -e DEBUG web python console.py</span><br></pre></td></tr></table></figure></p><p>DEBUG的值是从执行compose文件所在的shell的同一个环境变量取得。</p><h2 id="env文件"><a href="#env文件" class="headerlink" title=".env文件"></a>.env文件</h2><p>可以在环境文件<code>.env</code>设置默认的环境变量，这些环境变量可以在compose文件中调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat .env</span><br><span class="line">TAG=v1.5</span><br><span class="line"></span><br><span class="line">$ cat docker-compose.yml</span><br><span class="line">version: &apos;2.0&apos;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: &quot;webapp:$&#123;TAG&#125;&quot;</span><br></pre></td></tr></table></figure></p><p>当执行<code>docker-compose up</code>命令时，上面定义的web服务将使用<code>webapp:v1.5</code>镜像，可以使用config命令来打印出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose config</span><br><span class="line">version: &apos;2.0&apos;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: &apos;webapp:v1.5&apos;</span><br></pre></td></tr></table></figure><p>在shell中的环境变量将比定义在<code>.env</code>文件中的环境变量优先。如果在shell中设置一个不同的TAG，镜像将优先使用shell中的定义，而不是.evn文件中的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ export TAG=v2.0</span><br><span class="line">$ docker-compose config</span><br><span class="line">version: &apos;2.0&apos;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: &apos;webapp:v2.0&apos;</span><br></pre></td></tr></table></figure><h2 id="使用环境变量来配置compose"><a href="#使用环境变量来配置compose" class="headerlink" title="使用环境变量来配置compose"></a>使用环境变量来配置compose</h2><p>某些环境变量可用来配置以改变<code>docker compose</code>的命令行特性，以<code>COMPOSE_</code>或<code>DOCKER_</code>开头，详细信息参考<a href="https://docs.docker.com/compose/reference/envvars/" target="_blank" rel="noopener">CLI Environment Variables</a></p>]]></content>
    
    <summary type="html">
    
      compose的环境变量的配置和使用。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="compose的环境变量" scheme="http://xym-loveit.github.io/tags/compose%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础-docker在各个平台的基本配置</title>
    <link href="http://xym-loveit.github.io/2018/04/26/Docker%E5%9F%BA%E7%A1%80-docker%E5%9C%A8%E5%90%84%E4%B8%AA%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
    <id>http://xym-loveit.github.io/2018/04/26/Docker基础-docker在各个平台的基本配置/</id>
    <published>2018-04-26T06:13:36.000Z</published>
    <updated>2018-04-26T07:07:15.457Z</updated>
    
    <content type="html"><![CDATA[<p>在安装完<code>docker</code>之后，<code>docker daemon</code>会用默认的配置来运行。</p><p>在生产环境中，系统管理员通常会根据需求来配置<code>docker</code>，在大多数例子中，系统管理员配置会配置进程管理器，如：<code>sysvinit</code>,<code>upstart</code>或<code>systemd</code>来管理<code>docker</code>的启动和停止。</p><h2 id="直接运行docker-daemon"><a href="#直接运行docker-daemon" class="headerlink" title="直接运行docker daemon"></a>直接运行docker daemon</h2><p>我们可以直接用<code>dockerd</code>命令来直接运行<code>docker daemon</code>.默认是监听在<code>unix socket unix:///var/run/docker.sock</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ dockerd</span><br><span class="line"></span><br><span class="line">INFO[0000] +job init_networkdriver()</span><br><span class="line">INFO[0000] +job serveapi(unix:///var/run/docker.sock)</span><br><span class="line">INFO[0000] Listening for HTTP on unix (/var/run/docker.sock)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="直接配置docker-daemon"><a href="#直接配置docker-daemon" class="headerlink" title="直接配置docker daemon"></a>直接配置docker daemon</h2><p>如果你是直接运行<code>dockerd</code>命令，而非使用进程管理器(<code>systemctl start docker</code>)，你可以直接将配置选项附加到<code>docker run</code>命令。其他配置选项可传递给<code>docker daemon</code>来配置 配置选项如下：</p><p><code>| Flag | Description | | :—- | :——— | | -D,–debug=false |</code> 开启或关闭debug模式，默认是关闭的 <code>| | -H,–host=[] | Daemon socket[s]</code>连接到哪 <code>| | –tls=false |</code>开启或关闭TLS，默认是关闭的 | 这里有一个使用配置选项运行<code>docker daemon</code>的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ dockerd -D \</span><br><span class="line">--tls=true \</span><br><span class="line">--tlscert=/var/docker/server.pem \</span><br><span class="line">--tlskey=/var/docker/serverkey.pem \</span><br><span class="line">-H tcp://192.168.59.3:2376</span><br></pre></td></tr></table></figure><p>这些选项是：</p><ul><li>开启<code>debug</code>模式 -D</li><li>开启<code>tls</code>并指定证书 <code>--tlscert</code>和<code>--tlskey</code></li><li>监听连接<code>tcp://192.168.59.3:2376</code></li></ul><p>命令行可参考<a href="https://docs.docker.com/engine/reference/commandline/dockerd/" target="_blank" rel="noopener">complete list of daemon flags</a></p><h2 id="Daemon-debugging"><a href="#Daemon-debugging" class="headerlink" title="Daemon debugging"></a>Daemon debugging</h2><p>如上所诉，开启debug模式来允许管理员或操作者来获取docker daemon运行时的信息。如果面对一个没有响应的daemon，管理员可以通过向Docker daemon发送<code>SIGUSR1</code>信号来强制所有线程的完整堆栈跟踪添加到daemon的日志中。在linux上通常使用kill命令。例：<code>kill -USR1 &lt;daemon-pid&gt;</code>发送<code>SIGUSR1</code>到daemon，这会导致堆栈被添加到daemon日志中。</p><blockquote><p>Note: 日志级别至少是info及以上，默认日志界别是info</p></blockquote><p>在处理<code>SIGUSR1</code>信号并将堆栈跟踪转存到日志后，daemon将继续运行，堆栈跟踪可用于确定daemon所有线程和goroutines的状态</p><h2 id="在centos上配置docker"><a href="#在centos上配置docker" class="headerlink" title="在centos上配置docker"></a>在centos上配置docker</h2><p>在CENTOS 6.X和RHEL 6.X中，我们在<code>/etc/sysconfig/docker</code>文件中配置docker daemon，我们可以通过指定<code>other_args</code>变量来实现。短时间内，在Centos7.x 和RHEL 7.x我们使用<code>OPTIONS</code>变量值，不再推荐直接使用systemd。</p><p>1.登录到你的系统，使用<code>root</code>账户，或者使用<code>sudo</code></p><p>2.创建<code>/etc/systemd/system/docker.service.d</code>目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir /etc/systemd/system/docker.service.d</span><br></pre></td></tr></table></figure><p>3.创建<code>/etc/systemd/system/docker.service.d/docker.conf</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir /etc/systemd/system/docker.service.d/docker.conf</span><br></pre></td></tr></table></figure></p><p>4.打开这个docker.conf文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/systemd/system/docker.service.d/docker.conf</span><br></pre></td></tr></table></figure></p><p>5.覆盖从<code>docker.service</code>文件复制过来的<code>ExecStart</code>，用以自定义<code>docker daemon</code>。要修改<code>ExecStart</code>配置，必须先指定一个空配置，然后再定义一个新配置，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// -D --tls=true --tlscert=/var/docker/server.pem --tlskey=/var/docker/serverkey.pem -H tcp://192.168.59.3:2376</span><br></pre></td></tr></table></figure><p>6.保存关闭文件 </p><p>7.重新载入改变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure></p><p>8.重启docker daemon<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure></p><p>9.检查docker daemon是否运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | grep docker | grep -v grep</span><br></pre></td></tr></table></figure></p><h2 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h2><p>docker 在centos7.x上是将日志保存在<code>/var/log/messages</code> 中的，我们也可以使用<code>journalctl -u docker</code>来查看docker的日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@xym ~]# journalctl -u docker</span><br><span class="line">-- Logs begin at Wed 2018-04-18 13:46:33 CST, end at Thu 2018-04-26 15:01:01 CST. --</span><br><span class="line">Apr 18 13:46:43 xym systemd[1]: Starting Docker Application Container Engine...</span><br><span class="line">Apr 18 13:46:44 xym dockerd[1279]: time=&quot;2018-04-18T13:46:44.353903498+08:00&quot; level=info msg=&quot;libcontainerd: started new docker-containerd process&quot; pid=1364</span><br><span class="line">Apr 18 13:46:44 xym dockerd[1279]: time=&quot;2018-04-18T13:46:44+08:00&quot; level=info msg=&quot;starting containerd&quot; module=containerd revision=89623f28b87a6004d4b785663257362d1658a729 version=v1.0.0</span><br><span class="line">Apr 18 13:46:44 xym dockerd[1279]: time=&quot;2018-04-18T13:46:44+08:00&quot; level=info msg=&quot;setting subreaper...&quot; module=containerd</span><br><span class="line">Apr 18 13:46:44 xym dockerd[1279]: time=&quot;2018-04-18T13:46:44+08:00&quot; level=info msg=&quot;changing OOM score to -500&quot; module=containerd</span><br><span class="line">Apr 18 13:46:44 xym dockerd[1279]: time=&quot;2018-04-18T13:46:44+08:00&quot; level=info msg=&quot;loading plugin &quot;io.containerd.content.v1.content&quot;...&quot; module=containerd type=io.containerd.content.v1</span><br><span class="line">Apr 18 13:46:44 xym dockerd[1279]: time=&quot;2018-04-18T13:46:44+08:00&quot; level=info msg=&quot;loading plugin &quot;io.containerd.snapshotter.v1.btrfs&quot;...&quot; module=containerd type=io.containerd.snapshotter.</span><br><span class="line">Apr 18 13:46:44 xym dockerd[1279]: time=&quot;2018-04-18T13:46:44+08:00&quot; level=warning msg=&quot;failed to load plugin io.containerd.snapshotter.v1.btrfs&quot; error=&quot;path /var/lib/docker/containerd/daemo</span><br><span class="line">Apr 18 1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      docker daemon的生产环境配置注意事项。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="docker daemon配置" scheme="http://xym-loveit.github.io/tags/docker-daemon%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础-docker常用命令</title>
    <link href="http://xym-loveit.github.io/2018/04/26/Docker%E5%9F%BA%E7%A1%80-docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://xym-loveit.github.io/2018/04/26/Docker基础-docker常用命令/</id>
    <published>2018-04-26T03:20:12.000Z</published>
    <updated>2018-04-26T03:58:22.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker-Command"><a href="#Docker-Command" class="headerlink" title="Docker Command"></a>Docker Command</h2><p>介绍一些docker常用的命令</p><h3 id="Docker-container-management"><a href="#Docker-container-management" class="headerlink" title="Docker container management"></a>Docker container management</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#运行容器</span><br><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">  -t 分配一个terminal窗口</span><br><span class="line">  -i 允许和容器进行交互</span><br><span class="line">  -d 后台运行一个容器</span><br><span class="line">  -P 将容器内部的所有exposed的端口映射为宿主机上的随意端口</span><br><span class="line">  -p 将容器内部的端口绑定到宿主机上指定的端口</span><br><span class="line">     后面跟&lt;port&gt; ：表示将容器内部的这个端口隐射到宿主机上的随意端口</span><br><span class="line">     后面跟&lt;port1&gt;:&lt;port2&gt; ：表示将&lt;port2容器内部端口&gt;隐射到&lt;port1宿主机端口&gt;</span><br><span class="line">  --name 为容器命名</span><br><span class="line">  --net 为容器指定网络</span><br><span class="line">  -v 为容器挂载卷组</span><br><span class="line">  --volume-driver 指定容器卷组的驱动</span><br><span class="line"></span><br><span class="line">$ docker run -d -P --name web -v /src/webapp:/webapp training/webapp python app.py</span><br><span class="line">$ docker run -d -P --name web training/webapp python app.py</span><br><span class="line">$ docker run -d -p 80:5000 trainning/webapp python app.py</span><br><span class="line">$ docker run ubuntu /bin/echo &quot;Hello world&quot;</span><br><span class="line">$ docker run -ti ubuntu /bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#启动容器，可同时启动多个容器</span><br><span class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">$ docker start 215b04f73370</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#停止容器运行，可同时停止多个容器</span><br><span class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">$ docker stop 215b04f73370</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#重启重启，可同时重启多个容器</span><br><span class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">$ docker restart 215b04f73370</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#删除容器</span><br><span class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">  -f 强制删除一个正在运行的容器(实际上是先停止容器，然后再删除容器)</span><br><span class="line">  -v 删除和容器关联的卷</span><br><span class="line"></span><br><span class="line">$ docker rm -f 215b04f73370</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#列出容器清单</span><br><span class="line">docker ps [OPTIONS]</span><br><span class="line">  -a 列出所有容器,包括已经停止的容器</span><br><span class="line">  -q 值显示容器ID</span><br><span class="line">  -l 列出最近创建的容器</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#连接到一个正在运行的容器</span><br><span class="line">docker attach [OPTIONS] [CONTAINER]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#在一个已经运行的容器里运行命令</span><br><span class="line">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br><span class="line"></span><br><span class="line">$ docker exec -ti db1 /bin/bash</span><br></pre></td></tr></table></figure><h3 id="Docker-container-state-management"><a href="#Docker-container-state-management" class="headerlink" title="Docker container state management"></a>Docker container state management</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查看容器内部日志</span><br><span class="line">docker logs [OPTIONS] CONTAINER</span><br><span class="line">  -f 容器日志追踪</span><br><span class="line"></span><br><span class="line">$ docker logs grave_roentgen</span><br><span class="line">$ docker logs 20348fdf82e4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查看容器内部运行的进程</span><br><span class="line">docker top CONTAINER</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#获取容器、images、task的配置信息和状态信息</span><br><span class="line">docker inspect [OPTIONS] CONTAINER|IMAGE|TASK [CONTAINER|IMAGE|TASK...]</span><br><span class="line">  -f 按照给定的模板来输出结果</span><br><span class="line"></span><br><span class="line">$ docker inspect -f &apos;&#123; &#123; range .NetworkSettings.Networks &#125; &#125;&#123; &#123; .IPAddress &#125; &#125;&#123; &#123; end &#125; &#125;&apos; romantic_mahavira</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查看容器内公开端口隐射在宿主机上的端口</span><br><span class="line">docker port CONTAINER [PRIVATE_PORT[/PROTO]]</span><br><span class="line"></span><br><span class="line">$ docker port 215b04f73370</span><br></pre></td></tr></table></figure><h3 id="Docker-images-management"><a href="#Docker-images-management" class="headerlink" title="Docker images management"></a>Docker images management</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#列出image清单</span><br><span class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br><span class="line">  -a 显示所有image</span><br><span class="line">  -q 只显示image ID</span><br><span class="line">  --digests 显示摘要信息</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#拉取image镜像</span><br><span class="line">docker pull [OPTIONS] IMAGENAME[:TAG|@DIGEST]</span><br><span class="line">  -a 将所有tag image下载下来</span><br><span class="line">  --disable-content-trust=true 取消检查image</span><br><span class="line"></span><br><span class="line">$ docker pull chinakevinguo/docker-whale:latest</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查找images</span><br><span class="line">docker search [OPTIONS] image</span><br><span class="line"></span><br><span class="line">$ docker search sinatra</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#登录到docke服务器</span><br><span class="line">docker login [OPTIONS] [SERVER]</span><br><span class="line">  -u 用户名</span><br><span class="line">  -p 密码</span><br><span class="line"></span><br><span class="line">$ docker login</span><br><span class="line">Username: chinakevinguo</span><br><span class="line">Password:</span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#将经过修改的容器构建成新的镜像，一般不推荐这种用法</span><br><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line">  -a 作者</span><br><span class="line">  -m 描述</span><br><span class="line"></span><br><span class="line">$ docker commit -m &quot;Added json gem&quot; -a &quot;Kevin Guo&quot; goofy_bohr chinakevinguo/sinatra:v2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#通过dockerfile构建镜像</span><br><span class="line">docker build [OPTIONS] PATH | URL</span><br><span class="line">  -t 指定image的REPOSITORY，可以指定多个REPOSITORY</span><br><span class="line">  -f 指定你的dockerfile的名称路径（默认是$PATH/Dockerfile）</span><br><span class="line"></span><br><span class="line">$ docker build -t chinakevinguo/sinatra:v3  ~/sinatra</span><br><span class="line">$ docker build -t chinakevinguo/sinatra:v3 -f ~/sinatra/mydockerfile .</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#为image打tag，也可以算是为images重命名</span><br><span class="line">docker tag IMAGE[:TAG] IMAGE[:TAG]</span><br><span class="line"></span><br><span class="line">$ docker tag chinakevinguo/sinatrasdfa:v3 chinakevinguo/sinatra:v5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#上传image到dockerHub上</span><br><span class="line">docker push [OPTIONS] NAME[:TAG]</span><br><span class="line"></span><br><span class="line">$ docker push chinakevinguo/docker-whale:latest</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#删除镜像</span><br><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line">  -f 强制删除镜像(实际上是先删除了基于该镜像创建的容器之后再删除的该镜像)</span><br><span class="line">$ docker rmi -f web1</span><br></pre></td></tr></table></figure><h3 id="Docker-network-management"><a href="#Docker-network-management" class="headerlink" title="Docker network management"></a>Docker network management</h3><ul><li>host模式：容器和宿主机共享network namespace</li><li>container模式：容器和另外一个容器共享network namespace。kubernetes中的pod就是多容器共享一个network namespace</li><li>none模式：容器有独立的network namespace，但没有对其进行任何的网络配置</li><li>bridge模式：docker默认模式，容器通过一个网桥获取ip，以NAT的方式和外界通信 </li></ul><p><img src="/assets/img/docker-bridge-module.png" alt="docker网络模型"></p><p>总结一下bridge网络就是：docker会在机器上自己维护一个网络，并通过<code>docker0</code>这个虚拟交换机和主机本身的网络连接在一起</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#docker网络管理</span><br><span class="line">docker network COMMAND</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">  create       创建一个网络</span><br><span class="line">  connect      链接容器到网络</span><br><span class="line">  disconnect   将容器从网络断开</span><br><span class="line">  inspect      显示网络的详细信息</span><br><span class="line">  ls           列出网络</span><br><span class="line">  rm           删除一个或者更多网络</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#创建一个网络</span><br><span class="line">docker network create [OPTIONS] YOURNETWORK</span><br><span class="line">  -d 指定docker使用哪种模式的网络</span><br><span class="line"></span><br><span class="line">$ docker network create -d bridge my-bridge-network</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#将容器从网络断开</span><br><span class="line">docker network disconnect [OPTIONS] NETWORK CONTAINER</span><br><span class="line"></span><br><span class="line">$ docker network disconnect bridge web1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#将容器链接到网络</span><br><span class="line">docker network connect [OPTIONS] NETWORK CONTAINER</span><br><span class="line">  --ip   指定ip地址</span><br><span class="line">  --link 添加连接到其他容器</span><br><span class="line"></span><br><span class="line">$ docker network connect my-bridge-network web1</span><br></pre></td></tr></table></figure><h3 id="Docker-container-volume-management"><a href="#Docker-container-volume-management" class="headerlink" title="Docker container volume management"></a>Docker container volume management</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#docker volume 管理</span><br><span class="line">docker volume COMMAND</span><br><span class="line">  COMMANDS：</span><br><span class="line">    create    创建卷组</span><br><span class="line">    inspect   显示卷组详细信息</span><br><span class="line">    ls        列出卷组</span><br><span class="line">    rm        删除卷组</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#为容器挂载卷组</span><br><span class="line">$ docker run -d -P --name web -v /src/webapp:/webapp training/webapp python app.py</span><br></pre></td></tr></table></figure><p>这个命令是将宿主机上的/src/webapp挂载到容器的/webapp，如果/webapp存在，则/src/webapp会覆盖挂载，但是不会删除以前的内容，取消此次挂载后，以前的内容又可以访问了。 容器内部的目录必须指定绝对路径，而宿主机上的目录即可以是绝对路径，也可以仅仅是一个名字或者什么都不写，如果只是一个名字$NAME，则会默认挂载到<code>/var/lib/docker/volumes/$NAME/_data</code>，如果什么都不写，则会挂载到<code>/var/lib/docker/volumes/</code>下的一个随机生成的字符串下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#不指定名字，默认挂载</span><br><span class="line">$ docker run -d -P --name web -v /webapp training/webapp python app.py</span><br><span class="line"></span><br><span class="line">$ docker inspect web</span><br><span class="line">&quot;Name&quot;: &quot;fac362...80535&quot;,</span><br><span class="line">&quot;Source&quot;: &quot;/var/lib/docker/volumes/fac362...80535/_data&quot;,</span><br><span class="line">&quot;Destination&quot;: &quot;/webapp&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#仅仅指定名字</span><br><span class="line">$ docker run -d -P --name web -v webapp:/webapp training/webapp python app.py</span><br><span class="line"></span><br><span class="line">$ docker inspect web</span><br><span class="line">&quot;Name&quot;: &quot;webapp&quot;,</span><br><span class="line">&quot;Source&quot;: &quot;/var/lib/docker/volumes/webapp/_data&quot;,</span><br><span class="line">&quot;Destination&quot;: &quot;/webapp&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#指定绝对路径</span><br><span class="line">$ docker run -d -P --name web -v /src/webapp:/webapp training/webapp python app.py</span><br><span class="line"></span><br><span class="line">$ docker inspect web</span><br><span class="line">&quot;Source&quot;: &quot;/src/webapp&quot;,</span><br><span class="line">&quot;Destination&quot;: &quot;/webapp&quot;,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#挂载共享卷组作为数据卷</span><br><span class="line">$ docker run -d -P --volume-driver=flocker -v my-named-volume:/webapp --name web training/webapp python app.py</span><br><span class="line"></span><br><span class="line">#先创建共享卷组，然后再进行挂载</span><br><span class="line">$ docker volume create -d flocker -o size-20GB my-named-volume</span><br><span class="line">$ docker run -d -P -v my-named-volume:/webapp --name web training/webapp python app.py</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#将容器作为卷组挂载进容器</span><br><span class="line"></span><br><span class="line">#创建一个卷组容器</span><br><span class="line">$ docker create -v /dbdata --name dbstore training/postgres /bin/true</span><br><span class="line"></span><br><span class="line">#使用--volumes-from 将dbdata挂载进其他容器</span><br><span class="line">$ docker run -d --volumes-from dbstore --name db1 training/postgres</span><br><span class="line">$ docker run -d --volumes-from dbstore --name db2 training/postgres</span><br></pre></td></tr></table></figure><h3 id="Backup，restore，migrate-data-volumes"><a href="#Backup，restore，migrate-data-volumes" class="headerlink" title="Backup，restore，migrate data volumes"></a>Backup，restore，migrate data volumes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#将卷组容器挂载到对应的容器之后，进行卷组数据备份</span><br><span class="line">$ docker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#数据恢复</span><br><span class="line">$ docker run -v /dbdata --name dbstore2 ubuntu /bin/bash</span><br><span class="line">$ docker run --rm --volumes-from dbstore2 -v $(pwd):/backup ubuntu bash -c &quot;cd /dbdata &amp;&amp; tar xvf /backup/backup.tar --strip 1&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在使用--rm的时候，会删除匿名卷组，而不会删除定义好的命名卷组</span><br><span class="line">$ docker run --rm -v /foo -v awesome:/bar busybox top</span><br></pre></td></tr></table></figure><p><strong>所谓匿名卷组：即那些指定了路径和那些没有指定命名的挂载项目</strong></p>]]></content>
    
    <summary type="html">
    
      docker常用命令详解。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="docker容器管理" scheme="http://xym-loveit.github.io/tags/docker%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/"/>
    
      <category term="docker容器状态" scheme="http://xym-loveit.github.io/tags/docker%E5%AE%B9%E5%99%A8%E7%8A%B6%E6%80%81/"/>
    
      <category term="docker镜像管理" scheme="http://xym-loveit.github.io/tags/docker%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/"/>
    
      <category term="docker网络管理" scheme="http://xym-loveit.github.io/tags/docker%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
    
      <category term="docker容器卷管理" scheme="http://xym-loveit.github.io/tags/docker%E5%AE%B9%E5%99%A8%E5%8D%B7%E7%AE%A1%E7%90%86/"/>
    
      <category term="docker数据备份及恢复" scheme="http://xym-loveit.github.io/tags/docker%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E5%8F%8A%E6%81%A2%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>使用 Docker 安装 Jenkins</title>
    <link href="http://xym-loveit.github.io/2018/04/25/%E4%BD%BF%E7%94%A8-Docker-%E5%AE%89%E8%A3%85-Jenkins/"/>
    <id>http://xym-loveit.github.io/2018/04/25/使用-Docker-安装-Jenkins/</id>
    <published>2018-04-25T03:14:57.000Z</published>
    <updated>2018-04-25T03:25:56.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>jenkins是一个用Java编写的开源自动化服务器,它是Hudson的一个分支project ; 它是一个持续集成软件(continuous integration),它以节点为单位,连接整个工作流, 通过各种类型插件支持构成具有个性化要求的项目持续集成, 通过各种各样的插件(plugin)来实现各个节点的功能, 它们共同完成持续集成(自动部署)/自动测试或者持续交付等工作.</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1、直接从 DockerHub 上pull 镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull jenkins</span><br></pre></td></tr></table></figure></p><p>2、由于 Jenkins 容器运行后，会自动在宿主计算机中挂在一个数据卷 <code>var/jenkins_home</code>，我们在主机中可以新建一个数据卷的文件夹，这里注意的是，有权限问题，不然会启动失败，有点坑这里，卡了半天，给宿主的这个挂载卷目录中加上下面的权限的就好了，改成为uid 1000的用户，具体参考阿里云<a href="https://yq.aliyun.com/articles/53990" target="_blank" rel="noopener">谈谈 Docker Volume 之权限管理（一）</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R 1000 /var/jenkins_home</span><br></pre></td></tr></table></figure></p><p>3、启动容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 7322:8080 -p 50000:50000 -v /var/jenkins_home/:/var/jenkins_home/  --name my_jenkins -d jenkins</span><br></pre></td></tr></table></figure></p><ul><li>8080 端口是访问 jenkins 网页的端口，如果你想在 80 端口访问，就改成 -p 80:8080</li><li>50000 端口与 slave 有关，主要作为master的jenkins用来连接slave的。</li></ul><p>可以更改挂载卷的目录，不过记得也要设置目录权限的问题。</p><p>使用 <code>docker ps</code> 查看运行的容器。</p><h2 id="配置和使用"><a href="#配置和使用" class="headerlink" title="配置和使用"></a>配置和使用</h2><p>1、使用 host + port 访问 jenkins，会进入第一个页面：</p><p><img src="http://op7wplti1.bkt.clouddn.com/install_Jenkins.png" alt="Jenkins安装"></p><p>因为我们将目录<code>/var/jenkins_home</code>已经挂载在宿主主机，可以直接去这个目录查看密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> cat /var/jenkins_home/secrets/initialAdminPassword</span><br><span class="line">c49d4a7883e1410685c45092a6fabeac</span><br></pre></td></tr></table></figure></p><p>2、进入后就开始安装插件的过程，然后等待安装完成。</p><p>3、然后跳出一个页面设置账号和密码，这样就安装完成，后面学习使用 jenkins 运用到工作中。</p>]]></content>
    
    <summary type="html">
    
      Docker安装Jenkins简单步骤。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker安装Jenkins" scheme="http://xym-loveit.github.io/tags/Docker%E5%AE%89%E8%A3%85Jenkins/"/>
    
      <category term="Jenkins" scheme="http://xym-loveit.github.io/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>为Docker镜像添加SSH服务</title>
    <link href="http://xym-loveit.github.io/2018/04/20/%E4%B8%BADocker%E9%95%9C%E5%83%8F%E6%B7%BB%E5%8A%A0SSH%E6%9C%8D%E5%8A%A1/"/>
    <id>http://xym-loveit.github.io/2018/04/20/为Docker镜像添加SSH服务/</id>
    <published>2018-04-20T08:01:19.000Z</published>
    <updated>2018-04-22T10:45:00.593Z</updated>
    
    <content type="html"><![CDATA[<p>一些进入容器的办法，比如<code>attach</code>、<code>exec</code>等命令，都无法解决远程管理容器的问题。因此，当我们需要远程登录到容器内进行一些操作的时候，就需要<code>SSH</code>的支持了。</p><p>有两种创建带有SSH服务的镜像：基于<code>Docker commit</code>命令创建和基于<code>Dockerfile</code>创建。</p><h2 id="基于commit命令创建"><a href="#基于commit命令创建" class="headerlink" title="基于commit命令创建"></a>基于commit命令创建</h2><p>Docker提供了<code>docker commit</code>命令，支持用户提交自己对制定容器的修改，并生产新的镜像。<br>命令格式：<code>docker commit CONTAINER[REPOSITORY:[:TAG]]</code></p><h3 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h3><p>首先，使用<code>ubuntu:14.04</code>镜像来创建容器：<br><code>docker run -it ubuntu:14.04 /bin/bash</code><br>更新<code>apt</code>缓存，并安装<code>openssh-server</code><br><code>apt-get update;apt-get install -y openssh-server</code></p><h3 id="2、安装和配置SSH服务"><a href="#2、安装和配置SSH服务" class="headerlink" title="2、安装和配置SSH服务"></a>2、安装和配置SSH服务</h3><p>如果需要正常启动SSH服务，则目录<code>/var/run/sshd</code>必须存在，手动创建它，并启动SSH服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /var/run/sshd</span><br><span class="line">/usr/sbin/sshd -D &amp;</span><br></pre></td></tr></table></figure></p><p>此时查看容器的22端口（ssh服务默认监听端口），可见此端口已经处于监听状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -tlnp</span><br><span class="line">//修改SSH服务的安全登录配置，取消pam登录限制</span><br><span class="line">sed -ri &apos;s/session required pam_loginuid.so/#session required pam_loginuid.so/g` /etc/pam.d/sshd</span><br></pre></td></tr></table></figure></p><p>在root用户目录下创建<code>.ssh</code>目录，并复制需要登录的公钥信息（一般为本地主机目录下的<code>.ssh/id_rsa.pub</code>文件，可由<code>ssh-keygen -t rsa</code>命令生成）到<code>authorized_keys</code>文件中。</p><p>创建自动启动SSH服务的可执行文件<code>run.sh</code>。并添加可执行权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /run.sh</span><br><span class="line">chmod +x run.sh</span><br></pre></td></tr></table></figure></p><p>其中，<code>run.sh</code>脚本内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">/usr/sbin/sshd -D</span><br></pre></td></tr></table></figure></p><p>最后，退出容器执行，<code>exit</code>命令。</p><h3 id="3、保存镜像"><a href="#3、保存镜像" class="headerlink" title="3、保存镜像"></a>3、保存镜像</h3><p><code>docker commit [OPTIONS]  CONTAINER [REPOSITORY[:TAG]]</code></p><h3 id="4、使用镜像"><a href="#4、使用镜像" class="headerlink" title="4、使用镜像"></a>4、使用镜像</h3><p>启动容器，并添加端口映射<code>10022--&gt;22</code>。其中10022是宿主主机的端口，22是容器的SSH服务端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//启动容器</span><br><span class="line">docker run -p 10022:22 -d sshd:ubuntu /run.sh </span><br><span class="line">//查看运行进程</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure></p><p>在宿主主机（<code>192.168.1.200</code>）或其他主机上，可以通过<code>SSH</code>访问10022端口来登录容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 192.168.1.200 -p 10022</span><br></pre></td></tr></table></figure></p><h2 id="使用Dockerfile创建"><a href="#使用Dockerfile创建" class="headerlink" title="使用Dockerfile创建"></a>使用Dockerfile创建</h2><h3 id="1、创建工作目录"><a href="#1、创建工作目录" class="headerlink" title="1、创建工作目录"></a>1、创建工作目录</h3><p>创建一个<code>ssh_ubuntu</code>目录,<code>mkdir ssh_ubuntu</code>,并在其中创建<code>Dockerfile</code>和<code>run.sh</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch Dockerfile run.sh</span><br></pre></td></tr></table></figure></p><h3 id="2、编写run-sh脚本和authorized-keys文件"><a href="#2、编写run-sh脚本和authorized-keys文件" class="headerlink" title="2、编写run.sh脚本和authorized_keys文件"></a>2、编写<code>run.sh</code>脚本和<code>authorized_keys</code>文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">/usr/sbin/sshd -D</span><br></pre></td></tr></table></figure><p>在宿主主机上生成SSH秘钥对，并创建<code>authorized_keys</code>文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt; authorized_keys</span><br></pre></td></tr></table></figure></p><h3 id="3、编写Dockerfile"><a href="#3、编写Dockerfile" class="headerlink" title="3、编写Dockerfile"></a>3、编写Dockerfile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#设置基础镜像</span><br><span class="line">FROM ubuntu:14.04</span><br><span class="line">#提供作者信息</span><br><span class="line">LABEL author=&quot;xym&quot; author_email=&quot;xym@126.com&quot;</span><br><span class="line">#更新命令</span><br><span class="line">RUN apt-get update</span><br><span class="line">#安装SSH服务</span><br><span class="line">RUN apt-get install -y openssh-server</span><br><span class="line">RUN mkdir -p /var/run/sshd</span><br><span class="line">RUN mkdir -p /root/.ssh</span><br><span class="line">#取消pam限制</span><br><span class="line">RUN sed -ri &apos;s/session required pam_loginuid.so/#session required pam_loginuid.so/g&apos; /etc/pam.d/sshd </span><br><span class="line">#复制配置文件到相应位置，并赋予脚本可执行权限</span><br><span class="line">ADD authorized_keys /root/.ssh/authorized_keys</span><br><span class="line">ADD run.sh /run.sh</span><br><span class="line">RUN chmod 755 run.sh</span><br><span class="line">#开放端口</span><br><span class="line">EXPOSE 22</span><br><span class="line">#设置自启动命令</span><br><span class="line">CMD [&quot;/run.sh&quot;]</span><br></pre></td></tr></table></figure><h3 id="4、创建镜像xd"><a href="#4、创建镜像xd" class="headerlink" title="4、创建镜像xd"></a>4、创建镜像xd</h3><p>在ssh_ubuntu目录下，使用<code>docker build</code>命令来创建镜像，这里注意还有一个”.”，表示使用当前目录中的<code>Dockerfile</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ssh_ubuntu</span><br><span class="line">docker build -t sshd:Dockerfile .</span><br></pre></td></tr></table></figure></p><h3 id="5、测试镜像，运行容器"><a href="#5、测试镜像，运行容器" class="headerlink" title="5、测试镜像，运行容器"></a>5、测试镜像，运行容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//启动镜像，映射容器22端口到本地的10122端口</span><br><span class="line">docker run -d -p 10122:22 sshd:Dockerfile</span><br><span class="line">//在宿主主机新打开一个终端，连接到新建的容器</span><br><span class="line">ssh 192.168.1.200 -p 10122</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Docker镜像添加SSH服务支持。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Dockerfile创建SSH服务" scheme="http://xym-loveit.github.io/tags/Dockerfile%E5%88%9B%E5%BB%BASSH%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Commit容器创建SSH服务" scheme="http://xym-loveit.github.io/tags/Commit%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BASSH%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>使用Dockerfile创建镜像</title>
    <link href="http://xym-loveit.github.io/2018/04/20/%E4%BD%BF%E7%94%A8Dockerfile%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/"/>
    <id>http://xym-loveit.github.io/2018/04/20/使用Dockerfile创建镜像/</id>
    <published>2018-04-20T02:18:05.000Z</published>
    <updated>2018-04-20T07:33:09.319Z</updated>
    
    <content type="html"><![CDATA[<p><code>Dockerfile</code>是一个文本格式的配置文件，用户可以使用<code>Dockerfile</code>来快速创建自定义的镜像。</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p><code>Dockerfile</code>由一行行命令语句组成，并且支持以<code>#</code>开头的注释行。<br>一般而言，<code>Dockerfile</code>分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#一个nginx dockerfile例子</span><br><span class="line">#基础镜像</span><br><span class="line">FROM ubuntu</span><br><span class="line">#维护者信息</span><br><span class="line">MAINTAINER xym xym@126.com</span><br><span class="line">#镜像操作指令</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y nginx</span><br><span class="line">RUN echo &quot;daemon off;&quot; &gt; /etc/nginx/nginx.conf</span><br><span class="line">#容器启动时执行指令</span><br><span class="line">CMD /usr/sbin/nginx</span><br></pre></td></tr></table></figure></p><p>其中一开始必须指明所基于的镜像名称，接下来一般是说明维护信息。后面则是镜像操作指令，例如RUN指令，RUN指令将对镜像执行跟随的命令。每运行一条RUN指令，镜像就添加新的一层，并提交。最后是CMD指令，用来指定运行容器时的操作命令。</p><h2 id="指令说明"><a href="#指令说明" class="headerlink" title="指令说明"></a>指令说明</h2><p>指令的一般格式为<code>INSTRUCTION arguments</code>，指令包括<code>FROM</code>、<code>MAINTAINER</code>、<code>RUN</code>等。</p><p><img src="http://op7wplti1.bkt.clouddn.com/1900654235_8b1-i_epub.jpg" alt="http://op7wplti1.bkt.clouddn.com/1900654235_8b1-i_epub.jpg"></p><p><img src="http://op7wplti1.bkt.clouddn.com/1900654235_8b1x-i_epub.jpg" alt="http://op7wplti1.bkt.clouddn.com/1900654235_8b1x-i_epub.jpg"></p><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>指定所创建镜像的基础镜像，如果本地不存在，则默认会去<code>Docker Hub</code>下载指定镜像。</p><p>命令格式：<code>FROM &lt;image&gt;</code> or <code>FROM &lt;image&gt;:&lt;tag&gt;</code> or <code>FROM &lt;image&gt;@&lt;digest&gt;</code></p><p>任何<code>Dockerfile</code>中的第一条指令必须为FROM指令。并且，如果在同一个<code>Dockerfile</code>中创建多个镜像，可以使用多个FROM指令（每个镜像一次）。 </p><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>指定维护者信息，格式为 <code>MAINTAINER &lt;name&gt;</code>。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER  image_creator@docker.com</span><br></pre></td></tr></table></figure></p><p>该信息会写入生成镜像的Author属性域中，可以使用 <code>docker inspect imageName/imageId</code>查看。 </p><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>运行指定命令，格式为：<code>RUN &lt;command&gt;</code> 或 <code>RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code>。注意，后一个指令会被解析为<code>json</code>数组，因此必须使用双引号。</p><p>前者默认将在<code>shell</code>终端中运行命令，即<code>/bin/sh-c</code>;后者则使用<code>exec</code>执行，不会启动shell环境。<br>指定使用其他终端类型可以使用第二种方式实现，例如：<code>RUN [&quot;bin/bash&quot;,&quot;-c&quot;,&quot;echo hello&quot;]</code>。</p><p>每条RUN指令将在当前镜像的基础上执行指定指令，并提交为新的镜像。当命令较长时可以使用”\”来换行。</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>CMD指令用来指定启动容器时默认执行的命令。它支持三种格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//使用exec执行，是推荐的使用方式</span><br><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line"></span><br><span class="line">//在/bin/sh中执行，提供给需要交互的应用</span><br><span class="line">CMD command param1 param2</span><br><span class="line"></span><br><span class="line">//提供给ENTRYPOINT的默认参数</span><br><span class="line">CMD [&quot;param1&quot;,&quot;param2&quot;]</span><br></pre></td></tr></table></figure></p><p>每个<code>Dockerfile</code>只能有一条CMD命令，如果指定了多条命令，只有最后一条会被执行。<br>如果用户启动容器时手动指定了运行的命令（作为run的参数），则会覆盖掉CMD指定的命令。</p><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>LABEL指令用来指定生成镜像的元数据标签信息。<br>命令格式：<code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt;...</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL author=&quot;xym&quot; author_email=xxx@126.com</span><br></pre></td></tr></table></figure></p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>声明镜像内的服务所监听的端口。</p><p>命令格式：<code>EXPOSE &lt;port&gt;[&lt;port&gt;...]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 22 80 8443</span><br></pre></td></tr></table></figure></p><p>该命令只是起到声明作用，并不会自动完成端口映射。在启动容器时需要使用<code>-P</code>，Docker主机会自动分配一个宿主机的临时端口转发到指定的端口；使用<code>-p</code>，则可以具体指定哪个宿主机的本地端口会映射过来。</p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>指定环境变量，在镜像生成过程中会被后续RUN指令使用，在镜像启动的容器中也会存在。</p><p>命令格式：<code>ENV &lt;key&gt; &lt;value&gt;</code> or <code>ENV &lt;key&gt;=&lt;value&gt;</code></p><p>指令指定的环境变量在运行中可以被覆盖掉，如<code>docker run --env &lt;key&gt;=&lt;value&gt; built_image</code></p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>该命令将复制指定的<code>&lt;src&gt;</code>路径下的内容到容器中的<code>&lt;dest&gt;</code>路径下。</p><p>命令格式：<code>ADD &lt;src&gt; &lt;dest&gt;</code></p><p>其中<code>&lt;src&gt;</code>可以是<code>Dockerfile</code>所在目录的一个相对路径（文件或目录），也可以是一个URL，还可以是一个tar文件（如果为<code>tar</code>文件，会自动解压到<code>&lt;dest&gt;</code>路径下）。<code>&lt;dest&gt;</code>可以是镜像内的路径，或者相对于工作目录（<code>WORKDIR</code>）的相对路径。</p><p>路径支持正则格式：<code>ADD *.c /code/</code></p><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>格式为<code>COPY &lt;src&gt; &lt;dest&gt;</code></p><p>复制本地主机的<code>&lt;src&gt;</code>（为<code>Dockerfile</code>所在目录的相对路径、文件或者目录）下的内容到镜像中的<code>&lt;dest&gt;</code>下。目标路径不存在时，会自动创建。路径同样支持正则表达式。当使用本地目录为源目录时，推荐使用<code>COPY</code>。</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>指定镜像的默认入口命令，该入口命令会在启动容器时作为根命令执行，所有传入值作为该命令的参数。<br>支持两种格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]（exec调用执行）</span><br><span class="line">ENTRYPOINT command param1 param2（shell中执行）</span><br></pre></td></tr></table></figure></p><p>此时，<code>CMD</code>指令指定值将作为根命令的参数。<br>每个Dockerfile中只能有一个<code>ENTRYPOINT</code>，当指定多个时，只有最后一个有效。在运行时，可以被<code>--entrypoint</code>参数覆盖掉，如<code>docker run --entrypoint</code></p><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>创建一个数据卷挂载点。格式为<code>VOLUME [&quot;/data&quot;]</code>，可以从本地主机或其他容器挂载数据卷，一般用来存放数据库和需要保存的数据等。</p><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>指定运行容器时的用户名和UID，后续的RUN等指令也会使用指定的用户身份。<br>格式为：<code>USER daemon</code></p><p>当服务不需要管理员权限时，可以通过该命令指定运行用户，并且可以在之前创建所需要的用户。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</span><br></pre></td></tr></table></figure></p><p>要临时获取管理员权限可以使用<code>gosu</code>或<code>sudo</code></p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>为后续的<code>RUN/CMD/ENTRYPOINT</code>指令配置工作目录。</p><p>格式为：<code>WORKDIR /path/to/workdir</code><br>可以使用多个<code>WORKDIR</code>指令，后续命令如果参数是相对路径，后续命令如果是相对路径，则会基于之前命令指定的路径。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure></p><p>则最终路径为<code>/a/b/c</code></p><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>指定一些镜像内使用的的参数（例如版本号信息等），这些参数在执行<code>docker build</code>命令时以<code>--build-arg&lt;varname&gt;=&lt;value&gt;</code>格式传入。格式为<code>ARG &lt;name&gt;=[&lt;default value&gt;]</code>，则可以用<code>docker build --build-arg &lt;name&gt;=&lt;value&gt; .</code>来指定参数值。</p><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>配置当所创建的镜像作为其他镜像的基础镜像时，所执行的创建操作指令。格式为：<code>ONBUILD [INSTRUCTION]</code></p><p>例如：Dockerfile使用了如下的内容创建了镜像<code>image-A</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[...]</span><br><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>如果基于<code>image-A</code>创建新的镜像时，新的Dockerfile中使用<code>FROM image-A</code>指定基础镜像，会自动执行<code>ONBUILD</code>指令的内容，等价于在后面添加了两条指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">FROM image-A</span><br><span class="line">#自动执行onbuild指定的命令</span><br><span class="line">ADD . /app/src</span><br><span class="line">RUN /usr/local/bin/python-build --dir /app/src</span><br></pre></td></tr></table></figure><p>使用<code>ONBUILD</code>指令的镜像，推荐在标签中注明，例如：<code>ruby:1.9-onbuild</code></p><h3 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h3><p>指定所创建镜像启动的容器接受退出的信号值，例如：<br><code>STOPSIGNAL signal</code></p><h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p>配置所启动容器如何进行健康检查（如何判断健康与否），自Docker1.12开始支持。</p><p>格式有两种：</p><p><code>HEALTHCHECK [OPTIONS] CMD command</code></p><p>根据所执行命令返回值是否为0来判断；<br><code>HEALTHCHECK NONE</code>禁止基础镜像中的健康检查。</p><p>OPTIONS支持：</p><ul><li>–interval=DURATION（默认为30s）：过多久检查一次；</li><li>–timeout=DURATION（默认为30s）：每次检查等待结果的超时；</li><li>–retries=N（默认为3）：如果失败了，重试几次才最终确定失败。</li></ul><h3 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h3><p>指定其他命令使用<code>shell</code>时的默认shell类型。默认值为<code>[&quot;/bin/sh&quot;,&quot;-c&quot;]</code></p><p>注意：对于<code>Windows</code>系统，建议在Dockerfile开头添加<code>#escape=</code>来指定转义信息。</p><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>编写完成<code>Dockerfile</code>之后，可以通过<code>docker build</code>命令来创建镜像。基本格式为<code>docker build [选项] 内容路径</code>，该命令将读取指定路径下（包括子目录）的Dockerfile，并将该路径下的所有内容发送给Docker服务端，由服务端来创建镜像。因此除非生成镜像需要，否则一般建议放置Dockerfile的目录为空目录。有两点经验：</p><ul><li>如果使用非内容路径下的Dockerfile，可以通过-f选项来指定其路径</li><li>要指定生成镜像的标签信息，可以使用-t选项</li></ul><p>例如，指定Dockerfile所在路径为<code>/tmp/docker_builder/</code>,并且希望生成镜像标签为<code>build_repo/first_image</code>,可以使用下面命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t build_repo/first_image /tmp/docker_builder/</span><br></pre></td></tr></table></figure></p><h2 id="使用-dockerignore文件"><a href="#使用-dockerignore文件" class="headerlink" title="使用.dockerignore文件"></a>使用.dockerignore文件</h2><p>可以通过<code>.dockerignore</code>文件（每一行添加一条匹配模式）来让<code>Docker</code>忽略匹配模式路径下的目录和文件。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#comment</span><br><span class="line">*/temp*</span><br><span class="line">*/*/temp*</span><br><span class="line">tmp?</span><br><span class="line">~*</span><br></pre></td></tr></table></figure></p><h2 id="编写Dockerfile的指导原则"><a href="#编写Dockerfile的指导原则" class="headerlink" title="编写Dockerfile的指导原则"></a>编写Dockerfile的指导原则</h2><ul><li>精简镜像用途：尽量让每个镜像的用途都比较集中、单一，避免构造大而复杂，多功能的镜像；</li><li>选用合适的基础镜像：过大的基础镜像会造成生成臃肿的镜像，一般推荐较为小巧的<code>debian</code>镜像；</li><li>提供足够清晰的命令注释和维护者信息：Dockerfile也是一种代码，需要考虑方便后续扩展和他人使用；</li><li>正确使用版本：使用明确的版本号信息，如：1.0，2.0而非latest，将避免内容不一致可能引发的惨案；</li><li>减少镜像层数：如果希望所生成镜像的层数尽量少，则要尽量合并指令，例如多个RUN指令可以合并为一条；</li><li>及时删除临时文件和缓存文件：特别是在执行apt-get指令后，/var/cache/apt/下面会缓存一些安装包；</li><li>提高生成速度：如合理使用缓存，减少内容目录下的文件，或使用<code>.dockerignore</code>文件指定等。</li><li>调整合理的指令顺序：在开启缓存的情况下，内容不变的指令尽量放在前面，这样可以尽量复用</li><li>减少外部源的干扰：如果确实要从外部引入数据，需要指定持久地址，并带有版本信息，让他人可以重复而不出错</li></ul><h2 id="优良的镜像"><a href="#优良的镜像" class="headerlink" title="优良的镜像"></a>优良的镜像</h2><h3 id="BUSYBOX"><a href="#BUSYBOX" class="headerlink" title="BUSYBOX"></a>BUSYBOX</h3><p>BusyBox是一个集成了100多个最常见的<code>Liunx</code>命令和工具（如：cat/echo/grep/mount/telnet等）的精简工具箱。它只有几MB的大小，很方便进行各种快速验证，被誉为“Linux系统的瑞士军刀”。BusyBox可以运行于多款POSIX环境的操作系统中，如Liunx（包括Andrid）、Hurd、FreeBSD等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//查询busybox镜像</span><br><span class="line">docker search busybox</span><br><span class="line"></span><br><span class="line">//下载busybox镜像</span><br><span class="line">docker pull busybox</span><br><span class="line"></span><br><span class="line">//使用busybox创建容器</span><br><span class="line">docker run -it --name my_busybox busybox</span><br></pre></td></tr></table></figure><h3 id="Alpine"><a href="#Alpine" class="headerlink" title="Alpine"></a>Alpine</h3><p>Alpine操作系统是一个面向安全的轻型Linux发行版。Alpine是由非商业组织维护的支持广泛场景的Linux发行版，它特别为资深/重度Liunx用户而优化，关注安全、性能和资源效能。Alpine镜像适用于更多常用场景，并且是一个优秀的可以适用于生产的基础环境。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//查询busybox镜像</span><br><span class="line">docker search alpine</span><br><span class="line"></span><br><span class="line">//下载busybox镜像</span><br><span class="line">docker pull alpine</span><br><span class="line"></span><br><span class="line">//使用busybox创建容器</span><br><span class="line">docker run -it --name my_alpine alpine</span><br></pre></td></tr></table></figure><h3 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian/Ubuntu"></a>Debian/Ubuntu</h3><h3 id="CentOS-Fedora"><a href="#CentOS-Fedora" class="headerlink" title="CentOS/Fedora"></a>CentOS/Fedora</h3>]]></content>
    
    <summary type="html">
    
      Dockerfile基础介绍。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Dockerfile命令" scheme="http://xym-loveit.github.io/tags/Dockerfile%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Docker镜像构建文件Dockerfile及相关命令介绍</title>
    <link href="http://xym-loveit.github.io/2018/04/19/Docker%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E6%96%87%E4%BB%B6Dockerfile%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/"/>
    <id>http://xym-loveit.github.io/2018/04/19/Docker镜像构建文件Dockerfile及相关命令介绍/</id>
    <published>2018-04-19T07:22:20.000Z</published>
    <updated>2018-04-19T08:41:24.476Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>docker build</code>命令或使用<code>Docker Hub</code>的自动构建功能构建Docker镜像时，都需要一个<code>Dockerfile</code>文件。<code>Dockerfile</code>文件是一个由一系列构建指令组成的文本文件，<code>docker build</code>命令会根据这些构建指令完成<code>Docker</code>镜像的构建。本文将会介绍<code>Dockerfile</code>文件，及其中使用的构建指令。</p><h2 id="Dockerfile文件使用"><a href="#Dockerfile文件使用" class="headerlink" title="Dockerfile文件使用"></a>Dockerfile文件使用</h2><p><code>docker build</code>命令会根据<code>Dockerfile</code>文件及上下文构建新<code>Docker镜像</code>。构建上下文是指Dockerfile所在的本地路径或一个URL（Git仓库地址）。构建上下文环境会被递归处理，所以，构建所指定的路径还包括了子目录，而URL还包括了其中指定的子模块。</p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>将当前目录做为构建上下文时，可以像下面这样使用docker build命令构建镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build .</span><br><span class="line">Sending build context to Docker daemon  6.51 MB</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>说明：构建会在Docker后台守护进程（daemon）中执行，而不是<code>CLI</code>中。构建前，构建进程会将全部内容（递归）发送到守护进程。大多情况下，应该将一个空目录作为构建上下文环境，并将<code>Dockerfile</code>文件放在该目录下。</p><p>在构建上下文中使用的<code>Dockerfile</code>文件，是一个构建指令文件。为了提高构建性能，可以通过<code>.dockerignore</code>文件排除上下文目录下，不需要的文件和目录。</p><p><code>Dockerfile</code>一般位于构建上下文的根目录下，也可以通过<code>-f</code>指定该文件的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -f /path/to/a/Dockerfile .</span><br></pre></td></tr></table></figure><p>构建时，还可以通过-t参数指定构建成后，镜像的仓库、标签等：</p><h3 id="镜像标签"><a href="#镜像标签" class="headerlink" title="镜像标签"></a>镜像标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t shykes/myapp .</span><br></pre></td></tr></table></figure><p>如果存在多个仓库下，或使用多个镜像标签，就可以使用多个<code>-t</code>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .</span><br></pre></td></tr></table></figure><p>在Docker守护进程执行<code>Dockerfile</code>中的指令前，首先会对<code>Dockerfile</code>进行语法检查，有语法错误时会返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t test/myapp .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Error response from daemon: Unknown instruction: RUNCMD</span><br></pre></td></tr></table></figure><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>Docker 守护进程会一条一条的执行<code>Dockerfile</code>中的指令，而且会在每一步提交并生成一个新镜像，最后会输出最终镜像的ID。生成完成后，Docker 守护进程会自动清理你发送的上下文。</p><p><code>Dockerfile</code>文件中的每条指令会被独立执行，并会创建一个新镜像，<code>RUN cd /tmp</code>等命令不会对下条指令产生影响。</p><p>Docker 会重用已生成的中间镜像，以加速<code>docker build</code>的构建速度。以下是一个使用了缓存镜像的执行过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t svendowideit/ambassador .</span><br><span class="line">Sending build context to Docker daemon 15.36 kB</span><br><span class="line">Step 1/4 : FROM alpine:3.2</span><br><span class="line"> ---&gt; 31f630c65071</span><br><span class="line">Step 2/4 : MAINTAINER SvenDowideit@home.org.au</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 2a1c91448f5f</span><br><span class="line">Step 3/4 : RUN apk update &amp;&amp;      apk add socat &amp;&amp;        rm -r /var/cache/</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 21ed6e7fbb73</span><br><span class="line">Step 4/4 : CMD env | grep _TCP= | (sed &apos;s/.*_PORT_\([0-9]*\)_TCP=tcp:\/\/\(.*\):\(.*\)/socat -t 100000000 TCP4-LISTEN:\1,fork,reuseaddr TCP4:\2:\3 \&amp;/&apos; &amp;&amp; echo wait) | sh</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 7ea8aef582cc</span><br><span class="line">Successfully built 7ea8aef582cc</span><br></pre></td></tr></table></figure><p>构建缓存仅会使用本地父生成链上的镜像。如果不想使用本地缓存的镜像，也可以通过<code>--cache-from</code>指定缓存。指定后将再不使用本地生成的镜像链，而是从镜像仓库中下载。</p><h3 id="寻找缓存的逻辑"><a href="#寻找缓存的逻辑" class="headerlink" title="寻找缓存的逻辑"></a>寻找缓存的逻辑</h3><p>Docker 寻找缓存的逻辑其实就是树型结构根据 <code>Dockerfile</code> 指令遍历子节点的过程。下图可以说明这个逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> FROM base_image:version           Dockerfile:</span><br><span class="line">           +----------+                FROM base_image:version</span><br><span class="line">           |base image|                RUN cmd1  --&gt; use cache because we found base image</span><br><span class="line">           +-----X----+                RUN cmd11 --&gt; use cache because we found cmd1</span><br><span class="line">                / \</span><br><span class="line">               /   \</span><br><span class="line">       RUN cmd1     RUN cmd2           Dockerfile:</span><br><span class="line">       +------+     +------+           FROM base_image:version</span><br><span class="line">       |image1|     |image2|           RUN cmd2  --&gt; use cache because we found base image</span><br><span class="line">       +---X--+     +------+           RUN cmd21 --&gt; not use cache because there&apos;s no child node</span><br><span class="line">          / \                                        running cmd21, so we build a new image here</span><br><span class="line">         /   \</span><br><span class="line">RUN cmd11     RUN cmd12</span><br><span class="line">+-------+     +-------+</span><br><span class="line">|image11|     |image12|</span><br><span class="line">+-------+     +-------+</span><br></pre></td></tr></table></figure><p>大部分指令可以根据上述逻辑去寻找缓存，除了 <code>ADD</code> 和 <code>COPY</code> 。这两个指令会复制文件内容到镜像内，除了指令相同以外，Docker 还会检查每个文件内容校验(不包括最后修改时间和最后访问时间)，如果校验不一致，则不会使用缓存。</p><p>除了这两个命令，Docker 并不会去检查容器内的文件内容，比如 <code>RUN apt-get -y update</code>，每次执行时文件可能都不一样，但是 Docker 认为命令一致，会继续使用缓存。这样一来，以后构建时都不会再重新运行<code>apt-get -y update</code>。</p><p>如果 Docker 没有找到当前指令的缓存，则会构建一个新的镜像，并且之后的所有指令都不会再去寻找缓存。</p><h2 id="Dockerfile文件格式"><a href="#Dockerfile文件格式" class="headerlink" title="Dockerfile文件格式"></a>Dockerfile文件格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Comment</span><br><span class="line">INSTRUCTION arguments</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 注释</span><br><span class="line">指令 参数</span><br></pre></td></tr></table></figure><p><code>Dockerfile</code>文件中指令不区分大小写，但为了更易区分，约定使用<strong>大写</strong>形式。</p><p><code>Docker</code> 会依次执行<code>Dockerfile</code>中的指令，<strong>文件中的第一条指令必须是FROM，FROM指令用于指定一个基础镜像</strong>。</p><p>以#开头的行，Docker会认为是注释。但#出现在指令参数中时，则不是注释。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Comment</span><br><span class="line">RUN echo &apos;we are running some # of cool things&apos;</span><br></pre></td></tr></table></figure><h2 id="Dockerfile中使用指令"><a href="#Dockerfile中使用指令" class="headerlink" title="Dockerfile中使用指令"></a>Dockerfile中使用指令</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p><code>FROM</code>指令用于指定其后构建新镜像所使用的基础镜像。FROM指令必是<code>Dockerfile</code>文件中的首条命令，启动构建流程后，Docker将会基于该镜像构建新镜像，<code>FROM</code>后的命令也会基于这个基础镜像。</p><p><code>FROM</code>语法格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;digest&gt;</span><br></pre></td></tr></table></figure></p><p>通过<code>FROM</code>指定的镜像，可以是任何有效的基础镜像。FROM有以下限制：</p><ul><li>FROM必须是Dockerfile中第一条非注释命令</li><li>在一个Dockerfile文件中创建多个镜像时，FROM可以多次出现。只需在每个新命令FROM之前，记录提交上次的镜像ID。</li><li>tag或digest是可选的，如果不使用这两个值时，会使用latest版本的基础镜像</li></ul><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p><code>RUN</code>用于在镜像容器中执行命令，其有以下两种命令执行方式：</p><h4 id="shell执行"><a href="#shell执行" class="headerlink" title="shell执行"></a>shell执行</h4><p>在这种方式会在<code>shell</code>中执行命令，Linux下默认使用<code>/bin/sh -c</code>，Windows下使用<code>cmd /S /C</code>。</p><p>注意：通过<code>SHELL</code>命令修改RUN所使用的默认shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;command&gt;</span><br></pre></td></tr></table></figure></p><h4 id="exec执行"><a href="#exec执行" class="headerlink" title="exec执行"></a>exec执行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span><br></pre></td></tr></table></figure><p><code>RUN</code>可以执行任何命令，然后在当前镜像上创建一个新层并提交。提交后的结果镜像将会用在<code>Dockerfile</code>文件的下一步。</p><p>通过<code>RUN</code>执行多条命令时，可以通过<code>\</code>换行执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN /bin/bash -c &apos;source $HOME/.bashrc; \</span><br><span class="line">echo $HOME&apos;</span><br></pre></td></tr></table></figure><p>也可以在同一行中，通过分号分隔命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN /bin/bash -c &apos;source $HOME/.bashrc; echo $HOME&apos;</span><br></pre></td></tr></table></figure></p><p><code>RUN</code>指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定<code>--no-cache</code>参数，如：<code>docker build --no-cache</code>。</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p><code>CMD</code>用于指定在容器启动时所要执行的命令。<code>CMD</code>有以下三种格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">CMD [&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">CMD command param1 param2</span><br></pre></td></tr></table></figure></p><p><code>CMD</code>不同于<code>RUN</code>，<code>CMD</code>用于指定在容器启动时所要执行的命令，而<code>RUN</code>用于指定镜像构建时所要执行的命令。</p><p><code>CMD</code>与<code>RUN</code>在功能实现上也有相似之处。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker run -t -i itbilu/static_web_server /bin/true</span><br></pre></td></tr></table></figure></p><p>等价于：</p><p>cmd [“/bin/true”]</p><p>CMD在Dockerfile文件中仅可指定一次，指定多次时，会覆盖前的指令。</p><p>另外，<code>docker run</code>命令也会覆盖<code>Dockerfile</code>中CMD命令。如果<code>docker run</code>运行容器时，使用了<code>Dockerfile</code>中CMD相同的命令，就会覆盖<code>Dockerfile</code>中的CMD命令。</p><p>如，我们在构建镜像的<code>Dockerfile</code>文件中使用了如下指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;/bin/bash&quot;]</span><br></pre></td></tr></table></figure></p><p>使用<code>docker build</code>构建一个新镜像，镜像名为<code>itbilu/test</code>。构建完成后，使用这个镜像运行一个新容器，运行效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t itbilu/test</span><br><span class="line">root@e3597c81aef4:/#</span><br></pre></td></tr></table></figure><p>在使用<code>docker run</code>运行容器时，我们并没有在命令结尾指定会在容器中执行的命令，这时Docker就会执行在<code>Dockerfile</code>的CMD中指定的命令。</p><p>如果不想使用CMD中指定的命令，就可以在<code>docker run</code>命令的结尾指定所要运行的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t itbilu/test /bin/ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 ?        00:00:00 ps</span><br></pre></td></tr></table></figure></p><p>这时，docker run结尾指定的<code>/bin/ps</code>命令覆盖了<code>Dockerfile</code>的CMD中指定的命令。</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p><code>ENTRYPOINT</code>用于给容器配置一个可执行程序。也就是说，每次使用镜像创建容器时，通过<code>ENTRYPOINT</code>指定的程序都会被设置为默认程序。<code>ENTRYPOINT</code>有以下两种形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span><br><span class="line">ENTRYPOINT command param1 param2</span><br></pre></td></tr></table></figure><p><code>ENTRYPOINT</code>与<code>CMD</code>非常类似，不同的是通过<code>docker run</code>执行的命令不会覆盖<code>ENTRYPOINT</code>，而<code>docker run</code>命令中指定的任何参数，都会被当做参数再次传递给<code>ENTRYPOINT</code>。<code>Dockerfile</code>中只允许有一个<code>ENTRYPOINT</code>命令，多指定时会覆盖前面的设置，而只执行最后的<code>ENTRYPOINT</code>指令。</p><p><code>docker run</code>运行容器时指定的参数都会被传递给<code>ENTRYPOINT</code>，且会覆盖CMD命令指定的参数。如，执行<code>docker run &lt;image&gt; -d</code>时，<code>-d</code>参数将被传递给入口点。</p><p>也可以通过<code>docker run --entrypoint</code>重写<code>ENTRYPOINT</code>入口点。</p><p>如：可以像下面这样指定一个容器执行程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;/usr/bin/nginx&quot;]</span><br></pre></td></tr></table></figure></p><p>完整构建代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Version: 0.0.3</span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line">MAINTAINER 何民三 &quot;cn.liuht@gmail.com&quot;</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y nginx</span><br><span class="line">RUN echo &apos;Hello World, 我是个容器&apos; \ </span><br><span class="line">   &gt; /var/www/html/index.html</span><br><span class="line">ENTRYPOINT [&quot;/usr/sbin/nginx&quot;]</span><br><span class="line">EXPOSE 8</span><br></pre></td></tr></table></figure><p>使用<code>docker build</code>构建镜像，并将镜像指定为<code>itbilu/test</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker build -t=&quot;itbilu/test&quot; .</span><br></pre></td></tr></table></figure></p><p>构建完成后，使用<code>itbilu/test</code>启动一个容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t  itbilu/test -g &quot;daemon off;&quot;</span><br></pre></td></tr></table></figure></p><p>在运行容器时，我们使用了<code>-g &quot;daemon off;&quot;</code>，这个参数将会被传递给<code>ENTRYPOINT</code>，最终在容器中执行的命令为<code>/usr/sbin/nginx -g &quot;daemon off;&quot;</code>。</p><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p><code>LABEL</code>用于为镜像添加元数据，元数以键值对的形式指定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure></p><p>使用<code>LABEL</code>指定元数据时，一条<code>LABEL</code>指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。推荐将所有的元数据通过一条<code>LABEL</code>指令指定，以免生成过多的中间镜像。</p><p>如，通过<code>LABEL</code>指定一些元数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL version=&quot;1.0&quot; description=&quot;这是一个Web服务器&quot; by=&quot;IT笔录&quot;</span><br></pre></td></tr></table></figure></p><p>指定后可以通过<code>docker inspect</code>查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$sudo docker inspect itbilu/test</span><br><span class="line">&quot;Labels&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;1.0&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;这是一个Web服务器&quot;,</span><br><span class="line">    &quot;by&quot;: &quot;IT笔录&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>注意：<code>Dockerfile</code>中还有个<code>MAINTAINER</code>命令，该命令用于指定镜像作者。但<code>MAINTAINER</code>并不推荐使用，更推荐使用<code>LABEL</code>来指定镜像作者。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL maintainer=&quot;itbilu.com&quot;</span><br></pre></td></tr></table></figure></p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p><code>EXPOSE</code>用于指定容器在运行时监听的端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br></pre></td></tr></table></figure></p><p><code>EXPOSE</code>并不会让容器的端口访问到主机。要使其可访问，需要在<code>docker run</code>运行容器时通过<code>-p</code>来发布这些端口，或通过<code>-P</code>参数来发布<code>EXPOSE</code>导出的所有端口。</p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p><code>ENV</code>用于设置环境变量，其有以下两种设置形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure></p><p>如，通过<code>ENV</code>设置一个环境变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV ITBILU_PATH /home/itbilu/</span><br></pre></td></tr></table></figure></p><p>设置后，这个环境变量在<code>ENV</code>命令后都可以使用。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKERDIR $ITBILU_PATH</span><br></pre></td></tr></table></figure></p><p>这些环境变量不仅可以构建镜像过程使用，使用该镜像创建的容器中也可以使用。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -i -t  itbilu/test </span><br><span class="line">root@196ca123c0c3:/# cd $ITBILU_PATH</span><br><span class="line">root@196ca123c0c3:/home/itbilu#</span><br></pre></td></tr></table></figure></p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p><code>ADD</code>用于复制构建环境中的文件或目录到镜像中。其有以下两种使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure></p><p>通过<code>ADD</code>复制文件时，需要通过<code>&lt;src&gt;</code>指定源文件位置，并通过<code>&lt;dest&gt;</code>来指定目标位置。<code>&lt;src&gt;</code>可以是一个构建上下文中的文件或目录，也可以是一个<code>URL</code>，但不能访问构建上下文之外的文件或目录。</p><p>如，通过<code>ADD</code>复制一个网络文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD http://wordpress.org/latest.zip $ITBILU_PATH</span><br></pre></td></tr></table></figure></p><p>在上例中，<code>$ITBILU_PATH</code>是我们使用<code>ENV</code>指定的一个环境变量。</p><p>另外，如果使用的是本地归档文件（<code>gzip、bzip2、xz</code>）时，Docker会自动进行解包操作，类似使用<code>tar -x</code>。</p><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p><code>COPY</code>同样用于复制构建环境中的文件或目录到镜像中。其有以下两种使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">COPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure></p><p><code>COPY</code>指令非常类似于<code>ADD</code>，不同点在于<code>COPY</code>只会复制构建目录下的文件，不能使用<code>URL</code>也不会进行解压操作。</p><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p><code>VOLUME</code>用于创建挂载点，即向基于所构建镜像创始的容器添加卷：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;/data&quot;]</span><br></pre></td></tr></table></figure></p><p>一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：</p><ul><li>卷可以容器间共享和重用</li><li>容器并不一定要和其它容器共享卷</li><li>修改卷后会立即生效</li><li>对卷的修改不会对镜像产生影响</li><li>卷会一直存在，直到没有任何容器在使用它</li></ul><p><code>VOLUME</code>让我们可以将源代码、数据或其它内容添加到镜像中，而又不并提交到镜像中，并使我们可以多个容器间共享这些内容。</p><p>如，通过<code>VOLUME</code>创建一个挂载点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV ITBILU_PATH /home/itbilu/</span><br><span class="line">VOLUME [$ITBILU_PATH]</span><br></pre></td></tr></table></figure></p><p>构建的镜像，并指定镜像名为<code>itbilu/test</code>。构建镜像后，使用新构建的运行一个容器。运行容器时，需<code>-v</code>参将能本地目录绑定到容器的卷（挂载点）上，以使容器可以访问宿主机的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t -v ~/code/itbilu:/home/itbilu/  itbilu/test </span><br><span class="line">root@31b0fac536c4:/# cd /home/itbilu/</span><br><span class="line">root@31b0fac536c4:/home/itbilu# ls</span><br><span class="line">README.md  app.js  bin  config.js  controller  db  demo  document  lib  minify.js  node_modules  package.json  public  routes  test  views</span><br></pre></td></tr></table></figure></p><p>如上所示，我们已经可以容器的<code>/home/itbilu/</code>目录下访问到宿主机<code>~/code/itbilu</code>目录下的数据了。</p><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p><code>USER</code>用于指定运行镜像所使用的用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER daemon</span><br></pre></td></tr></table></figure></p><p>使用<code>USER</code>指定用户时，可以使用用户名、UID或GID，或是两者的组合。以下都是合法的指定试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">USER user</span><br><span class="line">USER user:group</span><br><span class="line">USER uid</span><br><span class="line">USER uid:gid</span><br><span class="line">USER user:gid</span><br><span class="line">USER uid:group</span><br></pre></td></tr></table></figure></p><p>使用<code>USER</code>指定用户后，<code>Dockerfile</code>中其后的命令<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>都将使用该用户。镜像构建完成后，通过<code>docker run</code>运行容器时，可以通过<code>-u</code>参数来覆盖所指定的用户。</p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p><code>WORKDIR</code>用于在容器内设置一个工作目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /path/to/workdir</span><br></pre></td></tr></table></figure></p><p>通过<code>WORKDIR</code>设置工作目录后，<code>Dockerfile</code>中其后的命令<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>、<code>ADD</code>、<code>COPY</code>等命令都会在该目录下执行。</p><p>如，使用<code>WORKDIR</code>设置工作目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure></p><p>在以上示例中，<code>pwd</code>最终将会在<code>/a/b/c</code>目录中执行。</p><p>在使用<code>docker run</code>运行容器时，可以通过<code>-w</code>参数覆盖构建时所设置的工作目录。</p><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p><code>ARG</code>用于指定传递给构建运行时的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARG &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure></p><p>如，通过<code>ARG</code>指定两个变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARG site</span><br><span class="line">ARG build_user=IT笔录</span><br></pre></td></tr></table></figure></p><p>以上我们指定了<code>site</code>和<code>build_user</code>两个变量，其中<code>build_user</code>指定了默认值。在使用<code>docker build</code>构建镜像时，可以通过<code>--build-arg &lt;varname&gt;=&lt;value&gt;</code>参数来指定或重设置这些变量的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker build --build-arg site=itiblu.com -t itbilu/test .</span><br></pre></td></tr></table></figure></p><p>这样我们构建了<code>itbilu/test</code>镜像，其中<code>site</code>会被设置为<code>itbilu.com</code>，由于没有指定<code>build_user</code>，其值将是默认值IT笔录。</p><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p><code>ONBUILD</code>用于设置镜像触发器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD [INSTRUCTION]</span><br></pre></td></tr></table></figure></p><p>当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发。</p><p>如，当镜像被使用时，可能需要做一些处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure></p><h3 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h3><p><code>STOPSIGNAL</code>用于设置停止容器所要发送的系统调用信号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure></p><p>所使用的信号必须是内核系统调用表中的合法的值，如：<code>9</code>、<code>SIGKILL</code>。</p><h3 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h3><p><code>SHELL</code>用于设置执行命令（<code>shell</code>式）所使用的的默认shell类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHELL [&quot;executable&quot;, &quot;parameters&quot;]</span><br></pre></td></tr></table></figure></p><p><code>SHELL</code>在Windows环境下比较有用，Windows下通常会有cmd和powershell两种shell，可能还会有sh。这时就可以通过SHELL来指定所使用的shell类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM microsoft/windowsservercore</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C echo default</span><br><span class="line">RUN echo default</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C powershell -command Write-Host default</span><br><span class="line">RUN powershell -command Write-Host default</span><br><span class="line"></span><br><span class="line"># Executed as powershell -command Write-Host hello</span><br><span class="line">SHELL [&quot;powershell&quot;, &quot;-command&quot;]</span><br><span class="line">RUN Write-Host hello</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C echo hello</span><br><span class="line">SHELL [&quot;cmd&quot;, &quot;/S&quot;&quot;, &quot;/C&quot;]</span><br><span class="line">RUN echo hello</span><br></pre></td></tr></table></figure><blockquote><p>原文链接：<a href="https://itbilu.com/linux/docker/VyhM5wPuz.html" target="_blank" rel="noopener">https://itbilu.com/linux/docker/VyhM5wPuz.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      Dockerfile镜像构建文件命令详解，方便查阅。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Dockerfile命令" scheme="http://xym-loveit.github.io/tags/Dockerfile%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Dockerfile命令详解" scheme="http://xym-loveit.github.io/tags/Dockerfile%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    
      <category term="FROM命令" scheme="http://xym-loveit.github.io/tags/FROM%E5%91%BD%E4%BB%A4/"/>
    
      <category term="RUN命令" scheme="http://xym-loveit.github.io/tags/RUN%E5%91%BD%E4%BB%A4/"/>
    
      <category term="CMD命令" scheme="http://xym-loveit.github.io/tags/CMD%E5%91%BD%E4%BB%A4/"/>
    
      <category term="ADD命令" scheme="http://xym-loveit.github.io/tags/ADD%E5%91%BD%E4%BB%A4/"/>
    
      <category term="COPY命令" scheme="http://xym-loveit.github.io/tags/COPY%E5%91%BD%E4%BB%A4/"/>
    
      <category term="ENTRYPOINT命令" scheme="http://xym-loveit.github.io/tags/ENTRYPOINT%E5%91%BD%E4%BB%A4/"/>
    
      <category term="ENV命令" scheme="http://xym-loveit.github.io/tags/ENV%E5%91%BD%E4%BB%A4/"/>
    
      <category term="ONBUILD命令" scheme="http://xym-loveit.github.io/tags/ONBUILD%E5%91%BD%E4%BB%A4/"/>
    
      <category term="ARG命令" scheme="http://xym-loveit.github.io/tags/ARG%E5%91%BD%E4%BB%A4/"/>
    
      <category term="WORKDIR命令，LABEL命令" scheme="http://xym-loveit.github.io/tags/WORKDIR%E5%91%BD%E4%BB%A4%EF%BC%8CLABEL%E5%91%BD%E4%BB%A4/"/>
    
      <category term="EXPOSE命令" scheme="http://xym-loveit.github.io/tags/EXPOSE%E5%91%BD%E4%BB%A4/"/>
    
      <category term="VOLUME命令" scheme="http://xym-loveit.github.io/tags/VOLUME%E5%91%BD%E4%BB%A4/"/>
    
      <category term="USER命令" scheme="http://xym-loveit.github.io/tags/USER%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Docker 配置加速器</title>
    <link href="http://xym-loveit.github.io/2018/04/19/Docker-%E9%85%8D%E7%BD%AE%E5%8A%A0%E9%80%9F%E5%99%A8/"/>
    <id>http://xym-loveit.github.io/2018/04/19/Docker-配置加速器/</id>
    <published>2018-04-19T01:51:10.000Z</published>
    <updated>2018-04-19T02:13:46.890Z</updated>
    
    <content type="html"><![CDATA[<p>在国内使用Docker Hub有个很大的问题就是速度太慢，pull一个image要很久，幸亏国内有个组织解决了这个问题——DaoCloud。在<a href="http://www.daocloud.io/#" target="_blank" rel="noopener">DaoCloud</a>上注册一个帐号，找到它的加速器页面，根据提示进行操作即可。</p><p>进入<a href="http://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">加速器</a>页面</p><p><img src="http://op7wplti1.bkt.clouddn.com/daocloud_%E5%8A%A0%E9%80%9F%E5%99%A8.png" alt="daocloud加速器"></p><p><img src="http://op7wplti1.bkt.clouddn.com/%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE.png" alt="daocloud配置"></p>]]></content>
    
    <summary type="html">
    
      Docker加速器配置
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker加速器配置" scheme="http://xym-loveit.github.io/tags/Docker%E5%8A%A0%E9%80%9F%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    
      <category term="daocloud加速器" scheme="http://xym-loveit.github.io/tags/daocloud%E5%8A%A0%E9%80%9F%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hexo在遇到特殊符号时出现解析报错</title>
    <link href="http://xym-loveit.github.io/2018/04/17/Hexo%E5%9C%A8%E9%81%87%E5%88%B0%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E6%97%B6%E5%87%BA%E7%8E%B0%E8%A7%A3%E6%9E%90%E6%8A%A5%E9%94%99/"/>
    <id>http://xym-loveit.github.io/2018/04/17/Hexo在遇到特殊符号时出现解析报错/</id>
    <published>2018-04-16T16:00:35.000Z</published>
    <updated>2018-04-16T16:09:18.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo-在遇到-““-符号时出现解析报错"><a href="#hexo-在遇到-““-符号时出现解析报错" class="headerlink" title="hexo 在遇到 ““ 符号时出现解析报错"></a>hexo 在遇到 “{{“ 符号时出现解析报错</h2><p>最近在更新一篇文章后，无论是 hexo g 生成，还是 hexo s 预览都会报解析错误， 大致如下，后面还有很长的信息，就不贴了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Template render error: unexpected token: .</span><br><span class="line">    at Object._prettifyError (D:\workspace\IdeaProjects\myHexo\node_modules\nunjucks\src\lib.js:35:11)</span><br><span class="line">    at Template.render (D:\workspace\IdeaProjects\myHexo\node_modules\nunjucks\src\environment.js:526:21)</span><br></pre></td></tr></table></figure><p>而把那篇文章移除后一切又是正常的。从错误上来看基本可以判断是模板解析错误，从 unexpected token: . 又看不出来具体是哪里出错，一直找不到原因。</p><p>今天查找资料发现有人遇到和我类似的问题，但报的是 <code>unexpected token: }}</code> 的错误。搜索一下我那篇文章，果然有好几处带有 <code>}}</code> 符号。尝试着把几处符号删除，果然正常了。看来问题真的出在 }} 上面。</p><p>直接说解决方案吧，参考别人的解决方法是在 }} 中间加一个空格，但因为我的是有部分教程含义的文章，所以并不想这样误导人。于是去 github 上找解决方案。</p><p>github 上给出的方法是在需要显示 }} 符号的地方加上 <code>{% raw %}{% endraw %}</code> 标签，标记这部分不需要解析。例如文章中可能会出现 <code></code> 的片段，写成 <code>{% raw %}{{ something }}{% endraw %}</code> 就可以了。</p><p>虽然有点麻烦，但也算临时解决了这个问题，这是个已知 bug ，希望后续的版本能修复吧，毕竟使用太多 hexo 专属的标签对博客以后的迁移、改版什么的来说还是很麻烦的。</p><p>本文链接: <a href="https://icewing.cc/post/hexo-bug-of-quot.html" target="_blank" rel="noopener">https://icewing.cc/post/hexo-bug-of-quot.html</a></p>]]></content>
    
    <summary type="html">
    
      Hexo使用解析问题
    
    </summary>
    
      <category term="hexo笔记" scheme="http://xym-loveit.github.io/categories/hexo%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="hexo小技巧" scheme="http://xym-loveit.github.io/tags/hexo%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Docker 端口映射与容器互联</title>
    <link href="http://xym-loveit.github.io/2018/04/16/Docker-%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94/"/>
    <id>http://xym-loveit.github.io/2018/04/16/Docker-端口映射与容器互联/</id>
    <published>2018-04-16T08:11:59.000Z</published>
    <updated>2018-04-16T15:56:45.507Z</updated>
    
    <content type="html"><![CDATA[<p>在实践中会经常碰到需要多个服务组件容器共同协作的情况，这往往需要多个容器之间能够互相访问到对方的服务。除了通过网络访问外，Docker还提供了两个很方便的功能来满足服务访问的基本需求：一是允许映射容器内应用的服务端口到本地宿主主机；另一个是互联机制实现多个容器间通过容器名来快速访问。</p><h2 id="端口映射实现访问容器"><a href="#端口映射实现访问容器" class="headerlink" title="端口映射实现访问容器"></a>端口映射实现访问容器</h2><h3 id="1、从外部访问容器应用"><a href="#1、从外部访问容器应用" class="headerlink" title="1、从外部访问容器应用"></a>1、从外部访问容器应用</h3><p>在启动容器的时候，如果不指定对应的参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。当容器中运行一些网络应用，要让外部访问这些应用时，可以通过<code>-p</code>或<code>-P</code>参数来指定端口映射。当使用<code>-P</code>（大写的）标记时，Docker会随机映射一个端口到内部容器开放的网络端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@xxx ~]# docker run -d -P training/webapp python app.py</span><br><span class="line">f2c1a06b94b49de281b403fa339d5975be5dd6fae662c664b300540c851c3565</span><br><span class="line"></span><br><span class="line">//ps命令后发现本地主机的32783被映射到了容器的5000端口。访问宿主主机的32783端口即可访问容器内的web应用</span><br><span class="line">[root@xxx ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                          PORTS                     NAMES</span><br><span class="line">f2c1a06b94b4        training/webapp     &quot;python app.py&quot;          3 seconds ago       Up 2 seconds                    0.0.0.0:32783-&gt;5000/tcp   inspiring_hawking</span><br><span class="line"></span><br><span class="line">//同样使用docker logs命令来查看应用信息</span><br><span class="line">[root@xxx ~]# docker logs -f  f2c</span><br><span class="line">Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span><br><span class="line">172.17.0.1 - - [14/Apr/2018 16:13:50] &quot;GET / HTTP/1.1&quot; 200 -</span><br></pre></td></tr></table></figure><p><code>-p</code>（小写的）可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP:HostPort:ContainerPort|IP::ContainerPort|HostPort:ContainerPort</span><br></pre></td></tr></table></figure><h3 id="2、映射所有接口地址"><a href="#2、映射所有接口地址" class="headerlink" title="2、映射所有接口地址"></a>2、映射所有接口地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//使用HostPort:ContainerPort格式将本地的5000端口映射到容器的5000端口</span><br><span class="line">[root@xxx ~]# docker run -d -p 5000:5000 training/webapp python app.py</span><br><span class="line">22c0bc271d46033c16f9ebdbc60ebf78938a1a0710bcede98afd15f887a92968</span><br><span class="line"></span><br><span class="line">//查看容器，注意端口映射栏</span><br><span class="line">[root@xxx ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                    NAMES</span><br><span class="line">22c0bc271d46        training/webapp     &quot;python app.py&quot;          8 seconds ago       Up 7 seconds                0.0.0.0:5000-&gt;5000/tcp   confident_saha</span><br><span class="line"></span><br><span class="line">//多次使用-p标记可以绑定多个端口</span><br><span class="line">[root@xxx ~]# docker run -d -p 5000:5000 -p 8080:80  training/webapp python app.py</span><br><span class="line">c18177c0e1ec3a40c175cec0b7c165d8e0ff9576087c1734293e890357152919</span><br><span class="line"></span><br><span class="line">//查看容器，注意端口映射栏</span><br><span class="line">[root@xxx ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                                          NAMES</span><br><span class="line">c18177c0e1ec        training/webapp     &quot;python app.py&quot;          3 seconds ago       Up 2 seconds                0.0.0.0:5000-&gt;5000/tcp, 0.0.0.0:8080-&gt;80/tcp   suspicious_swartz</span><br></pre></td></tr></table></figure><h3 id="3、映射到指定地址的指定端口"><a href="#3、映射到指定地址的指定端口" class="headerlink" title="3、映射到指定地址的指定端口"></a>3、映射到指定地址的指定端口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//只有自己访问自己</span><br><span class="line">[root@xxx ~]# docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py </span><br><span class="line">4da1f3ed9ee27026b9929e2b96ebd422e2bf6ab212b07ab8fbb8339c322fef70</span><br><span class="line"></span><br><span class="line">[root@xxx ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                      NAMES</span><br><span class="line">4da1f3ed9ee2        training/webapp     &quot;python app.py&quot;          4 seconds ago       Up 4 seconds                127.0.0.1:5000-&gt;5000/tcp   affectionate_elion</span><br></pre></td></tr></table></figure><h3 id="4、映射到指定地址的任意端口"><a href="#4、映射到指定地址的任意端口" class="headerlink" title="4、映射到指定地址的任意端口"></a>4、映射到指定地址的任意端口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//使用IP::ContainerPort绑定localhost的任意端口到容器的5000端口，本地主机会自动分配一个端口</span><br><span class="line">[root@xxx ~]# docker run -d -p 127.0.0.1::5000 training/webapp python app.py</span><br><span class="line">ed9497ef017e2e90fac7e783c92ccde2f59c14f62d429190cb24c0dfa43eeefb</span><br><span class="line"></span><br><span class="line">[root@xxx ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                         PORTS                       NAMES</span><br><span class="line">ed9497ef017e        training/webapp     &quot;python app.py&quot;          5 seconds ago       Up 4 seconds                   127.0.0.1:32768-&gt;5000/tcp   wonderful_yonath</span><br><span class="line"></span><br><span class="line">//还可以使用udp标记来指定udp端口</span><br><span class="line">[root@xxx ~]# docker run -d -p 5000:5000/udp training/webapp python app.py</span><br><span class="line">4880a7d119f226591ad1b99ad0324d55d8e2caa98a399c9f426e6757fc7491c5</span><br><span class="line">[root@xym ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                         PORTS                              NAMES</span><br><span class="line">4880a7d119f2        training/webapp     &quot;python app.py&quot;          3 seconds ago       Up 3 seconds                   5000/tcp, 0.0.0.0:5000-&gt;5000/udp   gracious_williams</span><br><span class="line">b5257d2e</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 5、查看映射端口配置</span><br><span class="line"></span><br><span class="line">使用`docker port`命令来查看当前映射的端口配置，也可以查看到绑定的地址：</span><br></pre></td></tr></table></figure><p>[root@xxx ~]# docker port priceless_franklin 5000<br>0.0.0.0:5000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 互联机制实现便捷互访</span><br><span class="line"></span><br><span class="line">容器的互联（linking）是一种让多个容器中应用进行快速交互的方式。它会在源和接受容器之间创建连接关系，接受容器可以通过容器名快速访问到源容器，而不用指定具体的IP地址。</span><br><span class="line"></span><br><span class="line">### 1、自定义容器命名</span><br><span class="line"></span><br><span class="line">连接系统依据容器名称来执行。因此，首先需要定义好一个好记的容器名字。虽然当创建容器的时候，系统默认会分配一个名字，但自定义容器名字有两个好处：</span><br><span class="line"></span><br><span class="line">* 自定义的名字比较好记，比如一个web应用容器，我们可以给它起个名字叫web ，一目了然。</span><br><span class="line">* 当要连接其他容器时，即便重启，也可以使用容器名而不用改变，比如连接web容器到db容器。</span><br></pre></td></tr></table></figure><p>//使用–name参数自定义容器名称<br>[root@xxx ~]# docker run -d -p 5000:5000 –name web training/webapp python app.py<br>757d2ee95be01e2c509426c52bf5b4176ff7199eb654b5854ddf0e9b8412c044</p><p>//查看运行容器，注意NAMES栏<br>[root@xxx ~]# docker ps -l<br>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES<br>757d2ee95be0        training/webapp     “python app.py”     5 seconds ago       Up 4 seconds        0.0.0.0:5000-&gt;5000/tcp   web</p><p>//还可使用inspect –format “{{.Name}}“获取容器名字<br>[root@xxx ~]# docker inspect –format “{{.Name}}“ 757d2ee95be<br>/web</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在执行`docker run`的时候如果添加了`--rm`标记，则容器在终止后会立即删除。注意`--rm`和`-d`参数不能同时使用。</span><br><span class="line"></span><br><span class="line">### 2、容器互联</span><br><span class="line"></span><br><span class="line">使用`--link`参数可以让容器之间安全地进行交互。</span><br></pre></td></tr></table></figure><p>//创建一个db容器<br>[root@xxx ~]# docker run -d –name db training/postgres<br>Unable to find image ‘training/postgres:latest’ locally<br>latest: Pulling from training/postgres<br>a3ed95caeb02: Pull complete<br>6e71c809542e: Pull complete<br>2978d9af87ba: Pull complete<br>e1bca35b062f: Pull complete<br>500b6decf741: Pull complete<br>74b14ef2151f: Pull complete<br>7afd5ed3826e: Pull complete<br>3c69bb244f5e: Pull complete<br>d86f9ec5aedf: Pull complete<br>010fabf20157: Pull complete<br>Digest: sha256:a945dc6dcfbc8d009c3d972931608344b76c2870ce796da00a827bd50791907e<br>Status: Downloaded newer image for training/postgres:latest<br>3b48a3a82a86a52244527112a4a03e98e951c8edcdaedb3b63bc1a0775ac0315</p><p>//删除原来的web容器<br>[root@xxx ~]# docker rm -f web<br>web</p><p>//重建web容器，并让它连接到db容器,–link参数的格式为–link name:alias，其中name是要连接的容器名称，alias是这个连接的别名<br>[root@xxx ~]# docker run -d -P –name web –link db:db training/webapp python app.py<br>ca82ea2a2e5ad9b407d5c80fcfd6cd01f7e03be46864e5058b539075e858c626</p><p>//查看运行容器<br>[root@xxx ~]# docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                     NAMES<br>ca82ea2a2e5a        training/webapp     “python app.py”          22 seconds ago       Up 21 seconds       0.0.0.0:32784-&gt;5000/tcp   web<br>3b48a3a82a86        training/postgres   “su postgres -c ‘/us…”   About a minute ago   Up About a minute   5432/tcp                  db</p><p>//查看接受容器(web)连接信息<br>[root@xxx ~]# docaker inspect –format “{{.HostConfig.Links}}“ web<br>[/db:/web/db]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Docker相当于在两个互联的容器之间创建了一个虚机通道，而且不用映射他们的端口在宿主主机上。在启动db容器的时候并没有使用`-p`和`-P`标记，从而避免了暴露数据库服务端口到外部网路上。</span><br><span class="line"></span><br><span class="line">Docker通过两种方式为容器公开连接信息：</span><br><span class="line"></span><br><span class="line">* 更新环境变量</span><br><span class="line">* 更新`/etc/hosts`文件</span><br><span class="line"></span><br><span class="line">使用env命令来查看web容器的环境变量：</span><br></pre></td></tr></table></figure><p>[root@xxx ~]# docker run –rm –name web2 –link db:db training/webapp env<br>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br>HOSTNAME=6f8232ea8d36<br>DB_PORT=tcp://172.17.0.3:5432<br>DB_PORT_5432_TCP=tcp://172.17.0.3:5432<br>DB_PORT_5432_TCP_ADDR=172.17.0.3<br>DB_PORT_5432_TCP_PORT=5432<br>DB_PORT_5432_TCP_PROTO=tcp<br>DB_NAME=/web2/db<br>DB_ENV_PG_VERSION=9.3<br>HOME=/root</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中`DB_`开头的环境变量时提供web容器连接db容器使用的，前缀采用大写的连接别名。除了环境变量之外，Docker还添加host信息到子容器的`/etc/hosts`文件，下面是子容器web的hosts文件：</span><br></pre></td></tr></table></figure><p>//创建容器，并进入bash<br>[root@xxx ~]# docker run -it –rm –link db:db training/webapp /bin/bash</p><p>//查看hosts配置<br>root@d64fd0fa99f0:/opt/webapp# cat /etc/hosts<br>172.17.0.3    db 3b48a3a82a86<br>172.17.0.4    d64fd0fa99f0</p><p>//查看db容器，发现其将容器id作为主机名<br>root@3b48a3a82a86:/# cat /etc/hosts<br>127.0.0.1    localhost<br>172.17.0.3    3b48a3a82a86</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里有两个hosts信息，第一个是db容器的IP、主机名和容器id，第二个是web容器，web容器使用自己的id作为默认主机名。</span><br></pre></td></tr></table></figure><p>//安装ping命令<br>root@d64fd0fa99f0:/opt/webapp# apt-get install inetutils-ping<br>Unpacking inetutils-ping (2:1.9.2-1) …<br>Setting up inetutils-ping (2:1.9.2-1) …</p><p>//执行ping命令，测试与db容器的连通性<br>root@d64fd0fa99f0:/opt/webapp# ping db<br>PING db (172.17.0.3): 56 data bytes<br>64 bytes from 172.17.0.3: icmp_seq=0 ttl=64 time=0.267 ms<br>64 bytes from 172.17.0.3: icmp_seq=1 ttl=64 time=0.314 ms<br>64 bytes from 172.17.0.3: icmp_seq=2 ttl=64 time=0.260 ms<br>64 bytes from 172.17.0.3: icmp_seq=3 ttl=64 time=0.131 ms</p><p><code>`</code></p>]]></content>
    
    <summary type="html">
    
      Docker入门指南,端口映射和容器互联。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="docker容器端口映射" scheme="http://xym-loveit.github.io/tags/docker%E5%AE%B9%E5%99%A8%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/"/>
    
      <category term="Pp命" scheme="http://xym-loveit.github.io/tags/Pp%E5%91%BD/"/>
    
      <category term="link选项" scheme="http://xym-loveit.github.io/tags/link%E9%80%89%E9%A1%B9/"/>
    
      <category term="容器互联原理" scheme="http://xym-loveit.github.io/tags/%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 跳过指定文件的渲染</title>
    <link href="http://xym-loveit.github.io/2018/04/16/Hexo-%E8%B7%B3%E8%BF%87%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93/"/>
    <id>http://xym-loveit.github.io/2018/04/16/Hexo-跳过指定文件的渲染/</id>
    <published>2018-04-16T06:52:03.000Z</published>
    <updated>2018-04-16T06:56:58.866Z</updated>
    
    <content type="html"><![CDATA[<p>关于hexo的<code>_config.yml</code>配置，官方文档中：</p><blockquote><p>skip_render：跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。</p></blockquote><p>但并没有说明具体该怎么配置，一番折腾后得以解决：</p><p>如果要跳过source文件夹下的<code>test.html</code>，可以这样配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip_render: test.html</span><br></pre></td></tr></table></figure></p><p>注意，千万不要手贱加上个<code>/</code>写成<code>/test.html</code>，这里只能填相对于source文件夹的相对路径。</p><p>如果要忽略source下的test文件夹下所有文件，可以这样配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip_render: test/*</span><br></pre></td></tr></table></figure></p><p>如果要忽略source下的test文件夹下<code>.html</code>文件，可以这样配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">skip_render: test/*.html</span><br></pre></td></tr></table></figure></p><p>如果要忽略source下的test文件夹下所有文件和目录，可以这样配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip_render: test/**</span><br></pre></td></tr></table></figure><p>如果要忽略多个路径的文件或目录，可以这样配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">skip_render:</span><br><span class="line">    - test.html</span><br><span class="line">    - test/*</span><br></pre></td></tr></table></figure><p><strong>Tips:</strong></p><p><a href="https://github.com/hexojs/hexo/issues/1146" target="_blank" rel="noopener">如何不处理source目录下某个子目录的所有文件，仅仅是将其copy到public目录中对应目录？</a></p>]]></content>
    
    <summary type="html">
    
      Hexo使用小技巧
    
    </summary>
    
      <category term="hexo笔记" scheme="http://xym-loveit.github.io/categories/hexo%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="hexo小技巧" scheme="http://xym-loveit.github.io/tags/hexo%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Docker 数据管理</title>
    <link href="http://xym-loveit.github.io/2018/04/15/Docker-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://xym-loveit.github.io/2018/04/15/Docker-数据管理/</id>
    <published>2018-04-15T11:04:53.000Z</published>
    <updated>2018-04-16T04:44:34.177Z</updated>
    
    <content type="html"><![CDATA[<p>在生产环境中使用Docker过程中，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，这必然涉及到容器的数据管理操作。</p><p>容器中管理数据主要有两种方式：</p><p>数据卷（Data volumes）：容器内数据直接映射到本地主机环境；<br>数据卷容器（Data Volume Containers）：使用特定容器维护数据卷；</p><p>本文首先介绍如果在容器内创建数据卷，并且把本地的目录或文件挂载到容器内的数据卷中。接下来，会介绍如何使用数据卷容器，在容器和主机、容器和容器之间共享数据，并实现数据的备份和恢复。</p><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>数据卷是一个可供容器使用的特殊目录，它将主机操作系统目录直接映射进容器，类似于linux中的mount操作。</p><p>数据卷可以提供很多有用的特性：  </p><ul><li>数据卷可以在容器之间共享和重用，容器间传递数据将变得高效方便</li><li>对数据卷内数据的修改会立马生效，无论是容器内操作还是本机操作</li><li>对数据卷的更新不会影响镜像，解耦了应用和数据</li><li>卷会一直存在，直到没有容器使用，可以安全的卸载它</li></ul><h3 id="1、在容器内创建一个数据卷"><a href="#1、在容器内创建一个数据卷" class="headerlink" title="1、在容器内创建一个数据卷"></a>1、在容器内创建一个数据卷</h3><p>在用<code>docker run</code>命令的时候，使用-v标记可以在容器内创建一个数据卷。多次重复使用-v标记可以创建多个数据卷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//使用training/webapp镜像创建一个web（name参数指定容器名称）容器，并创建一个数据卷挂载到容器的/webapp目录（-v 指定创建的数据卷）</span><br><span class="line">// -P参数是将容器服务暴露的端口自动映射到本地主机的临时端口上，python app.py(为执行的命令COMMAND和其对应的参数ARG)</span><br><span class="line">[root@xxx ~]# docker run -d -P --name web -v /webapp training/webapp python app.py</span><br><span class="line">Unable to find image &apos;training/webapp:latest&apos; locally</span><br><span class="line">latest: Pulling from training/webapp</span><br><span class="line">e190868d63f8: Pull complete </span><br><span class="line">909cd34c6fd7: Pull complete </span><br><span class="line">0b9bfabab7c1: Pull complete </span><br><span class="line">a3ed95caeb02: Pull complete </span><br><span class="line">10bbbc0fc0ff: Pull complete </span><br><span class="line">fca59b508e9f: Pull complete </span><br><span class="line">e7ae2541b15b: Pull complete </span><br><span class="line">9dd97ef58ce9: Pull complete </span><br><span class="line">a4c1b0cb7af7: Pull complete </span><br><span class="line">Digest: sha256:06e9c1983bd6d5db5fba376ccd63bfa529e8d02f23d5079b8f74a616308fb11d</span><br><span class="line">Status: Downloaded newer image for training/webapp:latest</span><br><span class="line">e7816725b3d075b56410c9d64543a4febfe965e9a5d7cc1c8ea82c92c966f030</span><br><span class="line"></span><br><span class="line">//查看镜像</span><br><span class="line">[root@xxx ~]# docker images</span><br><span class="line">REPOSITORY                                        TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hub.c.163.com/public/ubuntu                       14.04               2fe5c4bba1f9        2 years ago         237MB</span><br><span class="line">training/webapp                                   latest              6fae60ef3446        2 years ago         349MB  </span><br><span class="line"></span><br><span class="line">//查看运行态的容器</span><br><span class="line">[root@xxx ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES</span><br><span class="line">e7816725b3d0        training/webapp     &quot;python app.py&quot;     21 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;5000/tcp   web</span><br></pre></td></tr></table></figure><h3 id="2、挂载一个主机目录作为数据卷"><a href="#2、挂载一个主机目录作为数据卷" class="headerlink" title="2、挂载一个主机目录作为数据卷"></a>2、挂载一个主机目录作为数据卷</h3><p>使用-v标记也可以指定挂载一个本地的已有目录到容器中去作为数据卷（推荐方式）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//使用-v /src/webapp:/opt/webapp 加载主机/src/webapp目录到容器的/opt/webapp目录，python为command命令，app.py为运行参数</span><br><span class="line">[root@xxx webapp]# docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py</span><br><span class="line">1e0d2372472f8697a65c7da879a8807cf048bc4601b7136e354e4b0c87a7126f</span><br><span class="line"></span><br><span class="line">//查看运行的容器</span><br><span class="line">[root@xxx webapp]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES</span><br><span class="line">1e0d2372472f        training/webapp     &quot;python app.py&quot;     4 seconds ago       Up 3 seconds        0.0.0.0:32781-&gt;5000/tcp   web</span><br></pre></td></tr></table></figure><p>这个功能在进行测试的时候非常方便，比如用户可以将一些程序或数据放到本地目录中，然后在容器中运行和使用。另外，本地目录的路径必须是绝对路径，如果目录不存在,Docker会自动创建</p><p>Docker挂载数据卷的默认权限是读写（rw），用户也可以通过<code>ro</code>指定为只读。加了<code>ro</code>之后，容器内对所挂载数据卷内的数据就无法修改了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@xxx ~]# docker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py</span><br><span class="line">f5d7d04aa46c50db6696efa8554a9d344bbd3f13eb077be3c680a1ac89d509a0</span><br></pre></td></tr></table></figure><h3 id="3、挂载一个本地主机文件作为数据卷"><a href="#3、挂载一个本地主机文件作为数据卷" class="headerlink" title="3、挂载一个本地主机文件作为数据卷"></a>3、挂载一个本地主机文件作为数据卷</h3><p><code>-v</code>参数，也可以从主机挂载单个文件到容器中作为数据卷（不推荐）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//使用-v ~/.bash_history:/.bash_history，这样就可以记录在容器中输入过的命令历史了</span><br><span class="line"></span><br><span class="line">[root@xxx ~]# docker run -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash</span><br><span class="line">root@43e50ea02e35:/# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@43e50ea02e35:/# history </span><br><span class="line">    1  ls</span><br><span class="line">    2  history</span><br></pre></td></tr></table></figure><p>挂载文件引起的问题：使用文件编辑工具，包括<code>vi</code>或者<code>sed --in-place</code>的时候，可能会造成文件<code>inode</code>的改变，从Docker1.1.0起，这会导致报错误信息。所以推荐的方式是直接挂载文件所在目录。</p><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>如果用户需要在多个容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。数据卷容器也是一个容器，但是它的目的是专门用来提供数据卷供其他容器挂载。</p><p>首先创建一个数据卷容器<code>dbdata</code>,并在其中创建一个数据卷挂载到<code>/dbdata</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建一个数据卷容器</span><br><span class="line">[root@xxx ~]# docker run -it -v /dbdata --name dbdata ubuntu</span><br><span class="line"></span><br><span class="line">//查看目录</span><br><span class="line">root@d4bb57243d45:/# ls</span><br><span class="line">bin  boot  dbdata  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure></p><p>然后，可以在其他容器中使用<code>--volumes-from</code>来挂载<code>dbdata</code>容器中的数据卷，例如创建<code>db1</code>和<code>db2</code>两个容器，并从<code>dbdata</code>容器挂载数据卷：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 创建2个容器挂载dbdata容器中的数据卷</span><br><span class="line">[root@xxx ~]# docker run -it --volumes-from dbdata --name db1 ubuntu</span><br><span class="line">[root@xxx ~]# docker run -it --volumes-from dbdata --name db2 ubuntu</span><br></pre></td></tr></table></figure><p>此时，容器db1和容器db2都挂载同一个数据卷到相同的<code>dbdata</code>目录。三个容器任何一方在该目录下的写入，其他容器都可以看到。例如，在<code>dbdata</code>容器中创建一个<code>test</code>文件,在<code>db1</code>容器中可能查看到它：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//在dbdata容器的数据卷中创建文件a</span><br><span class="line">root@9e90f695bcb8:/dbdata# touch a</span><br><span class="line">root@9e90f695bcb8:/dbdata# ll</span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x.  2 root root   14 Apr 14 10:02 ./</span><br><span class="line">drwxr-xr-x. 22 root root 4096 Apr 14 10:01 ../</span><br><span class="line">-rw-r--r--.  1 root root    0 Apr 14 10:02 a</span><br><span class="line"></span><br><span class="line">//在db1容器中查看数据卷目录dbdata，也发现了文件a</span><br><span class="line">root@ab4426a23cb4:/dbdata# ll</span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x.  2 root root    6 Apr 14 10:01 ./</span><br><span class="line">drwxr-xr-x. 22 root root 4096 Apr 14 10:02 ../</span><br><span class="line">root@ab4426a23cb4:/dbdata# ls     </span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">//db2结果和db1一样</span><br><span class="line">root@b4bea0f56613:/# cd dbdata/</span><br><span class="line">root@b4bea0f56613:/dbdata# ll</span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x.  2 root root   14 Apr 14 10:02 ./</span><br><span class="line">drwxr-xr-x. 22 root root 4096 Apr 14 10:03 ../</span><br><span class="line">-rw-r--r--.  1 root root    0 Apr 14 10:02 a</span><br></pre></td></tr></table></figure><p>可以多次使用<code>--volumes-from</code>参数来从多个容器挂载多个数据卷。还可以从其他已经挂载了容器卷的容器来挂载数据卷。  </p><p>使用<code>--volumes-from</code>参数所挂载数据卷的容器自身并不需要保持在运行状态。如果删除了挂载容器（包括dbdata、db1和bd2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时显示使用<code>docker rm -v</code>命令来指定同时删除关联的数据卷。</p><h2 id="利用数据卷容器迁移数据"><a href="#利用数据卷容器迁移数据" class="headerlink" title="利用数据卷容器迁移数据"></a>利用数据卷容器迁移数据</h2><p>可以使用数据卷容器对其中的数据卷进行备份、恢复、以实现数据的迁移。</p><h3 id="1、备份"><a href="#1、备份" class="headerlink" title="1、备份"></a>1、备份</h3><p>使用如下命令来备份<code>dbdata</code>数据卷容器内的数据卷：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@xxx ~]# docker run --volumes-from dbdata -v $(pwd):/backup --name worker ubuntu tar -zcvf /backup/backup.tar /dbdata</span><br><span class="line">tar: Removing leading `/&apos; from member names</span><br><span class="line">/dbdata/</span><br><span class="line">/dbdata/a</span><br><span class="line"></span><br><span class="line">[root@xxx ~]#</span><br></pre></td></tr></table></figure><p>分析命令：  </p><ul><li>利用ubuntu镜像创建一个容器worker。对应命令参数：<code>docker run --name worker ubuntu</code></li><li>使用<code>--volumes-from dbdata</code>参数来让<code>worker</code>容器挂载<code>dbdata</code>容器的数据卷(即dbdata)。对应命令参数：<code>--volumes-from dbdata</code></li><li>使用 <code>-v $(pwd):/backup</code>参数来挂载本地的当前目录到<code>woker</code>容器的<code>/backup</code>目录。对应命令参数：<code>-v $(pwd):/backup</code></li><li><code>worker</code>容器启动后，使用<code>tar -zcvf /backup/backup.tar /dbdata</code>命令来将<code>/dbdata</code>下内容备份为容器内的<code>/backup/backup.tar</code>,即宿主主机当前目录下的<code>backup.tar</code>。</li></ul><h3 id="2、恢复"><a href="#2、恢复" class="headerlink" title="2、恢复"></a>2、恢复</h3><p>如果要将数据恢复到一个容器，可以按照下面步骤操作。首先创建一个带有数据卷的容器<code>dbdata2</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>然后创建另一个新的容器，挂载<code>dbdata2</code>的容器，并使用<code>untar</code>解压备份文件到所挂载的容器中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker run --volumes-from dbdata2 -v $(pwd):/backup busybox untar /backup/backup.tar</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Docker入门指南，通过数据卷（-v参数）和数据卷容器（--volumes-from参数）来做数据管理（使用数据卷容器做数据卷的备份和恢复）。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="docker数据管理" scheme="http://xym-loveit.github.io/tags/docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/"/>
    
      <category term="-v选项" scheme="http://xym-loveit.github.io/tags/v%E9%80%89%E9%A1%B9/"/>
    
      <category term="--volumes-from选项" scheme="http://xym-loveit.github.io/tags/volumes-from%E9%80%89%E9%A1%B9/"/>
    
      <category term="数据卷备份" scheme="http://xym-loveit.github.io/tags/%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%A4%87%E4%BB%BD/"/>
    
      <category term="数据卷恢复" scheme="http://xym-loveit.github.io/tags/%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%81%A2%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>Docker 基本操作之仓库</title>
    <link href="http://xym-loveit.github.io/2018/04/15/Docker-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%B9%8B%E4%BB%93%E5%BA%93/"/>
    <id>http://xym-loveit.github.io/2018/04/15/Docker-基本操作之仓库/</id>
    <published>2018-04-15T07:43:29.000Z</published>
    <updated>2018-04-15T10:00:40.619Z</updated>
    
    <content type="html"><![CDATA[<p>仓库（Repository）是集中存放镜像的地方，分为公共仓库和私有仓库。一个容易与之混淆的概念是注册服务器（Registry）。实际上注册服务器是存放仓库的具体服务器，一个注册服务器上可以有多个仓库，而每个仓库下面可以有多个镜像。从这方面来说，可将仓库看做一个具体的项目或目录。例如对于仓库地址<code>private-docker.com/ubuntu</code>来说,<code>private-docker.com</code>是注册服务器地址，<code>ubuntu</code>是仓库名。</p><h2 id="Docker-Hub公共镜像"><a href="#Docker-Hub公共镜像" class="headerlink" title="Docker Hub公共镜像"></a>Docker Hub公共镜像</h2><p>访问地址：<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><h3 id="1、登录仓库"><a href="#1、登录仓库" class="headerlink" title="1、登录仓库"></a>1、登录仓库</h3><p>命令格式：<code>docker login [OPTIONS] [SERVER]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -p, --password string   Password</span><br><span class="line">      --password-stdin    Take the password from stdin</span><br><span class="line">  -u, --username string   Username</span><br><span class="line">  </span><br><span class="line">//通过存储的登录信息，直接确认登录  </span><br><span class="line">[root@xxx ~]# docker login</span><br><span class="line">Authenticating with existing credentials...</span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Are you sure you want to proceed? [y/N] y</span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure><h3 id="2、基本操作"><a href="#2、基本操作" class="headerlink" title="2、基本操作"></a>2、基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//查找官方仓库中的镜像，搜索关键词centos</span><br><span class="line">[root@xxx ~]# docker search centos</span><br><span class="line">NAME                               DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">centos                             The official build of CentOS.                   4188                [OK]                </span><br><span class="line">ansible/centos7-ansible            Ansible on Centos7                              108                                     [OK]</span><br><span class="line">jdeathe/centos-ssh                 CentOS-6 6.9 x86_64 / CentOS-7 7.4.1708 x86_…   94                                      [OK]</span><br><span class="line">consol/centos-xfce-vnc             Centos container with &quot;headless&quot; VNC session…   52                                      [OK]</span><br><span class="line">imagine10255/centos6-lnmp-php56    centos6-lnmp-php56                              40                                      [OK]</span><br><span class="line">tutum/centos                       Simple CentOS docker image with SSH access      38                                      </span><br><span class="line">gluster/gluster-centos             Official GlusterFS Image [ CentOS-7 +  Glust…   26                                      [OK]</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">//下载centos镜像</span><br><span class="line">[root@xxx ~]# docker pull centos</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/centos</span><br><span class="line">469cfcc7a4b3: Pull complete </span><br><span class="line">Digest: sha256:989b936d56b1ace20ddf855a301741e52abca38286382cba7f44443210e96d16</span><br><span class="line">Status: Downloaded newer image for centos:latest</span><br></pre></td></tr></table></figure><p>根据search结果，可将镜像资源分为两类。一种是类似centos这样的镜像，称为基础或根镜像。这些镜像是由docker公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。还有一种类型，比如<code>ansible/centos7-ansible</code>镜像，它是由docker用户ansible创建并维护的，带有用户名称前缀，表明是某用户下的某仓库。可以通过用户名称前缀<code>user_name/镜像名</code>来指定使用某个用户提供的镜像。另外，在查找的时候通过-s N参数可以指定仅显示评价为N星级以上的镜像。</p><h3 id="3、自动创建"><a href="#3、自动创建" class="headerlink" title="3、自动创建"></a>3、自动创建</h3><p>自动创建（Automated Builds）功能对于需要经常升级镜像内程序来说，十分方便。有时候，用户创建了镜像，安装了某个软件，如果软件发布新版本则需要手动更新镜像。而自动创建允许用户通过Docker Hub指定跟踪一个目标网站（目前支持Github或Bitbucket）上的项目，一旦项目发生新的提交，则自动执行创建。</p><p>要配置自动创建，包括如下步骤：</p><ul><li>1)创建并登陆Docker Hub，以及目标网站；在目标网站中连接账户到Docker Hub。</li><li>2)在Docker Hub中配置一个“自定创建”</li><li>3)选取一个目标网站中的项目（需要含Dockerfile）和分支；</li><li>4)指定Dockerfile位置，并提交创建</li></ul><p>之后，可以在Docker Hub的“自动创建”页面中跟踪每次创建的状态。</p><h2 id="国内时速云镜像"><a href="#国内时速云镜像" class="headerlink" title="国内时速云镜像"></a>国内时速云镜像</h2><p>访问地址：<a href="https://hub.tenxcloud.com/" target="_blank" rel="noopener">https://hub.tenxcloud.com/</a></p><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//下载镜像</span><br><span class="line">[root@xxx ~]# docker pull index.tenxcloud.com/tenxcloud/centos</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from tenxcloud/centos</span><br><span class="line">a3ed95caeb02: Pull complete </span><br><span class="line">5989106db7fb: Pull complete </span><br><span class="line">c9d12ea9fc45: Pull complete </span><br><span class="line">68317fcc0aa1: Pull complete </span><br><span class="line">83ef48200e63: Pull complete </span><br><span class="line">c6eb26bf54de: Pull complete </span><br><span class="line">1bcf3170bbc2: Pull complete </span><br><span class="line">Digest: sha256:190cbd5234c4aad993b852d5f118ecfba5499adc6f752026938bce0eca754b0c</span><br><span class="line">Status: Downloaded newer image for index.tenxcloud.com/tenxcloud/centos:latest</span><br><span class="line"></span><br><span class="line">//查看镜像</span><br><span class="line">[root@xxx ~]# docker images</span><br><span class="line">REPOSITORY                                        TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">xymtest                                           0.1                 8a758d16a99b        22 hours ago        113MB</span><br><span class="line">ubuntu                                            latest              c9d990395902        32 hours ago        113MB</span><br><span class="line">centos                                            latest              e934aafc2206        7 days ago          199MB</span><br><span class="line">registry                                          latest              d1fd7d86a825        3 months ago        33.3MB</span><br><span class="line">index.tenxcloud.com/tenxcloud/centos              latest              6e7516266d96        23 months ago       310MB</span><br></pre></td></tr></table></figure><h2 id="搭建本地私有仓库"><a href="#搭建本地私有仓库" class="headerlink" title="搭建本地私有仓库"></a>搭建本地私有仓库</h2><h3 id="1、使用registry镜像创建私有仓库"><a href="#1、使用registry镜像创建私有仓库" class="headerlink" title="1、使用registry镜像创建私有仓库"></a>1、使用registry镜像创建私有仓库</h3><p>安装Docker后，可以通过官方提供的<code>registry</code>镜像来简单搭建一套本地私有仓库环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//在本地启动registry镜像，作为私有服务器，监听5000端口</span><br><span class="line">[root@xxx ~]# docker run -d -p 5000:5000 registry</span><br><span class="line">Unable to find image &apos;registry:latest&apos; locally</span><br><span class="line">latest: Pulling from library/registry</span><br><span class="line">81033e7c1d6a: Pull complete </span><br><span class="line">b235084c2315: Pull complete </span><br><span class="line">c692f3a6894b: Pull complete </span><br><span class="line">ba2177f3a70e: Pull complete </span><br><span class="line">a8d793620947: Pull complete </span><br><span class="line">Digest: sha256:672d519d7fd7bbc7a448d17956ebeefe225d5eb27509d8dc5ce67ecb4a0bce54</span><br><span class="line">Status: Downloaded newer image for registry:latest</span><br><span class="line">67083c200be2f6a043377a9b4d69af24d0ba9c58a140b753634f5be4ede67464</span><br></pre></td></tr></table></figure><p>这将自动下载并启动一个<code>registry</code>容器，创建本地的私有仓库服务。默认情况下，会将仓库创建在容器的<code>/tmp/registry</code>目录下。可以通过-v参数来将镜像文件存放在本地的指定路径。例如以下实例将上传的镜像放到<code>/opt/data/registry</code>目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//在本地启动registry镜像，作为私有服务器，监听5000端口,并指定本地目录数据卷/opt/data/registry，映射容器内/tmp/registry目录</span><br><span class="line">[root@xxx ~]# docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry</span><br><span class="line">5b9a1ad53352c4e3a6f5bf7d70ef9a6d573cb4da064fb24f8f406444d125555c</span><br></pre></td></tr></table></figure><h3 id="2、管理私有仓库"><a href="#2、管理私有仓库" class="headerlink" title="2、管理私有仓库"></a>2、管理私有仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//标记镜像</span><br><span class="line">[root@xxx ~]# docker tag xymtest:0.1 192.168.206.128:5000/test</span><br><span class="line"></span><br><span class="line">//上传镜像</span><br><span class="line">[root@xxx ~]# docker push 192.168.206.128:5000/test</span><br><span class="line">The push refers to repository [192.168.206.128:5000/test]</span><br><span class="line">Get https://192.168.206.128:5000/v2/: http: server gave HTTP response to HTTPS client</span><br><span class="line"></span><br><span class="line">//编辑daemon.json,配置，&quot;insecure-registries&quot;:[&quot;192.168.206.128:5000&quot;]，表示信任这个私有仓库，不进行安全证书检查</span><br><span class="line">[root@xxx docker]# pwd</span><br><span class="line">/etc/docker</span><br><span class="line">[root@xxx docker]# cat daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  //表示信任这个私有仓库，不进行安全证书检查</span><br><span class="line">  &quot;insecure-registries&quot;:[&quot;192.168.206.128:5000&quot;],</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://4vehewku.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//重启docker 服务</span><br><span class="line">[root@xxx docker]# systemctl restart docker</span><br><span class="line"></span><br><span class="line">//推送本地镜像到私有仓库</span><br><span class="line">[root@xxx docker]# docker push 192.168.206.128:5000/test</span><br><span class="line">The push refers to repository [192.168.206.128:5000/test]</span><br><span class="line">6d7697f5e458: Pushed </span><br><span class="line">a8de0e025d94: Pushed </span><br><span class="line">a5e66470b281: Pushed </span><br><span class="line">ac7299292f8b: Pushed </span><br><span class="line">e1a9a6284d0d: Pushed </span><br><span class="line">fccbfa2912f0: Pushed </span><br><span class="line">latest: digest: sha256:46d25028e0eb194348b8b1256b1375238b44116a018de67f3318a1bb9954ee9d size: 1564</span><br><span class="line"></span><br><span class="line">//下载刚刚上传的，私有仓库镜像</span><br><span class="line">[root@xxx docker]# docker pull 192.168.206.128:5000/test</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from test</span><br><span class="line">Digest: sha256:46d25028e0eb194348b8b1256b1375238b44116a018de67f3318a1bb9954ee9d</span><br><span class="line">Status: Downloaded newer image for 192.168.206.128:5000/test:latest</span><br></pre></td></tr></table></figure><p>如果要使用安全证书，我们也可以从较知名的CA服务商（如<code>verisign</code>）申请公开的<code>SSL/TLS</code>证书，或者使用<code>openssl</code>等软件自行生成。</p>]]></content>
    
    <summary type="html">
    
      Docker入门指南，仓库概念及基本操作。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="docker仓库" scheme="http://xym-loveit.github.io/tags/docker%E4%BB%93%E5%BA%93/"/>
    
      <category term="login命令" scheme="http://xym-loveit.github.io/tags/login%E5%91%BD%E4%BB%A4/"/>
    
      <category term="search命令" scheme="http://xym-loveit.github.io/tags/search%E5%91%BD%E4%BB%A4/"/>
    
      <category term="pull命令" scheme="http://xym-loveit.github.io/tags/pull%E5%91%BD%E4%BB%A4/"/>
    
      <category term="本地搭建私有仓库配置" scheme="http://xym-loveit.github.io/tags/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E9%85%8D%E7%BD%AE/"/>
    
      <category term="时速云镜像仓库" scheme="http://xym-loveit.github.io/tags/%E6%97%B6%E9%80%9F%E4%BA%91%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Docker 基本操作之容器</title>
    <link href="http://xym-loveit.github.io/2018/04/13/Docker-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%AE%B9%E5%99%A8/"/>
    <id>http://xym-loveit.github.io/2018/04/13/Docker-基本操作之容器/</id>
    <published>2018-04-13T11:42:56.000Z</published>
    <updated>2018-04-16T16:11:22.620Z</updated>
    
    <content type="html"><![CDATA[<p>容器是Docker的另一个核心概念。简单来说，容器时镜像的一个运行实例。所不同的是，镜像是静态只读文件，而容器带有运行时需要的可写文件层。如果认为虚拟机是模拟运行的一整套操作系统（包括内核、应用运行环境和其他系统环境）和跑在上面的应用，那么Docker容器就是独立运行的一个（或一组）应用，以及它们必须的运行环境。</p><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><h3 id="1、新建容器"><a href="#1、新建容器" class="headerlink" title="1、新建容器"></a>1、新建容器</h3><p>命令格式：<code>docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">      --add-host list                  Add a custom host-to-IP mapping (host:ip)</span><br><span class="line">  -a, --attach list                    Attach to STDIN, STDOUT or STDERR</span><br><span class="line">      --blkio-weight uint16            Block IO (relative weight), between 10 and 1000, or 0 to disable (default 0)</span><br><span class="line">      --blkio-weight-device list       Block IO weight (relative device weight) (default [])</span><br><span class="line">      --cap-add list                   Add Linux capabilities</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure><p>Create命令和后续的run命令支持的选项都十分复杂，主要包括如下几大类：与容器运行模式相关、与容器和环境配置相关、与容器资源限制和安全保护相关。</p><p>Create命令与容器运行模式相关的选项见下图：</p><p><img src="http://op7wplti1.bkt.clouddn.com/1900654235_4b1-i_epub.jpg" alt="Create命令与容器运行模式相关的选项"></p><p>Create命令与容器环境和配置相关选项如下图：</p><p><img src="http://op7wplti1.bkt.clouddn.com/1900654235_4b2-i_epub.jpg" alt="Create命令与容器环境和配置相关选项1"></p><p><img src="http://op7wplti1.bkt.clouddn.com/1900654235_4b2x-i_epub.jpg" alt="Create命令与容器环境和配置相关选项2"></p><p>Create命令与容器资源限制和安全保护相关选项如下图：</p><p><img src="http://op7wplti1.bkt.clouddn.com/1900654235_4b3-i_epub.jpg" alt="Create命令与容器资源限制和安全保护相关选项1"></p><p><img src="http://op7wplti1.bkt.clouddn.com/1900654235_4b3x-i_epub.jpg" alt="Create命令与容器资源限制和安全保护相关选项2"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//根据镜像创建一个容器</span><br><span class="line">[root@xxx /]# docker create -it registry.cn-hangzhou.aliyuncs.com/xym/163ubuntu:14.04 </span><br><span class="line">d26cbeecf22d92fdff515a9bb8146521c8e4c6ea76cf7baab5abebb4b31dfc52</span><br><span class="line"></span><br><span class="line">//查看docker本地所有容器,注意状态为Created</span><br><span class="line">[root@xxx /]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                                                   COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">d26cbeecf22d        registry.cn-hangzhou.aliyuncs.com/xym/163ubuntu:14.04   &quot;/bin/sh -c &apos;/usr/sb…&quot;   8 seconds ago       Created                                 practical_wright</span><br><span class="line"></span><br><span class="line">//使用start启动docker容器</span><br><span class="line">[root@xxx /]# docker start d26</span><br><span class="line">d26</span><br><span class="line"></span><br><span class="line">//查看docker本地所有容器,注意状态为Up</span><br><span class="line">[root@xxx /]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                                                   COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">d26cbeecf22d        registry.cn-hangzhou.aliyuncs.com/xym/163ubuntu:14.04   &quot;/bin/sh -c &apos;/usr/sb…&quot;   41 seconds ago      Up 2 seconds                            practical_wright</span><br></pre></td></tr></table></figure><p>其他比较重要的选项还包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-l，--label=[]：以键值对方式指定容器的标签信息;</span><br><span class="line"></span><br><span class="line">--label-file=[]：从文件读取标签信息。</span><br></pre></td></tr></table></figure><h3 id="2、启动容器"><a href="#2、启动容器" class="headerlink" title="2、启动容器"></a>2、启动容器</h3><p>命令格式：<code>docker start [OPTIONS] CONTAINER [CONTAINER...]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//查看本地所有Docker容器，注意状态为Exited</span><br><span class="line">[root@xxx /]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                                                   COMMAND                  CREATED             STATUS                       PORTS               NAMES</span><br><span class="line">d26cbeecf22d        registry.cn-hangzhou.aliyuncs.com/xym/163ubuntu:14.04   &quot;/bin/sh -c &apos;/usr/sb…&quot;   14 minutes ago      Exited (137) 5 seconds ago                       practical_wright</span><br><span class="line"></span><br><span class="line">//使用start启动容器</span><br><span class="line">[root@xxx /]# docker start d26cb</span><br><span class="line">d26cb</span><br><span class="line"></span><br><span class="line">//查看本地所有Docker容器，注意状态为Up</span><br><span class="line">[root@xxx /]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                                                   COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">d26cbeecf22d        registry.cn-hangzhou.aliyuncs.com/xym/163ubuntu:14.04   &quot;/bin/sh -c &apos;/usr/sb…&quot;   14 minutes ago      Up 2 seconds</span><br></pre></td></tr></table></figure><h3 id="3、新建并启动容器"><a href="#3、新建并启动容器" class="headerlink" title="3、新建并启动容器"></a>3、新建并启动容器</h3><p>除了创建容器后通过start命令来启动，也可以直接新建并启动容器。所需要的命令主要为<code>docker run</code>,等价于先执行<code>docker create</code>命令，再执行<code>docker start</code>命令。<br>例如，下面的命令输出一个“Hello World”，之后容器自动终止：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//创建容器并执行一个输出命令</span><br><span class="line">[root@xxx /]# docker run ubuntu:latest /bin/echo &quot;Hello World&quot;</span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line">//查看本地所有Docker容器，注意状态为Exited</span><br><span class="line">[root@xxx /]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">3fa47db4c105        ubuntu:latest       &quot;/bin/echo &apos;Hello Wo…&quot;   8 seconds ago       Exited (0) 7 seconds ago                       elated_goldwasser</span><br></pre></td></tr></table></figure><p>这跟在本地直接执行<code>/bin/echo &quot;Hello World&quot;</code>几乎感觉不出任何区别。当利用<code>docker run</code>来创建并启动容器时，Docker在后台运行的标准操作：  </p><ul><li>检查本地是否存在指定的镜像，不存在就从共有仓库下载；</li><li>利用镜像创建容器，并启动该容器；</li><li>分配一个文件系统给容器，并在只读的镜像层外面挂载一层可读写层；</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中；</li><li>从网桥的地址池配置一个IP地址给容器；</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被自动终止</li></ul><p>启动一个终端，并允许用户进行交互：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//其中-t选项当Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上，-i则让容器的标准输入保持打开。</span><br><span class="line">[root@xxx /]# docker run -it ubuntu:latest /bin/bash</span><br><span class="line">root@21536661367e:/# pwd</span><br><span class="line">/</span><br><span class="line"></span><br><span class="line">//用户可以在交互模式下输入系统命令进行操作</span><br><span class="line">root@21536661367e:/# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line"></span><br><span class="line">//用户可以在交互模式下输入系统命令进行操作，使用ps可以看到系统只运行了bash应用，并没有运行其他无关的进程</span><br><span class="line">root@21536661367e:/# ps</span><br><span class="line">   PID TTY          TIME CMD</span><br><span class="line">     1 pts/0    00:00:00 bash</span><br><span class="line">    10 pts/0    00:00:00 ps</span><br><span class="line">    </span><br><span class="line">//用户可以输入exit或ctrl+d来退出容器</span><br><span class="line">root@21536661367e:/# exit</span><br><span class="line">exit</span><br><span class="line">[root@xxx /]#</span><br></pre></td></tr></table></figure><p>对于所创建的bash容器，当使用exit命令退出之后，容器就自动处于退出（Exited）状态了。这是因为对Docker容器来说，当运行的应用退出后，容器也就没有必要继续运行了。<br>某些时候，执行<code>docker run</code>会出错，因为命令无法正常执行容器会直接退出，此时可以查看退出的错误代码。  </p><ul><li>125：Docker daemon执行出错，例如指定了不支持的Docker命令参数；</li><li>126：所指定的命令无法执行，例如权限出错。</li><li>127：容器内命令无法找到；</li></ul><p>命令执行出错后，会默认返回错误码。</p><h3 id="4、守护态运行"><a href="#4、守护态运行" class="headerlink" title="4、守护态运行"></a>4、守护态运行</h3><p>更多的时候，需要让Docker容器在后台以守护态（Daemonized）形式运行。此时，可以通过添加-d参数来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//-d参数以后台模式启动Docker，返回容器id</span><br><span class="line">[root@xxx ~]# docker run -d ubuntu:latest /bin/sh -c &quot;while true;do echo hello world;sleep 1;done&quot;</span><br><span class="line">5d4cfe5b4b6109fd8df8717fcd87790e7692f70d7e8e8d7590ba4c269f6dd717</span><br><span class="line"></span><br><span class="line">//通过docker ps查看运行的容器</span><br><span class="line">[root@xxx ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">5d4cfe5b4b61        ubuntu:latest       &quot;/bin/sh -c &apos;while t…&quot;   13 seconds ago      Up 12 seconds                           thirsty_lewin</span><br><span class="line"></span><br><span class="line">//使用docker logs命令获取容器输出信息</span><br><span class="line">[root@xxx ~]# docker logs 5d4c</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h2 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h2><p>命令格式：<code>docker stop [OPTIONS] CONTAINER [CONTAINER...]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  -t, --time int   Seconds to wait for stop before killing it (default 10)</span><br></pre></td></tr></table></figure></p><p>原理：首先向容器发送SIGTERM信号,等待一段超时时间（默认10秒）后，再发送SIGKILL信号来终止容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//终止前</span><br><span class="line">[root@xxx ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">5d4cfe5b4b61        ubuntu:latest       &quot;/bin/sh -c &apos;while t…&quot;   16 minutes ago      Up 16 minutes                           thirsty_lewin</span><br><span class="line"></span><br><span class="line">//发送终止命令</span><br><span class="line">[root@xxx ~]# docker stop 5d4c</span><br><span class="line">5d4c</span><br><span class="line"></span><br><span class="line">//终止后状态为Exited</span><br><span class="line">[root@xxx ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                        PORTS               NAMES</span><br><span class="line">5d4cfe5b4b61        ubuntu:latest       &quot;/bin/sh -c &apos;while t…&quot;   18 minutes ago      Exited (137) 56 seconds ago                       thirsty_lewin</span><br></pre></td></tr></table></figure></p><ul><li>使用<code>docker kill</code>命令会直接发送SIGKILL信号来强行终止容器。</li><li>当容器中指定的应用终结时，容器也会自动终止。</li><li>使用<code>docker start</code>可以重新启动处于终止状态的容器。</li><li>使用<code>docker restart</code>命令会将一个运行态的容器先终止，然后再重新启动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//重新启动已终止的容器</span><br><span class="line">[root@xxx ~]# docker start 5d4c</span><br><span class="line">5d4c</span><br><span class="line"></span><br><span class="line">//查看运行的容器</span><br><span class="line">[root@xxx ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">5d4cfe5b4b61        ubuntu:latest       &quot;/bin/sh -c &apos;while t…&quot;   25 minutes ago      Up 6 seconds                            thirsty_lewin</span><br><span class="line"></span><br><span class="line">//发送SIGKILL信号来强行终止容器</span><br><span class="line">[root@xxx ~]# docker kill 5d4c</span><br><span class="line">5d4c</span><br><span class="line"></span><br><span class="line">//查看运行容器</span><br><span class="line">[root@xxx ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line"></span><br><span class="line">//重启容器</span><br><span class="line">[root@xxx ~]# docker restart 5d4c</span><br><span class="line">5d4c</span><br><span class="line"></span><br><span class="line">//查看运行容器</span><br><span class="line">[root@xxx ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">5d4cfe5b4b61        ubuntu:latest       &quot;/bin/sh -c &apos;while t…&quot;   25 minutes ago      Up 1 second                             thirsty_lewin</span><br></pre></td></tr></table></figure><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>在使用-d参数时，容器启动后会进入后台，用户无法看到容器中的信息，也无法操作。这个时候如果要进入容器进行操作，有三种方法：</p><h3 id="1、使用attach命令"><a href="#1、使用attach命令" class="headerlink" title="1、使用attach命令"></a>1、使用attach命令</h3><p>命令格式：<code>docker attach [OPTIONS] CONTAINER</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">      --detach-keys string   指定退出attach模式的快捷键序列，默认是ctrl+q ctrl+p;</span><br><span class="line">      --no-stdin             是否关闭标准输入，默认是保持打开</span><br><span class="line">      --sig-proxy            是否代理收到的系统信号给应用进程，默认为true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@xxx ~]# docker run -itd ubuntu /bin/bash</span><br><span class="line">3535fd6c5ccab3c4d4737c1385ac18c36bd190c129c70c664fbf8c62a1707e67</span><br><span class="line">[root@xxx ~]# docker attach 3535</span><br><span class="line">root@3535fd6c5cca:/# </span><br><span class="line">root@3535fd6c5cca:/# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure></p><p>attach命令缺点：当多个窗口同时用attach命令连到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时，其他窗口也无法执行操作了。</p><h3 id="2、使用exec命令（exec命令用于从外部运行容器内部的命令）"><a href="#2、使用exec命令（exec命令用于从外部运行容器内部的命令）" class="headerlink" title="2、使用exec命令（exec命令用于从外部运行容器内部的命令）"></a>2、使用exec命令（exec命令用于从外部运行容器内部的命令）</h3><p>命令格式：<code>docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  -d, --detach               以后台模式运行命令</span><br><span class="line">      --detach-keys string   Override the key sequence for detaching a container</span><br><span class="line">  -e, --env list             设置环境变量</span><br><span class="line">  -i, --interactive          打开标准输入接受用户输入命令，默认为false</span><br><span class="line">      --privileged           Give extended privileges to the command</span><br><span class="line">  -t, --tty                  分配一个伪终端，默认为false</span><br><span class="line">  -u, --user string          执行命令的用户名或ID</span><br><span class="line">  -w, --workdir string       Working directory inside the container</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@xxx ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">5d4cfe5b4b61        ubuntu:latest       &quot;/bin/sh -c &apos;while t…&quot;   About an hour ago   Up About a minute                       thirsty_lewin</span><br><span class="line"></span><br><span class="line">//使用exec进入后台运行的镜像中</span><br><span class="line">[root@xxx ~]# docker exec -it thirsty_lewin /bin/bash</span><br><span class="line">root@5d4cfe5b4b61:/#</span><br></pre></td></tr></table></figure></p><p>通过以上可以看出，一个bash终端被打开了，在不影响容器内其他应用的前提下，用户可以很容易与容器进行交互。</p><p>注意：通过指定<code>-it</code>参数来保持标准输入打开，并且分配一个伪终端。通过<code>exec</code>命令对容器执行操作是最为推荐的方式。</p><h3 id="3、使用第三方nsenter工具"><a href="#3、使用第三方nsenter工具" class="headerlink" title="3、使用第三方nsenter工具"></a>3、使用第三方<code>nsenter</code>工具</h3><p>在<code>util-linux</code>软件包版本2.23+中包含<code>nsenter</code>工具，如果系统中的<code>util-linux</code>包没有该命令，可以按照下面方式从源码安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ cd /emp;curl https://mirrors.edge.kernel.org/pub/linux/utils/util-linux/v2.32/util-linux-2.32.tar.gz | tar -zxvf;</span><br><span class="line">cd util-linux-2.32;</span><br><span class="line"></span><br><span class="line">$ ./configure --without-ncurses</span><br><span class="line"></span><br><span class="line">$ make nsenter &amp;&amp; cp nsenter /usr/local/bin</span><br></pre></td></tr></table></figure><p>为了使用<code>nsenter</code> 连接到容器，还需要找到容器PID，可以通过下面的命令获取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//获取容器运行PID</span><br><span class="line">PID=$(docker inspect --format&quot;&#123;% raw %&#125;&#123;&#123;.State.Pid&#125;&#125;&#123;% endraw %&#125;&quot; &lt;container&gt;)</span><br><span class="line"></span><br><span class="line">//通过PID，连接到容器：</span><br><span class="line">`nsenter --target $PID --mount --uts --ipc --net --pid`</span><br></pre></td></tr></table></figure><p>下面使用完整的命令执行该操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//查看运行容器</span><br><span class="line">[root@xxx ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">5d4cfe5b4b61        ubuntu:latest       &quot;/bin/sh -c &apos;while t…&quot;   About an hour ago   Up 4 minutes                            thirsty_lewin</span><br><span class="line"></span><br><span class="line">//查看运行容器进程PID</span><br><span class="line">[root@xxx ~]# docker inspect --format &quot;&#123;% raw %&#125;&#123;&#123;.State.Pid&#125;&#125;&#123;% endraw %&#125;&quot; thirsty_lewin</span><br><span class="line">18637</span><br><span class="line"></span><br><span class="line">//进入容器</span><br><span class="line">[root@xxx ~]# nsenter --target 18637 --mount --uts --ipc --net --pid</span><br><span class="line">mesg: ttyname failed: No such file or directory</span><br><span class="line"></span><br><span class="line">//查看用户</span><br><span class="line">root@5d4cfe5b4b61:~# w</span><br><span class="line"> 15:22:55 up 15:59,  0 users,  load average: 0.03, 0.04, 0.05</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br></pre></td></tr></table></figure><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>可以使用docker rm命令来删除处于终止或退出状态的容器。</p><p>命令格式：<code>docker rm [OPTIONS] CONTAINER [CONTAINER...]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -f, --force     强制终止并删除一个运行中的容器</span><br><span class="line">  -l, --link      删除容器的连接但保留容器</span><br><span class="line">  -v, --volumes   删除容器挂载的数据卷</span><br><span class="line"></span><br><span class="line">//查看运行中的容器</span><br><span class="line">[root@xxx ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">5d4cfe5b4b61        ubuntu:latest       &quot;/bin/sh -c &apos;while t…&quot;   About an hour ago   Up 14 minutes                           thirsty_lewin</span><br><span class="line"></span><br><span class="line">//删除运行状态的容器</span><br><span class="line">[root@xxx ~]# docker rm 5d4c</span><br><span class="line">Error response from daemon: You cannot remove a running container 5d4cfe5b4b6109fd8df8717fcd87790e7692f70d7e8e8d7590ba4c269f6dd717. Stop the container before attempting removal or force remove</span><br><span class="line"></span><br><span class="line">//强制删除运行状态的容器</span><br><span class="line">[root@xxx ~]# docker rm -f 5d4c</span><br><span class="line">5d4c</span><br></pre></td></tr></table></figure><h2 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h2><p>某些时候，需要将容器从一个系统迁移到另外一个系统，此时可以使用docker的导入和导出功能。</p><h3 id="1、导出容器"><a href="#1、导出容器" class="headerlink" title="1、导出容器"></a>1、导出容器</h3><p>导出容器是指导出一个已经创建的容器到一个文件，不管此时这个容器是否处于运行状态。<br>命令格式：<code>docker export [OPTIONS] CONTAINER</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  -o, --output string  指定导出的tar归档文件，也可直接通过重定向来实现。</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">//显示所有容器</span><br><span class="line">[root@xxx ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                    PORTS               NAMES</span><br><span class="line">684d1d0dc403        ubuntu:latest       &quot;/bin/sh -c &apos;while t…&quot;   19 seconds ago      Up 18 seconds                                 vigorous_brahmagupta</span><br><span class="line">3fa47db4c105        ubuntu:latest       &quot;/bin/echo &apos;Hello Wo…&quot;   11 hours ago        Exited (0) 11 hours ago                       elated_goldwasser</span><br><span class="line"></span><br><span class="line">//将运行中的容器导出tar文件</span><br><span class="line">[root@xx ~]# docker export -o test_for_run.tar 684d</span><br><span class="line"></span><br><span class="line">//将已经退出的容器导出tar文件</span><br><span class="line">[root@xxx ~]# docker export 3fa4 &gt; test_for_stop.tar</span><br></pre></td></tr></table></figure><p>之后，可将导出的tar文件传输到其他机器上，然后再通过导入命令导入到系统中，从而实现容器的迁移。</p><h3 id="2、导入容器"><a href="#2、导入容器" class="headerlink" title="2、导入容器"></a>2、导入容器</h3><p>导出的文件又可以使用<code>docker import</code>命令导入变成镜像。<br>命令格式：<code>docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  -c, --change list      在导入的同时执行对容器进行修改的Dockerfile指令</span><br><span class="line">  -m, --message string   Set commit message for imported image</span><br><span class="line"></span><br><span class="line">//将tar文件导入系统中</span><br><span class="line">[root@xxx ~]# docker import test_for_run.tar xym/ubuntu:1.0</span><br><span class="line">sha256:f916030e78e9046defa752bfc32a99b96460e098d3ee1cab1a5048150255d27e</span><br><span class="line"></span><br><span class="line">[root@xxx ~]# docker images</span><br><span class="line">REPOSITORY                                        TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">xym/ubuntu                                        1.0                 f916030e78e9        2 seconds ago       85.8MB</span><br><span class="line">centos-7                                          import              be5e039acd03        19 hours ago        435MB</span><br></pre></td></tr></table></figure><p>之前镜像章节中介绍过使用<code>docker load</code>命令来导入一个镜像文件，与<code>docker import</code>命令十分类似。</p><p>实际上，既可以使用<code>docker load</code>命令来导入镜像存储文件到本地镜像库，也可以使用<code>docker import</code>命令来导入一个容器快照到本地镜像库。</p><p>这二者的区别在于容器快照文件将丢弃所有历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也更大。此外，从容器快照文件导入时可以重新指定标签。</p>]]></content>
    
    <summary type="html">
    
      Docker入门指南，容器各种操作命令。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="rm命令" scheme="http://xym-loveit.github.io/tags/rm%E5%91%BD%E4%BB%A4/"/>
    
      <category term="import命令" scheme="http://xym-loveit.github.io/tags/import%E5%91%BD%E4%BB%A4/"/>
    
      <category term="docker容器" scheme="http://xym-loveit.github.io/tags/docker%E5%AE%B9%E5%99%A8/"/>
    
      <category term="create命令" scheme="http://xym-loveit.github.io/tags/create%E5%91%BD%E4%BB%A4/"/>
    
      <category term="start命令" scheme="http://xym-loveit.github.io/tags/start%E5%91%BD%E4%BB%A4/"/>
    
      <category term="run命令" scheme="http://xym-loveit.github.io/tags/run%E5%91%BD%E4%BB%A4/"/>
    
      <category term="stop命令" scheme="http://xym-loveit.github.io/tags/stop%E5%91%BD%E4%BB%A4/"/>
    
      <category term="restart命令" scheme="http://xym-loveit.github.io/tags/restart%E5%91%BD%E4%BB%A4/"/>
    
      <category term="attach命令" scheme="http://xym-loveit.github.io/tags/attach%E5%91%BD%E4%BB%A4/"/>
    
      <category term="exec命令" scheme="http://xym-loveit.github.io/tags/exec%E5%91%BD%E4%BB%A4/"/>
    
      <category term="export命令" scheme="http://xym-loveit.github.io/tags/export%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Docker 基本操作之镜像</title>
    <link href="http://xym-loveit.github.io/2018/04/13/Docker-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%B9%8B%E9%95%9C%E5%83%8F/"/>
    <id>http://xym-loveit.github.io/2018/04/13/Docker-基本操作之镜像/</id>
    <published>2018-04-13T01:24:54.000Z</published>
    <updated>2018-04-14T16:55:47.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>命令格式：<code>docker pull [OPTIONS] NAME[:TAG|@DIGEST]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  -a, --all-tags               是否获取仓库中所有镜像，默认为否</span><br><span class="line">      --disable-content-trust  是否跳过镜像校验，默认为是</span><br></pre></td></tr></table></figure></p><ul><li>如果不显示指定TAG，默认拉取latest</li><li>镜像文件是由若干层（layer）组成，层的唯一标识是以一个256比特的64个十六进程字符构成。使用docker pull下载时会获取各层的信息。当不同的镜像包括相同的层时，本地仅会存储层的一份内容，减小了需要的存储空间。</li><li>当仓库地址（registry，注册服务器）省略不写时，默认使用<code>docker hub</code>服务器，如果从非官方仓库下载，则需要在仓库名称前指定完整的镜像注册服务器地址（e.g. hub.c.163.com/library/）。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//去网易蜂巢拉取镜像仓库  </span><br><span class="line">[root@xxx ~]# docker pull hub.c.163.com/library/memcached:latest </span><br><span class="line">latest: Pulling from library/memcached</span><br><span class="line">810fd2d89f8f: Pull complete </span><br><span class="line">0f1e2d8abe76: Pull complete </span><br><span class="line">b9608bffd4d0: Pull complete </span><br><span class="line">a6554c2d9f43: Pull complete </span><br><span class="line">40661d641679: Pull complete </span><br><span class="line">Digest: sha256:537918e564521a6aa1d4da202e33af500ecfcb4ab9be78d5a6f222ef919b3ba9</span><br><span class="line">Status: Downloaded newer image for hub.c.163.com/library/memcached:latest</span><br></pre></td></tr></table></figure><h2 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h2><p>命令格式：<code>docker images [OPTIONS] [REPOSITORY[:TAG]]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  -a, --all             显示所有镜像（包括临时文件），默认为否</span><br><span class="line">      --digests         列出镜像的数字摘要值，默认为否</span><br><span class="line">  -f, --filter filter   过滤列出的镜像</span><br><span class="line">      --format string   控制输出格式</span><br><span class="line">      --no-trunc        对输出结果中太长部分是否进行截断，如镜像ID信息，默认为是</span><br><span class="line">  -q, --quiet           仅输出ID信息，默认为否</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------------</span><br><span class="line">[root@xxx ~]# docker images</span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                            7                   0b99289e40ee        About an hour ago   435MB</span><br><span class="line">test                              0.1                 ff67a67177d8        About an hour ago   222MB</span><br><span class="line">hello-world                       latest              e38bc07ac18e        32 hours ago        1.85kB</span><br><span class="line">ubuntu                            14.04               a35e70164dfb        5 weeks ago         222MB</span><br><span class="line">hub.c.163.com/library/memcached   latest              8b057b9de580        7 months ago        58.6MB</span><br><span class="line">hub.c.163.com/public/ubuntu       14.04               2fe5c4bba1f9        2 years ago         237MB</span><br><span class="line">163ubuntu                         14.04               2fe5c4bba1f9        2 years ago         237MB</span><br></pre></td></tr></table></figure><ul><li>REPOSITORY:来源于哪个仓库，比如Ubuntu仓库用来保存Ubuntu系列的基础镜像。</li><li>TAG：镜像标签信息，用来标注不同的版本信息。如：14.04、latest等。</li><li>IMAGE ID：镜像的ID（唯一标识镜像），如hub.c.163.com/public/ubuntu：14.04和163ubuntu：14.04镜像的ID都是2fe5c4bba1f9，说明目前他们指向同一个镜像</li><li>CREATED：说明镜像的更新时间</li><li>镜像大小，优秀的镜像往往体积都较小</li></ul><p>其中镜像的ID信息十分重要，它唯一标识了镜像。在使用镜像ID的时候，一般可以使用该ID的前若干个字符组成的可区分串来替代完整的ID。</p><p>TAG信息用来标识来自同一个仓库的不同镜像。例如ubuntu仓库中有多个镜像，通过TAG信息来区分发行版本，包括10.04、12.04、12.10、14.04等标签。</p><p>镜像大小信息只是表示该镜像的逻辑体积大小，实际上由于相同的镜像本地只会存储一份，物理占用的存储空间会小于各镜像的逻辑体积之和。</p><p>更多子命令选项还可以通过<code>man docker-images</code>帮助命令来查看。</p><h2 id="使用tag命令添加镜像标签"><a href="#使用tag命令添加镜像标签" class="headerlink" title="使用tag命令添加镜像标签"></a>使用tag命令添加镜像标签</h2><p>命令格式：<code>docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx ~]# docker tag hub.c.163.com/public/ubuntu:14.04 163ubuntu:14.04 </span><br><span class="line">[root@xxx ~]# docker images</span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                            7                   0b99289e40ee        About an hour ago   435MB</span><br><span class="line">test                              0.1                 ff67a67177d8        2 hours ago         222MB</span><br><span class="line">hello-world                       latest              e38bc07ac18e        32 hours ago        1.85kB</span><br><span class="line">ubuntu                            14.04               a35e70164dfb        5 weeks ago         222MB</span><br><span class="line">hub.c.163.com/library/memcached   latest              8b057b9de580        7 months ago        58.6MB</span><br><span class="line">163ubuntu                         14.04               2fe5c4bba1f9        2 years ago         237MB</span><br><span class="line">hub.c.163.com/public/ubuntu       14.04               2fe5c4bba1f9        2 years ago         237MB</span><br><span class="line">[root@xxx ~]#</span><br></pre></td></tr></table></figure><p>为了方便后续工作中使用特定镜像，还可以使用docker tag命令来为本地镜像任意添加新的标签。例如添加一个新的<code>163ubuntu:14.04</code>镜像标签。之后用户就可以直接使用<code>163ubuntu:14.04</code>来表示这个镜像了。观察<code>163ubuntu:14.04</code>的ID跟源镜像<code>hub.c.163.com/public/ubuntu:14.04</code>完全一致。他们实际上指向同一个镜像文件，只是别名不同而已。<code>docker tag</code>命令添加的标签实际上起到了类似连接的作用。</p><h2 id="使用inspect命令查看详细信息"><a href="#使用inspect命令查看详细信息" class="headerlink" title="使用inspect命令查看详细信息"></a>使用inspect命令查看详细信息</h2><p>命令格式：<code>docker inspect [OPTIONS] NAME|ID [NAME|ID...]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  -f, --format string   使用指定的模板，格式化输出</span><br><span class="line">  -s, --size            如果是容器类型，表示其总大小</span><br><span class="line">      --type string     返回指定类型的json格式</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx ~]# docker inspect 163ubuntu:14.04 </span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;sha256:2fe5c4bba1f935f179e83cd5354403d1231ffc9df9c1621967194410eaf8d942&quot;,</span><br><span class="line">        &quot;RepoTags&quot;: [</span><br><span class="line">            &quot;163ubuntu:14.04&quot;,</span><br><span class="line">            &quot;hub.c.163.com/public/ubuntu:14.04&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;RepoDigests&quot;: [</span><br><span class="line">            &quot;hub.c.163.com/public/ubuntu@sha256:ffc2fc66f8e0bfa4b417b817054d3ebec130c8db44342b8fa394e25779633257&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;Parent&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Comment&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2016-03-16T03:29:48.276492132Z&quot;,</span><br><span class="line">        &quot;Container&quot;: &quot;f807d2c2c41cc21db9201605a962047278719a09cb945d0a3d5a2a587d978769&quot;,</span><br><span class="line">        &quot;ContainerConfig&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;f807d2c2c41c&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;Tty&quot;: false,</span><br><span class="line">            &quot;OpenStdin&quot;: false,</span><br><span class="line">            &quot;StdinOnce&quot;: false,</span><br><span class="line">            &quot;Env&quot;: [],</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;/bin/sh&quot;,</span><br><span class="line">                &quot;-c&quot;,</span><br><span class="line">                &quot;#(nop) ENTRYPOINT &amp;&#123;[\&quot;/bin/sh\&quot; \&quot;-c\&quot; \&quot;/usr/sbin/sshd -D\&quot;]&#125;&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Image&quot;: &quot;7c5c7629089e80dea49161f10c36678cc8934601a730f8f8eb2a58d2e14c6610&quot;,</span><br><span class="line">            &quot;Volumes&quot;: null,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: [</span><br><span class="line">                &quot;/bin/sh&quot;,</span><br><span class="line">                &quot;-c&quot;,</span><br><span class="line">                &quot;/usr/sbin/sshd -D&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;OnBuild&quot;: null,</span><br><span class="line">            &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;DockerVersion&quot;: &quot;1.9.1&quot;,</span><br><span class="line">        &quot;Author&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Config&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;f807d2c2c41c&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;Tty&quot;: false,</span><br><span class="line">            &quot;OpenStdin&quot;: false,</span><br><span class="line">            &quot;StdinOnce&quot;: false,</span><br><span class="line">            &quot;Env&quot;: [],</span><br><span class="line">            &quot;Cmd&quot;: null,</span><br><span class="line">            &quot;Image&quot;: &quot;7c5c7629089e80dea49161f10c36678cc8934601a730f8f8eb2a58d2e14c6610&quot;,</span><br><span class="line">            &quot;Volumes&quot;: null,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: [</span><br><span class="line">                &quot;/bin/sh&quot;,</span><br><span class="line">                &quot;-c&quot;,</span><br><span class="line">                &quot;/usr/sbin/sshd -D&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;OnBuild&quot;: null,</span><br><span class="line">            &quot;Labels&quot;: &#123;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Architecture&quot;: &quot;amd64&quot;,</span><br><span class="line">        &quot;Os&quot;: &quot;linux&quot;,</span><br><span class="line">        &quot;Size&quot;: 237059566,</span><br><span class="line">        &quot;VirtualSize&quot;: 237059566,</span><br><span class="line">        &quot;GraphDriver&quot;: &#123;</span><br><span class="line">            &quot;Data&quot;: &#123;</span><br><span class="line">                &quot;DeviceId&quot;: &quot;27&quot;,</span><br><span class="line">                &quot;DeviceName&quot;: &quot;docker-253:0-102127602-c30e1cbfce6f98d947b8df2100734cddf113980a3ccdb356a1b84f27825a3dbe&quot;,</span><br><span class="line">                &quot;DeviceSize&quot;: &quot;10737418240&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Name&quot;: &quot;devicemapper&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;RootFS&quot;: &#123;</span><br><span class="line">            &quot;Type&quot;: &quot;layers&quot;,</span><br><span class="line">            &quot;Layers&quot;: [</span><br><span class="line">                &quot;sha256:89688d062a0607fb50d0955de8964659e66f1bb41164b2d2b473d1edd7d8af90&quot;,</span><br><span class="line">                &quot;sha256:704e51eef17861bc3a2a7355709a7ce0b11ab720cc1b0e00235f984b33494b0e&quot;,</span><br><span class="line">                &quot;sha256:98b4fca781e7eab1cfb4d6427b60c4490b4c7d71a0bca622c7dd03cecb657a6d&quot;,</span><br><span class="line">                &quot;sha256:a695e8d298aaf8ee68638151e6068518475130eccdd224ba0591981f212e5ea2&quot;,</span><br><span class="line">                &quot;sha256:836a329bec9925c8fc76232885344a0053d19534ae108e5cbc111490481b5778&quot;,</span><br><span class="line">                &quot;sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Metadata&quot;: &#123;</span><br><span class="line">            &quot;LastTagTime&quot;: &quot;2018-04-13T10:03:07.660866339+08:00&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>更多用法请使用<code>man docker-inspect</code>帮助命令。</p><h2 id="使用history命令查看镜像历史"><a href="#使用history命令查看镜像历史" class="headerlink" title="使用history命令查看镜像历史"></a>使用history命令查看镜像历史</h2><p>命令格式：<code>docker history [OPTIONS] IMAGE</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">      --format string   指定格式化模板输出</span><br><span class="line">  -H, --human           Print sizes and dates in human readable format (default true)</span><br><span class="line">      --no-trunc        Don&apos;t truncate output</span><br><span class="line">  -q, --quiet           Only show numeric IDs</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx ~]# docker history 163ubuntu:14.04 </span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">2fe5c4bba1f9        2 years ago         /bin/sh -c #(nop) ENTRYPOINT &amp;&#123;[&quot;/bin/sh&quot; &quot;-…   0B                  </span><br><span class="line">&lt;missing&gt;           2 years ago         /bin/sh -c sed -i &apos;s/#PasswordAuthentication…   2.54kB              </span><br><span class="line">&lt;missing&gt;           2 years ago         /bin/sh -c mkdir /var/run/sshd                  0B                  </span><br><span class="line">&lt;missing&gt;           2 years ago         /bin/sh -c apt-get update &amp;&amp; apt-get install…   69.3MB              </span><br><span class="line">&lt;missing&gt;           2 years ago         /bin/sh -c #(nop) ADD file:b7283a2724cc73e4c…   872B                </span><br><span class="line">&lt;missing&gt;           2 years ago         /bin/sh -c #(nop) ADD file:9f6d0ad171ede3597…   168MB</span><br></pre></td></tr></table></figure><h2 id="镜像搜寻"><a href="#镜像搜寻" class="headerlink" title="镜像搜寻"></a>镜像搜寻</h2><p>命令格式：<code>docker search [OPTIONS] TERM</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print search using a Go template</span><br><span class="line">      --limit int       Max number of search results (default 25)</span><br><span class="line">      --no-trunc        Don&apos;t truncate output</span><br><span class="line">      </span><br><span class="line">      Filter</span><br><span class="line">             Filter output based on these conditions:</span><br><span class="line">                - stars=&lt;numberOfStar&gt; 指定仅显示评价为指定星级以上的镜像，默认为0，即输出所有镜像</span><br><span class="line">                - is-automated=(true|false) 仅显示自动创建的镜像，默认为否</span><br><span class="line">                - is-official=(true|false) 仅显示官方的镜像，默认为否</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//搜索所有自动创建且评价为20+的带nginx关键字的镜像</span><br><span class="line">[root@xxx ~]# docker search --filter=is-automated=true --filter=stars=20 nginx</span><br><span class="line">NAME                                                   DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">jwilder/nginx-proxy                                    Automated Nginx reverse proxy for docker con…   1315                                    [OK]</span><br><span class="line">richarvey/nginx-php-fpm                                Container running Nginx + PHP-FPM capable of…   544                                     [OK]</span><br><span class="line">jrcs/letsencrypt-nginx-proxy-companion                 LetsEncrypt container to use with nginx as p…   348                                     [OK]</span><br><span class="line">webdevops/php-nginx                                    Nginx with PHP-FPM                              99                                      [OK]</span><br><span class="line">zabbix/zabbix-web-nginx-mysql                          Zabbix frontend based on Nginx web-server wi…   49                                      [OK]</span><br><span class="line">bitnami/nginx                                          Bitnami nginx Docker Image                      48                                      [OK]</span><br><span class="line">1and1internet/ubuntu-16-nginx-php-phpmyadmin-mysql-5   ubuntu-16-nginx-php-phpmyadmin-mysql-5          33                                      [OK]</span><br></pre></td></tr></table></figure><ul><li>NAME：镜像名字</li><li>DESCRIPTION：描述</li><li>STARS：星级（表示该镜像受欢迎程度）</li><li>OFFICIAL：是否官方创建</li><li>AUTOMATED：是否自动创建</li></ul><p>默认结果按照星级评价进行排序。</p><h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p>命令格式：<code>docker rmi [OPTIONS] IMAGE [IMAGE...]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  -f, --force      强制删除</span><br><span class="line">      --no-prune   Do not delete untagged parents</span><br></pre></td></tr></table></figure></p><h3 id="使用标签删除镜像"><a href="#使用标签删除镜像" class="headerlink" title="使用标签删除镜像"></a>使用标签删除镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//删除前查看镜像</span><br><span class="line">[root@xxx ~]# docker images</span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                            7                   0b99289e40ee        2 hours ago         435MB</span><br><span class="line">test                              0.1                 ff67a67177d8        3 hours ago         222MB</span><br><span class="line">hello-world                       latest              e38bc07ac18e        33 hours ago        1.85kB</span><br><span class="line">ubuntu                            14.04               a35e70164dfb        5 weeks ago         222MB</span><br><span class="line">hub.c.163.com/library/memcached   latest              8b057b9de580        7 months ago        58.6MB</span><br><span class="line">163ubuntu                         14.04               2fe5c4bba1f9        2 years ago         237MB</span><br><span class="line">hub.c.163.com/public/ubuntu       14.04               2fe5c4bba1f9        2 years ago         237MB</span><br><span class="line">//删除镜像操作</span><br><span class="line">[root@xxx ~]# docker rmi 163ubuntu:14.04 </span><br><span class="line">Untagged: 163ubuntu:14.04</span><br><span class="line">//删除后查看镜像</span><br><span class="line">[root@xxx ~]# docker images</span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                            7                   0b99289e40ee        2 hours ago         435MB</span><br><span class="line">test                              0.1                 ff67a67177d8        3 hours ago         222MB</span><br><span class="line">hello-world                       latest              e38bc07ac18e        33 hours ago        1.85kB</span><br><span class="line">ubuntu                            14.04               a35e70164dfb        5 weeks ago         222MB</span><br><span class="line">hub.c.163.com/library/memcached   latest              8b057b9de580        7 months ago        58.6MB</span><br><span class="line">hub.c.163.com/public/ubuntu       14.04               2fe5c4bba1f9        2 years ago         237MB</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：当同一个镜像拥有多个标签的时候，docker rmi命令只是删除该镜像多个标签中的指定标签而已，并不影响镜像文件。因此上述操作相当于只是删除了镜像<code>2fe5c4bba1f9</code>的一个标签而已。但当镜像只剩下一个标签的时候就要小心了,此时再使用<code>docker rmi</code>命令会彻底删除镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx ~]# docker rmi hub.c.163.com/library/memcached:latest </span><br><span class="line">Untagged: hub.c.163.com/library/memcached:latest</span><br><span class="line">Untagged: hub.c.163.com/library/memcached@sha256:537918e564521a6aa1d4da202e33af500ecfcb4ab9be78d5a6f222ef919b3ba9</span><br><span class="line">Deleted: sha256:8b057b9de580ce01fdce47c7ca1632ce03b925f9464afc0d91821b066f32204d</span><br><span class="line">Deleted: sha256:0382f79fb93ba9f862822a9c594019a32a39f5d46321e242a388c2e455d369e6</span><br><span class="line">Deleted: sha256:7f7bc5c738d847e3e2e647b467d3bb363bbbc99f53649cba7df71c2326fc183d</span><br><span class="line">Deleted: sha256:1c3bf91649b76e0956ab416404cb81bb30f1be5377316af42ecf680cb50c2d34</span><br><span class="line">Deleted: sha256:bbebfa4c46fd5f64fc0e0d71fc5c94448fa04fa0b20b74dc97ad0ec07cd8ff45</span><br><span class="line">Deleted: sha256:eb78099fbf7fdc70c65f286f4edc6659fcda510b3d1cfe1caa6452cc671427bf</span><br></pre></td></tr></table></figure><p>例如删除标签为<code>hub.c.163.com/library/memcached:latest</code>的镜像，由于该镜像没有额外的标签指向它，执行<code>docker rmi</code>命令，可以看出它会删除这个镜像文件的所有层。</p><h3 id="使用镜像ID删除镜像"><a href="#使用镜像ID删除镜像" class="headerlink" title="使用镜像ID删除镜像"></a>使用镜像ID删除镜像</h3><p>当使用docker rmi命令，并且后面跟上镜像的ID（也可能是能进行区分的部分ID串前缀）时，先会尝试删除所有指向该镜像的标签，然后删除该镜像本身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//删除前查看镜像</span><br><span class="line">[root@xxx ~]# docker images</span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                            7                   0b99289e40ee        3 hours ago         435MB</span><br><span class="line">test                              0.1                 ff67a67177d8        3 hours ago         222MB</span><br><span class="line">hello-world                       latest              e38bc07ac18e        33 hours ago        1.85kB</span><br><span class="line">ubuntu                            14.04               a35e70164dfb        5 weeks ago         222MB</span><br><span class="line">hub.c.163.com/library/memcached   latest              8b057b9de580        7 months ago        58.6MB</span><br><span class="line">163mem                            latest              8b057b9de580        7 months ago        58.6MB</span><br><span class="line">hub.c.163.com/public/ubuntu       14.04               2fe5c4bba1f9        2 years ago         237MB</span><br><span class="line"></span><br><span class="line">//通过镜像ID删除镜像，提示多个镜像引用此镜像ID，必须使用-f 参数强制删除</span><br><span class="line">[root@xxx ~]# docker rmi 8b057b9de580</span><br><span class="line">Error response from daemon: conflict: unable to delete 8b057b9de580 (must be forced) - image is referenced in multiple repositories</span><br><span class="line">[root@xxx ~]# docker rmi -f 8b057b9de580</span><br><span class="line">Untagged: 163mem:latest</span><br><span class="line">Untagged: hub.c.163.com/library/memcached:latest</span><br><span class="line">Untagged: hub.c.163.com/library/memcached@sha256:537918e564521a6aa1d4da202e33af500ecfcb4ab9be78d5a6f222ef919b3ba9</span><br><span class="line">Deleted: sha256:8b057b9de580ce01fdce47c7ca1632ce03b925f9464afc0d91821b066f32204d</span><br><span class="line">Deleted: sha256:0382f79fb93ba9f862822a9c594019a32a39f5d46321e242a388c2e455d369e6</span><br><span class="line">Deleted: sha256:7f7bc5c738d847e3e2e647b467d3bb363bbbc99f53649cba7df71c2326fc183d</span><br><span class="line">Deleted: sha256:1c3bf91649b76e0956ab416404cb81bb30f1be5377316af42ecf680cb50c2d34</span><br><span class="line">Deleted: sha256:bbebfa4c46fd5f64fc0e0d71fc5c94448fa04fa0b20b74dc97ad0ec07cd8ff45</span><br><span class="line">Deleted: sha256:eb78099fbf7fdc70c65f286f4edc6659fcda510b3d1cfe1caa6452cc671427bf</span><br><span class="line"></span><br><span class="line">//删除后查看镜像列表，发现与此ID关联的镜像都已删除成功</span><br><span class="line">[root@xxx ~]# docker images</span><br><span class="line">REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                        7                   0b99289e40ee        3 hours ago         435MB</span><br><span class="line">test                          0.1                 ff67a67177d8        3 hours ago         222MB</span><br><span class="line">hello-world                   latest              e38bc07ac18e        33 hours ago        1.85kB</span><br><span class="line">ubuntu                        14.04               a35e70164dfb        5 weeks ago         222MB</span><br><span class="line">hub.c.163.com/public/ubuntu   14.04               2fe5c4bba1f9        2 years ago         237MB</span><br></pre></td></tr></table></figure></p><p><strong>注意</strong>：当有该镜像创建的容器存在时，镜像文件是无法被删除的，如要删除该镜像请先删除该容器，然后再删除镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//使用镜像运行容器</span><br><span class="line">[root@xxx ~]# docker run ubuntu:14.04 echo &quot;Hello&quot;</span><br><span class="line">Hello</span><br><span class="line">//查看所有状态容器</span><br><span class="line">[root@xxx ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                               COMMAND                  CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">8bdb6f330ec9        ubuntu:14.04                        &quot;echo Hello&quot;             7 seconds ago       Exited (0) 6 seconds ago                       determined_varahamihira</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//使用标签删除镜像，提示被容器引用</span><br><span class="line">[root@xxx ~]# docker rmi ubuntu:14.04 </span><br><span class="line">Error response from daemon: conflict: unable to remove repository reference &quot;ubuntu:14.04&quot; (must force) - container 8bdb6f330ec9 is using its referenced image a35e70164dfb</span><br><span class="line"></span><br><span class="line">//无法强制删除</span><br><span class="line">[root@xxx ~]# docker rmi -f a35e70164dfb</span><br><span class="line">Error response from daemon: conflict: unable to delete a35e70164dfb (cannot be forced) - image has dependent child images</span><br><span class="line"></span><br><span class="line">//删除容器</span><br><span class="line">[root@xxx ~]# docker rm 8bdb6</span><br><span class="line">8bdb6</span><br><span class="line"></span><br><span class="line">//成功删除镜像</span><br><span class="line">[root@xxx ~]# docker rmi ubuntu:14.04 </span><br><span class="line">Untagged: ubuntu:14.04</span><br><span class="line">Untagged: ubuntu@sha256:ed49036f63459d6e5ed6c0f238f5e94c3a0c70d24727c793c48fded60f70aa96</span><br></pre></td></tr></table></figure><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>创建镜像的方法有三种：基于已有镜像的容器创建、基于本地模板导入、基于Dockerfile创建。<br>先介绍前二种创建方式</p><h3 id="基于已有镜像的容器创建"><a href="#基于已有镜像的容器创建" class="headerlink" title="基于已有镜像的容器创建"></a>基于已有镜像的容器创建</h3><p>命令格式：<code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  -a, --author string    作者信息</span><br><span class="line">  -c, --change list      提交的时候指定Dockerfile指令，包括CMD/ENTRYPOINT/ENV/EXPOSE/LABEL/ONBUILD/USER/VOLUME/WORKDIR等</span><br><span class="line">  -m, --message string   提交信息</span><br><span class="line">  -p, --pause            提交时暂停容器运行</span><br></pre></td></tr></table></figure><p>下面将演示如何使用该命令创建一个新镜像。首先，启动一个镜像，并在其中进行修改操作，例如创建一个test文件，之后推出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx ~]# docker run -it ubuntu:latest /bin/bash</span><br><span class="line">root@72ed7e58bc28:/# touch test</span><br><span class="line">root@72ed7e58bc28:/# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure></p><p>记住此时的容器ID为：<code>72ed7e58bc28</code>,此时容器跟原<code>ubuntu:latest</code>镜像相比，已经发生了变化，可以使用docker commit命令来提交为一个新的镜像。提交的时候可以使用ID或名称来指定容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx ~]# docker commit -m &quot;提交一个新镜像&quot; -a &quot;xym&quot; 72ed7e58bc28 xymtest:0.1</span><br><span class="line">sha256:8a758d16a99b414b738bee50b485c3d99f6093c0c4002efd9dd5dd740efd2ee9</span><br><span class="line">[root@xxx ~]# docker images</span><br><span class="line">REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">xymtest                       0.1                 8a758d16a99b        26 seconds ago      113MB</span><br><span class="line">centos                        7                   0b99289e40ee        4 hours ago         435MB</span><br><span class="line">test                          0.1                 ff67a67177d8        4 hours ago         222MB</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="基于本地模板导入"><a href="#基于本地模板导入" class="headerlink" title="基于本地模板导入"></a>基于本地模板导入</h3><p>用户也可以直接从一个操作系统模板文件导入一个镜像。</p><p>命令格式：<code>docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  -c, --change list      导入时候指定Dockerfile指令，包括CMD/ENTRYPOINT/ENV/EXPOSE/LABEL/ONBUILD/USER/VOLUME/WORKDIR等</span><br><span class="line">  -m, --message string   提交信息</span><br></pre></td></tr></table></figure></p><p>要直接导入一个镜像，可以使用OpenVZ提供的模板来创建，或者用其他已导出的镜像模板来创建。OpenVZ模板的下载地址为：<a href="https://openvz.org/Download/template/precreated" target="_blank" rel="noopener">https://openvz.org/Download/template/precreated</a></p><p>例如：下载了<code>centos-7-x86_64-minimal.tar.gz</code>模板压缩包，之后使用以下命令导入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx ~]# cat centos-7-x86_64-minimal.tar.gz | docker import - centos-7:import</span><br><span class="line">sha256:be5e039acd03e1c3489841f6edd244954a4c1eb534de7fff605d807136b7e735</span><br><span class="line">[root@xxx ~]# docker images</span><br><span class="line">REPOSITORY                    TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">centos-7                      import              be5e039acd03        About a minute ago   435MB</span><br><span class="line">xymtest                       0.1                 8a758d16a99b        18 minutes ago       113MB</span><br><span class="line">centos                        7                   0b99289e40ee        4 hours ago          435MB</span><br><span class="line">test                          0.1                 ff67a67177d8        4 hours ago          222MB</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="存出和载入镜像"><a href="#存出和载入镜像" class="headerlink" title="存出和载入镜像"></a>存出和载入镜像</h2><p>可以使用<code>docker save</code> 和<code>docker load</code>命令来存出和载入镜像。</p><h3 id="存出镜像"><a href="#存出镜像" class="headerlink" title="存出镜像"></a>存出镜像</h3><p>命令格式：<code>docker save [OPTIONS] IMAGE [IMAGE...]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  -o, --output string   写出目标文件</span><br></pre></td></tr></table></figure></p><p>如果要导出镜像到本地文件，可以使用<code>docker save</code>命令。例如，导出本地的<code>163ubuntu:14.04</code>镜像为文件<code>163ubuntu_14.04.tar</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx ~]# docker save -o 163ubuntu_14.04.tar 163ubuntu:14.04 </span><br><span class="line">[root@xxx ~]# ls -t</span><br><span class="line">163ubuntu_14.04.tar ...</span><br></pre></td></tr></table></figure></p><p>之后，用户就可以通过复制该文件（163ubuntu_14.04.tar）将镜像分享给其他人。</p><h3 id="载入镜像"><a href="#载入镜像" class="headerlink" title="载入镜像"></a>载入镜像</h3><p>命令格式：<code>docker load [OPTIONS]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">  -i, --input string   指定要导入的tar归档镜像文件</span><br><span class="line">  -q, --quiet          Suppress the load output</span><br></pre></td></tr></table></figure></p><p>可以通过<code>docker load</code> 将导出的tar文件再导入到本地镜像库，例如从文件<code>163ubuntu_14.04.tar</code>导入镜像到本地镜像列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx ~]# docker load --input 163ubuntu_14.04.tar </span><br><span class="line">Loaded image: 163ubuntu:14.04</span><br><span class="line"></span><br><span class="line">或者可以使用</span><br><span class="line"></span><br><span class="line">[root@xxx ~]# docker load &lt; 163ubuntu_14.04.tar </span><br><span class="line">Loaded image: 163ubuntu:14.04</span><br></pre></td></tr></table></figure><p>这将导入镜像及其相关元数据信息（包括标签等）。</p><h2 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h2><p>命令格式：<code>docker push [OPTIONS] NAME[:TAG]|[REGISTRY_HOST[:REGISTRY_PORT]/]NAME[:TAG]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line">      --disable-content-trust   Skip image signing (default true)</span><br></pre></td></tr></table></figure></p><p>可以使用<code>docker push</code>命令上传镜像到仓库，默认上传到<code>Docker Hub</code>官方仓库（需要登录）。<br>用户在<code>Docker Hub网站</code>注册后可以上传自制镜像。<strong>例如用户user上传本地的test:latest镜像，可以先添加新的标签user/test:latest,然后用docker push命令上传镜像</strong>：</p><h4 id="上传镜像到网易蜂巢docker"><a href="#上传镜像到网易蜂巢docker" class="headerlink" title="上传镜像到网易蜂巢docker"></a>上传镜像到网易蜂巢docker</h4><p>参见官网操作文档：<a href="https://www.163yun.com/help/documents/15587826830438400" target="_blank" rel="noopener">https://www.163yun.com/help/documents/15587826830438400</a></p><p>1、登录网易云镜像仓库<br>docker login -u {你的网易云邮箱账号或手机号码} -p {你的网易云密码} hub.c.163.com</p><p>返回「Login Succeded」即为登录成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx /]# docker login hub.c.163.com</span><br><span class="line">Username: xxx@126.com（你的账号）        </span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Are you sure you want to proceed? [y/N] y</span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure><ul><li>2、标记本地镜像<br>docker tag {镜像名或ID} hub.c.163.com/{你的用户名}/{标签名}</li></ul><p>你的网易云镜像仓库推送地址为 hub.c.163.com/{你的用户名}/{标签名}</p><p>Attention: 此处为你的用户名，不是你的邮箱帐号或者手机号码 登录网易云控制台，页面右上角头像右侧即为「用户名」</p><p>推送至不存在的镜像仓库时，自动创建镜像仓库并保存新推送的镜像版本；<br>推送至已存在的镜像仓库时，在该镜像仓库中保存新推送的版本，当版本号相同时覆盖原有镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx /]# docker tag hub.c.163.com/public/ubuntu:14.04 hub.c.163.com/xxx/163ubuntu:14.04</span><br><span class="line">[root@xxx /]# docker images</span><br><span class="line">REPOSITORY                          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">163ubuntu                           14.04               2fe5c4bba1f9        2 years ago         237MB</span><br><span class="line">hub.c.163.com/public/ubuntu         14.04               2fe5c4bba1f9        2 years ago         237MB</span><br><span class="line">hub.c.163.com/xxx/163ubuntu   14.04               2fe5c4bba1f9        2 years ago         237MB</span><br></pre></td></tr></table></figure><ul><li><ol start="3"><li>推送至网易云镜像仓库<br>docker push hub.c.163.com/{你的用户名}/{标签名}</li></ol></li></ul><p>默认为私有镜像仓库，推送成功后即可在控制台的「镜像仓库」查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx /]# docker push hub.c.163.com/xxx/163ubuntu:14.04 </span><br><span class="line">The push refers to repository [hub.c.163.com/xxx/163ubuntu]</span><br><span class="line">5f70bf18a086: Pushed </span><br><span class="line">836a329bec99: Pushed </span><br><span class="line">a695e8d298aa: Pushed </span><br><span class="line">98b4fca781e7: Pushed </span><br><span class="line">704e51eef178: Pushed </span><br><span class="line">89688d062a06: Pushed </span><br><span class="line">14.04: digest: sha256:c6740481ffab5f07e8785e6f07d5e2bec8ba9436d67f6e686d0fe1bf65c651be size: 4031</span><br></pre></td></tr></table></figure><h4 id="上传镜像到阿里云"><a href="#上传镜像到阿里云" class="headerlink" title="上传镜像到阿里云"></a>上传镜像到阿里云</h4><blockquote><p>Docker的镜像存储中心通常被称为Registry。<br>当您需要获取Docker镜像的时候，首先需要登录Registry，然后拉取镜像。在您修改过镜像之后，您可以再次将镜像推送到Registry中去。</p><p>Docker的镜像地址是什么？我们来看一个完整的例子。（以容器服务的公共镜像为例）<br>registry.cn-hangzhou.aliyuncs.com/acs/agent:0.8</p><p>registry.cn-hangzhou.aliyuncs.com 叫做 “Registry域名”。<br>acs 叫做 “命名空间”。<br>agent 叫做 “仓库名称”。<br>0.8 叫做 “Tag”、”镜像标签”（非必须，默认latest）。<br>将这个几个完全独立的概念组合一下，还有几个术语。<br>registry.cn-hangzhou.aliyuncs.com/acs/agent 称为 “仓库坐标”。<br>acs/agent 称为 “仓库全名”（通常在API中使用）。</p></blockquote><p>参见文档：<a href="https://yq.aliyun.com/articles/70756" target="_blank" rel="noopener">https://yq.aliyun.com/articles/70756</a></p><p>了解相关说明后发现，阿里云有一个”命名空间”的概念，所以<strong>要想上传自己的镜像，请先去个人中心创建命名空间</strong>。</p><p>比如：当前创建的命名空间为<code>xym</code>,则通过以下命令即可将自己的镜像上传到命名空间</p><ul><li>1、docker login 以阿里云杭州公网Registry为例：登陆时必须指明登陆的 “Registry域名”</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx /]# docker login registry.cn-hangzhou.aliyuncs.com</span><br><span class="line">Username: xxx</span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Are you sure you want to proceed? [y/N] y</span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure><ul><li><p>2、标记本地镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//注意这里的xym为：命名空间</span><br><span class="line">[root@xxx /]# docker tag hub.c.163.com/public/ubuntu:14.04 registry.cn-hangzhou.aliyuncs.com/xym/163ubuntu:14.04</span><br><span class="line">[root@xxx /]# docker images</span><br><span class="line">REPOSITORY                                        TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                                            7                   0b99289e40ee        6 hours ago         435MB</span><br><span class="line">ubuntu                                            latest              c9d990395902        12 hours ago        113MB</span><br><span class="line">hub.c.163.com/public/ubuntu                       14.04               2fe5c4bba1f9        2 years ago         237MB</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/xym/163ubuntu   14.04               2fe5c4bba1f9        2 years ago         237MB</span><br></pre></td></tr></table></figure></li><li><ol start="3"><li>推送至阿里云<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx /]# docker push registry.cn-hangzhou.aliyuncs.com/xym/163ubuntu</span><br><span class="line">The push refers to repository [registry.cn-hangzhou.aliyuncs.com/xym/163ubuntu]</span><br><span class="line">5f70bf18a086: Pushed </span><br><span class="line">836a329bec99: Pushed </span><br><span class="line">a695e8d298aa: Pushed </span><br><span class="line">98b4fca781e7: Pushed </span><br><span class="line">704e51eef178: Pushed </span><br><span class="line">89688d062a06: Pushed </span><br><span class="line">14.04: digest: sha256:ef619091bc47f4b82ce4e984668ee96a2447f244bbd73fbaffe103605c454c28 size: 1569</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>登录控制台查看推送结果。</p><h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p>参见阿里控制台，CentOS 镜像加速器帮助说明:</p><blockquote><p>针对Docker客户端版本大于1.10.0的用户</p></blockquote><blockquote><p>您可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器：<br>sudo mkdir -p /etc/docker<br>sudo tee /etc/docker/daemon.json &lt;&lt;-‘EOF’<br>{<br>  “registry-mirrors”: [“<a href="https://4vehewku.mirror.aliyuncs.com&quot;]" target="_blank" rel="noopener">https://4vehewku.mirror.aliyuncs.com&quot;]</a><br>}<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker</p></blockquote><p>其他情况请自行 <a href="https://www.google.com" target="_blank" rel="noopener">google</a></p>]]></content>
    
    <summary type="html">
    
      Docker入门指南，各镜像操作命令，上传镜像到镜像服务器（阿里云、网易蜂巢等云平台）详细步骤。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="search命令" scheme="http://xym-loveit.github.io/tags/search%E5%91%BD%E4%BB%A4/"/>
    
      <category term="pull命令" scheme="http://xym-loveit.github.io/tags/pull%E5%91%BD%E4%BB%A4/"/>
    
      <category term="docker镜像" scheme="http://xym-loveit.github.io/tags/docker%E9%95%9C%E5%83%8F/"/>
    
      <category term="images命令" scheme="http://xym-loveit.github.io/tags/images%E5%91%BD%E4%BB%A4/"/>
    
      <category term="tag命令" scheme="http://xym-loveit.github.io/tags/tag%E5%91%BD%E4%BB%A4/"/>
    
      <category term="inspect命令" scheme="http://xym-loveit.github.io/tags/inspect%E5%91%BD%E4%BB%A4/"/>
    
      <category term="history命令" scheme="http://xym-loveit.github.io/tags/history%E5%91%BD%E4%BB%A4/"/>
    
      <category term="rmi命令" scheme="http://xym-loveit.github.io/tags/rmi%E5%91%BD%E4%BB%A4/"/>
    
      <category term="rm命令" scheme="http://xym-loveit.github.io/tags/rm%E5%91%BD%E4%BB%A4/"/>
    
      <category term="commit命令" scheme="http://xym-loveit.github.io/tags/commit%E5%91%BD%E4%BB%A4/"/>
    
      <category term="import命令" scheme="http://xym-loveit.github.io/tags/import%E5%91%BD%E4%BB%A4/"/>
    
      <category term="save命令" scheme="http://xym-loveit.github.io/tags/save%E5%91%BD%E4%BB%A4/"/>
    
      <category term="load命令" scheme="http://xym-loveit.github.io/tags/load%E5%91%BD%E4%BB%A4/"/>
    
      <category term="push命令" scheme="http://xym-loveit.github.io/tags/push%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud常见问题总结</title>
    <link href="http://xym-loveit.github.io/2018/04/11/Spring-Cloud%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://xym-loveit.github.io/2018/04/11/Spring-Cloud常见问题总结/</id>
    <published>2018-04-11T13:01:13.000Z</published>
    <updated>2018-04-11T16:08:27.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Eureka常见问题"><a href="#Eureka常见问题" class="headerlink" title="Eureka常见问题"></a>Eureka常见问题</h2><h3 id="Eureka注册服务慢"><a href="#Eureka注册服务慢" class="headerlink" title="Eureka注册服务慢"></a>Eureka注册服务慢</h3><p>默认情况下，服务注册到Eureka Server的过程慢。在开发或测试时，常常希望能够加速这一过程，从而提升工作效率。Spring Cloud官方详细描述了该问题的原因并提供了解决方案：  </p><blockquote><p>简单翻译：服务注册涉及到周期性心跳，默认30秒一次（通过客户端配置ServiceUrl）。只有当实例、服务端和客户端的本地缓存中的元数据都相同时，服务才能被其他客户端发现（所以可能需要3次心跳）。可以使用参数<code>eureka.instance.leaseRenewalntervalInSeconds</code>修改时间间隔，从而加快客户端连接到其他服务的过程。在生产环境中最好坚持使用默认值，因为在服务器内部有一些计算，他们会对续约作出假设。</p></blockquote><p>综上，要想解决服务注册慢的问题，只须将<code>eureka.instance.leaseRenewalIntervalInSeconds</code>设定一个更小的值。该配置用于设置Eureka Client向Eureka Server发送心跳的时间间隔，默认30秒。在生产环境中，建议坚持使用默认值。</p><blockquote><p>原文来自：<a href="https://cloud.spring.io/spring-cloud-netflix/multi/multi__service_discovery_eureka_clients.html#_why_is_it_so_slow_to_register_a_service" target="_blank" rel="noopener">https://cloud.spring.io/spring-cloud-netflix/multi/multi__service_discovery_eureka_clients.html#_why_is_it_so_slow_to_register_a_service</a></p></blockquote><h3 id="已停止的微服务节点注销慢或不注销"><a href="#已停止的微服务节点注销慢或不注销" class="headerlink" title="已停止的微服务节点注销慢或不注销"></a>已停止的微服务节点注销慢或不注销</h3><p>在开发环境下，常常希望Eureka Server能迅速有效地注销已停止的微服务实例，然而，由于Eureka Server清理无效节点周期长（默认90秒），以及自我保护模式等原因，可能会遇到微服务注销慢甚至不注销的问题。解决方案如下：  </p><ul><li><p>Eureka Server 端：<br>配置关闭自我保护，并按需配置Eureka Server清理无效节点的时间间隔。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eureka.server.enable-self-preservation</span><br><span class="line">#设为false，关闭自我保护，从而保证会注销微服务</span><br><span class="line">eureka.server.eviction-interval-timer-in-ms</span><br><span class="line">#清理间隔（单位毫秒，默认为60*1000）</span><br></pre></td></tr></table></figure></li><li><p>Eureka Client 端<br>配置开启健康检查，并按需配置续约更新时间和到期时间。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eureka.client.healthcheck.enabled</span><br><span class="line">#设置为true,开启健康检查（需要spring-boot-starter-actuator依赖）</span><br><span class="line">eureka.instance.lease-renewal-interval-in-seconds</span><br><span class="line">#续约更新时间间隔（默认30秒）</span><br><span class="line">eureka.instance.lease-expiration-duration-in-seconds</span><br><span class="line">#续约到期时间（默认90秒）</span><br></pre></td></tr></table></figure></li></ul><p>值得注意的是，这些配置仅建议在开发或测试时使用，生产环境建议坚持使用默认值。</p><p><strong>示例</strong></p><ul><li><p>Eureka Server配置：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  server:</span><br><span class="line">    enable-self-preservation: false</span><br><span class="line">    eviction-interval-timer-in-ms: 4000</span><br></pre></td></tr></table></figure></li><li><p>Eureka Client配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    healthcheck:</span><br><span class="line">      enabled: true</span><br><span class="line">  instance:</span><br><span class="line">    lease-expiration-duration-in-seconds: 30</span><br><span class="line">    lease-renewal-interval-in-seconds: 10</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>修改Eureka的续约频率可能会打破Eureka的自我保护特性，详见：<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/373" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-netflix/issues/373</a>。这意味着在生产环境中，如果想要使用Eureka的自我保护特性，应该坚持使用默认配置。</p></blockquote><h3 id="如何自定义微服务的Instance-ID。"><a href="#如何自定义微服务的Instance-ID。" class="headerlink" title="如何自定义微服务的Instance ID。"></a>如何自定义微服务的Instance ID。</h3><p>Instance ID用于唯一标识注册到Eureka Server上的微服务实例。在Eureka Server首页可以直观地看到各个微服务的Instance ID。如下图： </p><p><img src="" alt=""></p><p>在Spring Cloud中，服务的Instance ID的默认值是<code>${spring.cloud.client.hostname}:${spring.application.name}:${server.port}</code>。如果想要自定义这部分内容，只须在微服务中配置<code>eureka.instance.instance-id</code>属性即可，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: microservice-provider-user</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    #将Instance ID设置成 IP:端口的形式 </span><br><span class="line">    instance-id: $&#123;spring.cloud.client.ipAddress&#125;:$&#123;server.port&#125;</span><br></pre></td></tr></table></figure><p>这样，就可将微服务<code>microservice-provider-user</code>的Instance ID设为IP:端口的形式。这样设置后，效果下图所示：  </p><p><img src="" alt=""></p><blockquote><p>Spring Cloud初始化Instance ID的相关代码：<br>org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration<br>org.springframework.cloud.commons.util.IdUtils.getDefaultInstanceId(PropertyResolver resolver);<br>org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean.getInstanceId()</p></blockquote><h3 id="Eureka的UNKNOWN问题总结"><a href="#Eureka的UNKNOWN问题总结" class="headerlink" title="Eureka的UNKNOWN问题总结"></a>Eureka的UNKNOWN问题总结</h3><p>注册信息unknown，是新手常会遇到的问题。如下图，有二种UNKNOWN的情况，一种是应用名称UNKNOWN,另一种是应用状态UNKNOWN。下面分别说明这二种情况。</p><p><img src="" alt=""></p><p><strong>应用名称UNKNOWN</strong></p><p>应用名称UNKNOWN显然不合适，首先微服务的名称不够语义化，无法直接观看出这是哪个服务；更重要的是，我们常常使用应用名称消费对应微服务接口。<br>一般来说，有二种情况会导致该问题的发生：  </p><ul><li>未配置<code>spring.application.name</code>或者<code>eureka.instance.appname</code>属性。如果这两个属性均不配置，就会导致应用名称UNKNOWN的问题。</li><li>某些版本的SpringFox会导致该问题，例如SpringFox2.6.0。建议使用SpringFox2.6.1或更新版本</li></ul><p><strong>微服务实例状态UNKNOWN</strong></p><p>微服务实例的状态UNKNOWN同样很麻烦。一般来讲，只会请求状态是UP的微服务。该问题一般由健康检查导致。<code>eureka.client.healthcheck.enabled=true</code>必须设置在<code>application.yml</code>中，而不能设置在<code>bootstrap.yml</code>中，否则一些场景下会导致应用状态UNKNOWN的问题。</p><blockquote><p>SpringFox是一款基于Spring和Swagger的开源的API文档框架，前身是swagger-springmvc。官网：<a href="http://springfox.github.io/springfox/" target="_blank" rel="noopener">http://springfox.github.io/springfox/</a>。</p></blockquote><h2 id="Hystrix-Feign整合Hystrix后首次请求失败"><a href="#Hystrix-Feign整合Hystrix后首次请求失败" class="headerlink" title="Hystrix/Feign整合Hystrix后首次请求失败"></a>Hystrix/Feign整合Hystrix后首次请求失败</h2><p>某些场景下，Feign或Ribbon整合Hystrix后，会出现首次调用失败的问题。</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>Hystrix默认的超时时间是1秒，如果在1秒内得不到响应，就会进入<code>fallback</code>逻辑。由于Spring的懒加载机制，首次请求往往会比较慢，因此在某些机器（特别是低端的机器）上，首次请求需要的时间可能就会大于1秒。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>方法一：延长Hystrix的超时时间，示例：<br><code>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 5000</code>该配置让Hystrix的超时时间改为5秒 </li><li>方法二：禁用Hystrix的超时，示例：<br><code>hystrix.command.default.execution.timeout.enabled: false</code></li><li>方法三：对于Feign，还可为Feign禁用Hystrix，示例：<br><code>feign.hystrix.enabled: false</code><br>这样即可为Feign全局禁用Hystrix支持，该方式比较极端，一般不建议使用。</li></ul><h2 id="Turbine集合数据不完整"><a href="#Turbine集合数据不完整" class="headerlink" title="Turbine集合数据不完整"></a>Turbine集合数据不完整</h2><p>在某些版本的Spring Cloud（例如Brixton SR5）中，Turbine会发生该问题。该问题直观体现是：使用Turbine聚合了多个微服务，但在Hystrix Dashboard上只能看到部分微服务的监控数据。</p><p>例如Turbine配置如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">turbine:</span><br><span class="line">  app-config: microservice-consumer-movie,microservice-consumer-movie-feign-hystrix-fallback-stream</span><br><span class="line">  cluster-name-expression: &quot;&apos;default&apos;&quot;</span><br></pre></td></tr></table></figure></p><p>Turbine理应聚合<code>microservice-consumer-movie</code>和<code>microservice-consumer-movie-feign-hystrix-fallback-stream</code>这两个微服务的监控数据，然而打开Hystrix Dashboard时，会发现Hystrix Dashboard只显示部分微服务的监控数据。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>当Turbine集合的微服务部署在同一台主机时，就会出现该问题。</p><ul><li><p>方法一：为各个微服务配置不同的<code>hostname</code>。并将<code>preferIpAddress</code>设为false或者不设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://discovery:8761/eureka/</span><br><span class="line">  instance:</span><br><span class="line">    hostname: ribbon #配置hostname</span><br></pre></td></tr></table></figure></li><li><p>方法二：设置<code>turbine.combine-host-port=true</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">turbine:</span><br><span class="line">  app-config: microservice-consumer-movie,microservice-consumer-movie-feign-hystrix-fallback-stream</span><br><span class="line">  cluster-name-expression: &quot;&apos;default&apos;&quot;</span><br><span class="line">  combine-host-port: true</span><br></pre></td></tr></table></figure></li><li><p>方法三：升级Spring Cloud到Camden或更新版本。当然，也可单独升级Spring Cloud Netflix到1.2或更新版本（一般不建议单独升级Spring Cloud Netflix，因为可能会跟Spring Cloud其他组件冲突）。这是因为老版本中的<code>combine-host-port</code>默认值是false。Spring Cloud已经意识到该问题，所以在新的版本中将该属性的默认值修改为true。该方案和方法二本质上是一致的。</p></li></ul><p>相关代码:  </p><blockquote><p>org.springframework.cloud.netflix.turbine.TurbineProperties.combineHostPort<br>org.springframework.cloud.netflix.turbine.CommonsInstanceDiscovery.getInstance(String hostname, String port, String cluster, Boolean status)<br>相关issue：<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/1087" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-netflix/issues/1087</a></p></blockquote><h2 id="Spring-Cloud各组件配置属性"><a href="#Spring-Cloud各组件配置属性" class="headerlink" title="Spring Cloud各组件配置属性"></a>Spring Cloud各组件配置属性</h2><p>Spring Cloud中的大部门问题都可以使用配置属性的方式来解决。下面将配置的地址罗列出来，方便查阅。</p><h3 id="Spring-Cloud的配置"><a href="#Spring-Cloud的配置" class="headerlink" title="Spring Cloud的配置"></a>Spring Cloud的配置</h3><p>Spring Cloud的所有组件配置都在其官方文档的附录，地址如下：  </p><p><a href="http://cloud.spring.io/spring-cloud-static/Camden.SR7/#_appendix_compendium_of_configuration_properties" target="_blank" rel="noopener">http://cloud.spring.io/spring-cloud-static/Camden.SR7/#_appendix_compendium_of_configuration_properties</a></p><h3 id="原生配置"><a href="#原生配置" class="headerlink" title="原生配置"></a>原生配置</h3><p>Spring Cloud 整合了很多类库，例如：<code>Eureka</code>、<code>Ribbon</code>、<code>Feign</code>等。这些组件自身也有一些配置属性，如下：  </p><ul><li>Eureka的配置：<a href="https://github.com/Netflix/eureka/wiki/Configuring-Eureka" target="_blank" rel="noopener">https://github.com/Netflix/eureka/wiki/Configuring-Eureka</a></li><li>Ribbon的配置：<a href="https://github.com/Netflix/ribbon/wiki/Programmers-Guide" target="_blank" rel="noopener">https://github.com/Netflix/ribbon/wiki/Programmers-Guide</a></li><li>Hystrix的配置：<a href="https://github.com/Netflix/Hystrix/wiki/Configuration" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/wiki/Configuration</a></li><li>Turbine的配置：<a href="https://github.com/Netflix/Turbine/wiki/Configuration-(1.x" target="_blank" rel="noopener">https://github.com/Netflix/Turbine/wiki/Configuration-(1.x)</a>)</li></ul><h2 id="Spring-Cloud定位问题的思路"><a href="#Spring-Cloud定位问题的思路" class="headerlink" title="Spring Cloud定位问题的思路"></a>Spring Cloud定位问题的思路</h2><h3 id="1、排查配置问题"><a href="#1、排查配置问题" class="headerlink" title="1、排查配置问题"></a>1、排查配置问题</h3><p>排查配置有无问题，举几个例说明。</p><ul><li>YAML缩进是否正确<ul><li>项目启动报错，错误指向yml文件</li></ul></li><li>配置属性是否正确<ul><li>可以借助IDE提示功能来排查，当IDE不提示或给出警告时，应格外注意。  </li></ul></li><li><p>配置属性的位置是否正确</p><ul><li>应当配置在<code>Eureka Client</code>项目上的属性，配置在了<code>Eureka Server</code>项目上</li><li>应当写在<code>bootstrap.yml</code>中的属性，写在了<code>application.yml</code>中，如：<code>spring.cloud.config.uri=http://localhost:8080</code>     </li><li>应当写在<code>application.yml</code>的属性，写在了<code>bootstrap.yml</code>中，如：<code>eureka.client.healthcheck.enabled-true</code><h3 id="2、排查环境问题"><a href="#2、排查环境问题" class="headerlink" title="2、排查环境问题"></a>2、排查环境问题</h3>如确认配置无误，即可考虑运行环境是否存在问题。</li></ul></li><li><p>环境变量</p><ul><li>当前使用的<code>spring boot maven</code>插件版本需要jdk8支持,在jdk7下报错，需要指定插件版本号，添加<code>&lt;version&gt;</code>配置</li></ul></li><li>依赖下载是否完整<ul><li>启动前使用<code>mvn clean package</code>,确认依赖完整性。</li></ul></li><li>网络问题<ul><li>微服务之间通过网络保持通信，因此，网络常常是排查问题的关键。当问题发生时候，可优先排查网络问题。</li></ul></li></ul><h3 id="3、排查代码问题"><a href="#3、排查代码问题" class="headerlink" title="3、排查代码问题"></a>3、排查代码问题</h3><p>经过以上步骤，依然没有定位到问题，那么可能是编写代码出了问题。很多时候，常常因为少了某个注解，或是依赖缺失，而导致了各种异常。许多场景下，设置合理的日志级别，会对问题的定位有奇效。</p><h3 id="4、排查Spring-Cloud自身问题"><a href="#4、排查Spring-Cloud自身问题" class="headerlink" title="4、排查Spring Cloud自身问题"></a>4、排查Spring Cloud自身问题</h3><p>如果确定不是自身问题，就可以debug一下Spring Cloud的代码。同时，可在github等平台给项目提交issue，然后参考官方回复，尝试规避相应问题。</p><p><strong>可参考资源：</strong></p><blockquote><p>各项自身的github，例如：Eureka的Github：<a href="https://github.com/netflix/eureka" target="_blank" rel="noopener">https://github.com/netflix/eureka</a><br>Spring Cloud对应的项目Github，例如Eureka项目在 Spring Cloud Netflix中：<a href="https://github.com/spring-cloud/spring-cloud-netflix" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-netflix</a></p></blockquote><blockquote><p>Spring Cloud的StackOverflow：<a href="https://stackoverflow.com/questions/tagged/spring-cloud" target="_blank" rel="noopener">https://stackoverflow.com/questions/tagged/spring-cloud</a><br>Spring Cloud的 Gitter<a href="https://gitter.im/spring-cloud/spring-cloud" target="_blank" rel="noopener">https://gitter.im/spring-cloud/spring-cloud</a><br>Spring Cloud中国社区 <a href="http://www.spring4all.com" target="_blank" rel="noopener">http://www.spring4all.com</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      在使用SpringCloud的过程中，可能会遇到一些问题。本文对常见问题做一些总结。
    
    </summary>
    
      <category term="Spring-Cloud系列" scheme="http://xym-loveit.github.io/categories/Spring-Cloud%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Spring-Cloud" scheme="http://xym-loveit.github.io/tags/Spring-Cloud/"/>
    
      <category term="SpringCloud常见问题" scheme="http://xym-loveit.github.io/tags/SpringCloud%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
      <category term="Eureka 配置" scheme="http://xym-loveit.github.io/tags/Eureka-%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Ribbon 配置" scheme="http://xym-loveit.github.io/tags/Ribbon-%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Hystrix 配置" scheme="http://xym-loveit.github.io/tags/Hystrix-%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Turbine 配置" scheme="http://xym-loveit.github.io/tags/Turbine-%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Spring Cloud 配置手册" scheme="http://xym-loveit.github.io/tags/Spring-Cloud-%E9%85%8D%E7%BD%AE%E6%89%8B%E5%86%8C/"/>
    
  </entry>
  
</feed>
