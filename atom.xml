<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>放肆的青春</title>
  
  <subtitle>要变得和大叔一样强</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xym-loveit.github.io/"/>
  <updated>2018-06-22T09:56:35.458Z</updated>
  <id>http://xym-loveit.github.io/</id>
  
  <author>
    <name>xym</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IntelliJ IDEA个人常用配置</title>
    <link href="http://xym-loveit.github.io/2018/06/22/IntelliJ-IDEA%E4%B8%AA%E4%BA%BA%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <id>http://xym-loveit.github.io/2018/06/22/IntelliJ-IDEA个人常用配置/</id>
    <published>2018-06-22T08:12:09.000Z</published>
    <updated>2018-06-22T09:56:35.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h2><h3 id="代码提示"><a href="#代码提示" class="headerlink" title="代码提示"></a>代码提示</h3><p><img src="http://op7wplti1.bkt.clouddn.com/xxvi-a-settings-introduce-1.jpg" alt=""></p><ul><li>IntelliJ IDEA 的代码提示和补充功能有一个特性：区分大小写。如上图标注 1 所示，默认就是 <code>First letter</code> 区分大小写的。</li><li>区分大小写的情况是这样的：比如我们在 Java 代码文件中输入 <code>stringBuffer</code> IntelliJ IDEA 是不会帮我们提示或是代码补充的，但是如果我们输入 <code>StringBuffer</code> 就可以进行代码提示和补充。</li><li>如果想不区分大小写的话，改为 <code>None</code> 选项即可。</li></ul><h3 id="代码检查等级"><a href="#代码检查等级" class="headerlink" title="代码检查等级"></a>代码检查等级</h3><p><img src="http://op7wplti1.bkt.clouddn.com/xxvi-a-settings-introduce-2.gif" alt=""></p><ul><li>如上图 Gif 所示，该功能用来快速设置代码检查等级。我个人一般在编辑大文件的时候会使用该功能。IntelliJ IDEA 对于编辑大文件并没有太大优势，很卡，原因就是它有各种检查，这样是非常耗内存和 CPU 的，所以为了能加快大文件的读写，我一般会暂时性设置为 <code>None</code>。</li></ul><blockquote><ul><li><code>Inspections</code> 为最高等级检查，可以检查单词拼写，语法错误，变量使用，方法之间调用等。</li><li><code>Syntax</code> 可以检查单词拼写，简单语法错误。</li><li><code>None</code> 不设置检查。</li></ul></blockquote><h3 id="省电模式"><a href="#省电模式" class="headerlink" title="省电模式"></a>省电模式</h3><p><img src="http://op7wplti1.bkt.clouddn.com/xxvi-a-settings-introduce-6.jpg" alt=""></p><blockquote><ul><li>如上图标注 1 所示，IntelliJ IDEA 有一种叫做 <code>省电模式</code> 的状态，开启这种模式之后 IntelliJ IDEA 会关掉代码检查和代码提示等功能。所以一般我也会认为这是一种 <code>阅读模式</code>，如果你在开发过程中遇到突然代码文件不能进行检查和提示可以来看看这里是否有开启该功能。</li></ul></blockquote><h3 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h3><p><img src="https://dancon.gitbooks.io/intellij-idea/content/images/xxvi-a-settings-introduce-9.gif" alt=""></p><ul><li>如上图 Gif 所示，IntelliJ IDEA 支持对代码进行垂直或是水平分组。一般在对大文件进行修改的时候，有些修改内容在文件上面，有些内容在文件下面，如果来回操作可能效率会很低，用此方法就可以好很多。当然了，前提是自己的显示器分辨率要足够高。</li></ul><h3 id="代码提示快捷键"><a href="#代码提示快捷键" class="headerlink" title="代码提示快捷键"></a>代码提示快捷键</h3><p><img src="http://op7wplti1.bkt.clouddn.com/xxvi-a-settings-introduce-13.gif" alt=""></p><blockquote><ul><li>如上图 Gif 所示，默认 <code>Ctrl + 空格</code> 快捷键是基础代码提示、补充快捷键，但是由于我们中文系统基本这个快捷键都被输入法占用了，所以我们发现不管怎么按都是没有提示代码效果的，原因就是在此。我个人建议修改此快捷键为 <code>Ctrl + 逗号</code>。</li></ul></blockquote><h3 id="显示内存"><a href="#显示内存" class="headerlink" title="显示内存"></a>显示内存</h3><p><img src="http://op7wplti1.bkt.clouddn.com/xxvi-a-settings-introduce-14.gif" alt=""></p><blockquote><ul><li>如上图 Gif 所示，IntelliJ IDEA 14 版本默认是不显示内存使用情况的，对于大内存的机器来讲不显示也无所谓，但是如果是内存小的机器最好还是显示下。如上图演示，点击后可以进行部分内存的回收。</li></ul></blockquote><h3 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h3><p><img src="http://op7wplti1.bkt.clouddn.com/xxvi-a-settings-introduce-15.jpg" alt=""></p><blockquote><ul><li>如上图标注 1 所示，在打开很多文件的时候，IntelliJ IDEA 默认是把所有打开的文件名 Tab 单行显示的。但是我个人现在的习惯是使用多行，多行效率比单行高，因为单行会隐藏超过界面部分 Tab，这样找文件不方便。</li></ul></blockquote><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p><img src="http://op7wplti1.bkt.clouddn.com/xxvi-a-settings-introduce-16.gif" alt=""></p><blockquote><ul><li>如上图 Gif 所示，默认 IntelliJ IDEA 对于 Java 代码的单行注释是把注释的斜杠放在行数的最开头，我个人觉得这样的单行注释非常丑，整个代码风格很难看，所以一般会设置为单行注释的两个斜杠跟随在代码的头部。</li></ul></blockquote><h3 id="锁定模式（Pinned-Mode-）"><a href="#锁定模式（Pinned-Mode-）" class="headerlink" title="锁定模式（Pinned Mode ）"></a>锁定模式（Pinned Mode ）</h3><p><img src="http://op7wplti1.bkt.clouddn.com/xxvi-a-settings-introduce-24.gif" alt=""></p><p>如上图 Gif 所示，当我们设置了组件窗口的 <code>Pinned Mode</code> 属性之后，在切换到其他组件窗口的时候，已设置该属性的窗口不会自动隐藏 </p><h3 id="显示行数、方法分割"><a href="#显示行数、方法分割" class="headerlink" title="显示行数、方法分割"></a>显示行数、方法分割</h3><p><img src="http://op7wplti1.bkt.clouddn.com/xxvi-a-settings-introduce-29.jpg" alt=""></p><ul><li>如上图红圈所示，默认 IntelliJ IDEA 是没有勾选 <code>Show line numbers</code> 显示行数的，但是我建议一般这个要勾选上。</li><li>如上图红圈所示，默认 IntelliJ IDEA 是没有勾选 <code>Show method separators</code> 显示方法线的，这种线有助于我们区分开方法，所以也是建议勾选上的。</li></ul><h3 id="多模块依赖"><a href="#多模块依赖" class="headerlink" title="多模块依赖"></a>多模块依赖</h3><p><img src="http://op7wplti1.bkt.clouddn.com/xxvi-a-settings-introduce-41.gif" alt=""></p><ul><li>如上图 Gif 所示，这是一个 Maven 多模块项目，在开发多模块的时候，经常会改到其他模块的代码，而模块与模块之间是相互依赖，如果不进行 install 就没办法使用到最新的依赖。</li><li>所以，为了减少自己手动 install 的过程，可以把 install 过程放在项目启动之前，就像 Gif 所示那样。</li></ul><h2 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h2><ol><li><h4 id="ignore"><a href="#ignore" class="headerlink" title=".ignore"></a>.ignore</h4></li><li><h4 id="Free-MyBatis-plugin"><a href="#Free-MyBatis-plugin" class="headerlink" title="Free MyBatis plugin"></a>Free MyBatis plugin</h4></li><li><h4 id="IDEA-Restart"><a href="#IDEA-Restart" class="headerlink" title="IDEA Restart"></a>IDEA Restart</h4></li><li><h4 id="Lombok-Plugin"><a href="#Lombok-Plugin" class="headerlink" title="Lombok Plugin"></a>Lombok Plugin</h4></li><li><h4 id="Maven-Helper"><a href="#Maven-Helper" class="headerlink" title="Maven Helper"></a>Maven Helper</h4></li><li><h4 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h4></li><li><h4 id="String-Manipulation"><a href="#String-Manipulation" class="headerlink" title="String Manipulation"></a>String Manipulation</h4></li><li><h4 id="JRebel-for-IntelliJ"><a href="#JRebel-for-IntelliJ" class="headerlink" title="JRebel for IntelliJ"></a>JRebel for IntelliJ</h4></li><li><h4 id="FindBugs-IDEA"><a href="#FindBugs-IDEA" class="headerlink" title="FindBugs-IDEA"></a>FindBugs-IDEA</h4></li><li><h4 id="Alibaba-Java-Coding-Guidelines"><a href="#Alibaba-Java-Coding-Guidelines" class="headerlink" title="Alibaba Java Coding Guidelines"></a>Alibaba Java Coding Guidelines</h4></li><li><h4 id="Gsonformat"><a href="#Gsonformat" class="headerlink" title="Gsonformat"></a>Gsonformat</h4></li></ol><h2 id="IntelliJ-IDEA-JVM参数调优"><a href="#IntelliJ-IDEA-JVM参数调优" class="headerlink" title="IntelliJ  IDEA JVM参数调优"></a>IntelliJ  IDEA JVM参数调优</h2><blockquote><p><a href="http://xxfox.perfma.com/jvm/generate" target="_blank" rel="noopener">http://xxfox.perfma.com/jvm/generate</a> </p></blockquote><h2 id="IntelliJ-IDEA-License-Server"><a href="#IntelliJ-IDEA-License-Server" class="headerlink" title="IntelliJ  IDEA  License  Server"></a>IntelliJ  IDEA  License  Server</h2><blockquote><p><a href="http://jtb.whoniverse.eu/" target="_blank" rel="noopener">http://jtb.whoniverse.eu/</a></p></blockquote><h2 id="IntelliJ-IDEA-官方权威快捷键"><a href="#IntelliJ-IDEA-官方权威快捷键" class="headerlink" title="IntelliJ IDEA 官方权威快捷键"></a>IntelliJ IDEA 官方权威快捷键</h2><blockquote><p><a href="https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf" target="_blank" rel="noopener">https://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf</a> </p></blockquote><blockquote><p>站在巨人的肩膀上 你会走的更远<br>本教程部分内容引起以下网址<br><a href="https://dancon.gitbooks.io/intellij-idea/content/this-tutorial-the-end.html" target="_blank" rel="noopener">https://dancon.gitbooks.io/intellij-idea/content/this-tutorial-the-end.html</a> 感谢原作者的辛勤付出</p></blockquote>]]></content>
    
    <summary type="html">
    
      换电脑或者重装Idea后，个人常用配置
    
    </summary>
    
      <category term="常用工具" scheme="http://xym-loveit.github.io/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="常用工具" scheme="http://xym-loveit.github.io/tags/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Intellij IDEA 2017集成MyBatis三剑客</title>
    <link href="http://xym-loveit.github.io/2018/05/25/Intellij-IDEA-2017%E9%9B%86%E6%88%90MyBatis%E4%B8%89%E5%89%91%E5%AE%A2/"/>
    <id>http://xym-loveit.github.io/2018/05/25/Intellij-IDEA-2017集成MyBatis三剑客/</id>
    <published>2018-05-25T08:44:00.000Z</published>
    <updated>2018-05-25T09:17:16.753Z</updated>
    
    <content type="html"><![CDATA[<p>MyBatis三剑客指的是：<code>MyBatis-Generate</code>、<code>Mybatis Plus</code>、<code>MyBatis-PageHelper</code></p><h2 id="MyBatis-Generate"><a href="#MyBatis-Generate" class="headerlink" title="MyBatis-Generate"></a>MyBatis-Generate</h2><p>使用 Mybatis Generator 这个maven插件来快速生成 Dao 类, mapper 配置文件和 Model 类.</p><blockquote><p>MyBatis Generator（简称MBG）是MyBatis的代码生成器.可以自动查询数据库中的所有表,然后生成可以访问表的基础对象类型.解决了对数据库操作有最大影响的一些简单的CRUD增删改查操作,但是仍需要对联合查询和存储过程手写SQL语句和对象.</p></blockquote><p><a href="https://www.kancloud.cn/wizardforcel/java-opensource-doc/152983" target="_blank" rel="noopener">MyBatis Generator中文文档</a></p><h4 id="1-在pom文件中添加插件"><a href="#1-在pom文件中添加插件" class="headerlink" title="1.在pom文件中添加插件"></a>1.在pom文件中添加插件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">         &lt;verbose&gt;true&lt;/verbose&gt;</span><br><span class="line">         &lt;overwrite&gt;true&lt;/overwrite&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><h4 id="2-在maven项目中的resource中创建xml文件与properties资源文件"><a href="#2-在maven项目中的resource中创建xml文件与properties资源文件" class="headerlink" title="2.在maven项目中的resource中创建xml文件与properties资源文件"></a>2.在maven项目中的resource中创建xml文件与properties资源文件</h4><p><img src="/assets/img/1.png" alt=""></p><ul><li>名称可以随便取，这里以 generatorConfig.xml 为名</li><li>资源文件为 datasource.properties 文件，这个可不要，这里用是因为方便管理而已</li></ul><h4 id="3-配置generatorConfig-xml与资源文件"><a href="#3-配置generatorConfig-xml与资源文件" class="headerlink" title="3.配置generatorConfig.xml与资源文件"></a>3.配置generatorConfig.xml与资源文件</h4><p><code>generatorConfig.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">    &lt;!--导入属性配置--&gt;</span><br><span class="line">    &lt;properties resource=&quot;datasource.properties&quot;&gt;&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--指定特定数据库的jdbc驱动jar包的位置--&gt;</span><br><span class="line">    &lt;classPathEntry location=&quot;$&#123;db.driverLocation&#125;&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context id=&quot;default&quot; targetRuntime=&quot;MyBatis3&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- optional，旨在创建class时，对注释进行控制 --&gt;</span><br><span class="line">        &lt;commentGenerator&gt;</span><br><span class="line">            &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">        &lt;/commentGenerator&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--jdbc的数据库连接 --&gt;</span><br><span class="line">        &lt;jdbcConnection</span><br><span class="line">                driverClass=&quot;$&#123;db.driverClassName&#125;&quot;</span><br><span class="line">                connectionURL=&quot;$&#123;db.url&#125;&quot;</span><br><span class="line">                userId=&quot;$&#123;db.username&#125;&quot;</span><br><span class="line">                password=&quot;$&#123;db.password&#125;&quot;&gt;</span><br><span class="line">        &lt;/jdbcConnection&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制 --&gt;</span><br><span class="line">        &lt;javaTypeResolver&gt;</span><br><span class="line">            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">        &lt;/javaTypeResolver&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类</span><br><span class="line">            targetPackage     指定生成的model生成所在的包名</span><br><span class="line">            targetProject     指定在该项目下所在的路径</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;!--&lt;javaModelGenerator targetPackage=&quot;com.mmall.pojo&quot; targetProject=&quot;.\src\main\java&quot;&gt;--&gt;</span><br><span class="line">        &lt;javaModelGenerator targetPackage=&quot;org.mmall.pojo&quot; targetProject=&quot;./src/main/java&quot;&gt;</span><br><span class="line">            &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">            &lt;!-- 是否对model添加 构造函数 --&gt;</span><br><span class="line">            &lt;property name=&quot;constructorBased&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt;</span><br><span class="line">            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">            &lt;!-- 建立的Model对象是否 不可改变  即生成的Model对象不会有 setter方法，只有构造方法 --&gt;</span><br><span class="line">            &lt;property name=&quot;immutable&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">        &lt;/javaModelGenerator&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --&gt;</span><br><span class="line">        &lt;!--&lt;sqlMapGenerator targetPackage=&quot;mappers&quot; targetProject=&quot;.\src\main\resources&quot;&gt;--&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage=&quot;mappers&quot; targetProject=&quot;./src/main/resources&quot;&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">        &lt;/sqlMapGenerator&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码</span><br><span class="line">                type=&quot;ANNOTATEDMAPPER&quot;,生成Java Model 和基于注解的Mapper对象</span><br><span class="line">                type=&quot;MIXEDMAPPER&quot;,生成基于注解的Java Model 和相应的Mapper对象</span><br><span class="line">                type=&quot;XMLMAPPER&quot;,生成SQLMap XML文件和独立的Mapper接口</span><br><span class="line">        --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- targetPackage：mapper接口dao生成的位置 --&gt;</span><br><span class="line">        &lt;!--&lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.mmall.dao&quot; targetProject=&quot;.\src\main\java&quot;&gt;--&gt;</span><br><span class="line">        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;org.mmall.dao&quot; targetProject=&quot;./src/main/java&quot;&gt;</span><br><span class="line">            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span><br><span class="line">            &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">        &lt;/javaClientGenerator&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;table tableName=&quot;mmall_shipping&quot; domainObjectName=&quot;Shipping&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;/table&gt;</span><br><span class="line">        &lt;table tableName=&quot;mmall_cart&quot; domainObjectName=&quot;Cart&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;/table&gt;</span><br><span class="line">        &lt;table tableName=&quot;mmall_cart_item&quot; domainObjectName=&quot;CartItem&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;/table&gt;</span><br><span class="line">        &lt;table tableName=&quot;mmall_category&quot; domainObjectName=&quot;Category&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;/table&gt;</span><br><span class="line">        &lt;table tableName=&quot;mmall_order&quot; domainObjectName=&quot;Order&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;/table&gt;</span><br><span class="line">        &lt;table tableName=&quot;mmall_order_item&quot; domainObjectName=&quot;OrderItem&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;/table&gt;</span><br><span class="line">        &lt;table tableName=&quot;mmall_pay_info&quot; domainObjectName=&quot;PayInfo&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;/table&gt;</span><br><span class="line">        &lt;table tableName=&quot;mmall_product&quot; domainObjectName=&quot;Product&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;</span><br><span class="line">            &lt;columnOverride column=&quot;detail&quot; jdbcType=&quot;VARCHAR&quot; /&gt;</span><br><span class="line">            &lt;columnOverride column=&quot;sub_images&quot; jdbcType=&quot;VARCHAR&quot; /&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">        &lt;table tableName=&quot;mmall_user&quot; domainObjectName=&quot;User&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;/table&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;!-- geelynote mybatis插件的搭建 --&gt;</span><br><span class="line">    &lt;/context&gt;</span><br><span class="line">&lt;/generatorConfiguration&gt;</span><br></pre></td></tr></table></figure><p><code>datasource.properties</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.driverLocation =  E:\\jre\\mysql-connector-java-5.1.6.jar</span><br><span class="line">db.driverClassName = com.mysql.jdbc.Driver</span><br><span class="line">db.url = jdbc:mysql://127.0.0.1:3306/mmall?characterEncoding=utf-8</span><br><span class="line">db.username = root</span><br><span class="line">db.password = root</span><br></pre></td></tr></table></figure><h4 id="4-运行"><a href="#4-运行" class="headerlink" title="4.运行"></a>4.运行</h4><ul><li>方式一：</li></ul><p><img src="/assets/img/2.png" alt=""></p><ul><li><p>方式二：</p><ul><li>在Intellij IDEA添加一个“Run运行”，这个少用 略</li></ul></li></ul><h2 id="Mybatis-Plus"><a href="#Mybatis-Plus" class="headerlink" title="Mybatis Plus"></a>Mybatis Plus</h2><blockquote><p>Mybatis Plus（简称MP）是一个 Mybatis 的增强工具，在 Mybatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p></blockquote><blockquote><p><a href="http://mp.baomidou.com/#/" target="_blank" rel="noopener">Mybatis Plus中文文档</a></p></blockquote><h4 id="1-功能"><a href="#1-功能" class="headerlink" title="1.功能"></a>1.功能</h4><ul><li>提供Mapper接口与配置文件中对应SQL的导航</li><li>编辑XML文件时自动补全</li><li>根据Mapper接口, 使用快捷键生成xml文件及SQL标签</li><li>ResultMap中的property支持自动补全，支持级联(属性A.属性B.属性C)</li><li>快捷键生成@Param注解</li><li>XML中编辑SQL时, 括号自动补全</li><li>XML中编辑SQL时, 支持参数自动补全(基于@Param注解识别参数)</li><li>自动检查Mapper XML文件中ID冲突</li><li>自动检查Mapper XML文件中错误的属性值</li><li>支持Find Usage</li><li>支持重构从命名</li><li>支持别名</li><li>自动生成ResultMap属性</li><li>快捷键: Option + Enter(Mac) | Alt + Enter(Windows)</li></ul><h4 id="2-安装与破解"><a href="#2-安装与破解" class="headerlink" title="2.安装与破解"></a>2.安装与破解</h4><ul><li>这是一个IDE插件，目前是收费的，这里我用的是Intellij IDEA的</li></ul><p><img src="/assets/img/3.png" alt=""></p><p>需要破解</p><h2 id="MyBatis-PageHelper"><a href="#MyBatis-PageHelper" class="headerlink" title="MyBatis-PageHelper"></a>MyBatis-PageHelper</h2><blockquote><p>这个一个通用的分页插件,使用时 Mybatis 最低版本不能低于3.3<br>原理：通过aop再截获我们执行sql的时候把相关的数据再执行一次</p></blockquote><p><a href="https://github.com/pagehelper/Mybatis-PageHelper" target="_blank" rel="noopener">GitHub地址</a></p><h4 id="1-在pom文件中添加依赖"><a href="#1-在pom文件中添加依赖" class="headerlink" title="1.在pom文件中添加依赖"></a>1.在pom文件中添加依赖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- mybatis pager --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.miemiedev&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-paginator&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.9.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="2-在spring配置文件内添加配置"><a href="#2-在spring配置文件内添加配置" class="headerlink" title="2.在spring配置文件内添加配置"></a>2.在spring配置文件内添加配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:mappers/*Mapper.xml&quot;&gt;&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 分页插件 --&gt;</span><br><span class="line">    &lt;property name=&quot;plugins&quot;&gt;</span><br><span class="line">        &lt;array&gt;</span><br><span class="line">            &lt;bean class=&quot;com.github.pagehelper.PageHelper&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;properties&quot;&gt;</span><br><span class="line">                    &lt;value&gt;</span><br><span class="line">                        &lt;!-- 数据库方言 --&gt;</span><br><span class="line">                        dialect=mysql</span><br><span class="line">                    &lt;/value&gt;</span><br><span class="line">                &lt;/property&gt;</span><br><span class="line">            &lt;/bean&gt;</span><br><span class="line">        &lt;/array&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><blockquote><p>本文引用自：<a href="https://www.godql.com/blog/2017/06/03/Intellij_IDEA_Integration_MyBatis/" target="_blank" rel="noopener">https://www.godql.com/blog/2017/06/03/Intellij_IDEA_Integration_MyBatis/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      Intellij IDEA 2017集成MyBatis三剑客（MyBatis-Generate、Mybatis Plus、MyBatis-PageHelper）
    
    </summary>
    
      <category term="mybatis系列" scheme="http://xym-loveit.github.io/categories/mybatis%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="MyBatis-Generate" scheme="http://xym-loveit.github.io/tags/MyBatis-Generate/"/>
    
      <category term="Mybatis Plus" scheme="http://xym-loveit.github.io/tags/Mybatis-Plus/"/>
    
      <category term="MyBatis-PageHelper" scheme="http://xym-loveit.github.io/tags/MyBatis-PageHelper/"/>
    
  </entry>
  
  <entry>
    <title>我珍藏的神兵利器</title>
    <link href="http://xym-loveit.github.io/2018/05/14/%E6%88%91%E7%8F%8D%E8%97%8F%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8/"/>
    <id>http://xym-loveit.github.io/2018/05/14/我珍藏的神兵利器/</id>
    <published>2018-05-14T03:26:28.000Z</published>
    <updated>2018-05-14T04:35:08.868Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>工欲善其事必先利其器。<br>我一直都在不断挑选和优化自己的兵器，以追求着最高效率。<br>此篇分享下我的私家珍藏的各种神兵利器。如果有朋友能推荐更好的，那就不枉此篇。<br>分为Windows软件和开发工具两类。</p></blockquote><h2 id="windows软件"><a href="#windows软件" class="headerlink" title="windows软件"></a>windows软件</h2><h3 id="快速启动：WOX"><a href="#快速启动：WOX" class="headerlink" title="快速启动：WOX"></a>快速启动：WOX</h3><p>快速启动应用+文件搜索+各种实用插件（计算器、翻译、网页快速访问等）。我的最爱，没有它我几乎半残。<br>一开始从用<code>altrun</code> 然后试过<code>Listary</code> ，发现WOX 后，最为顺手，效率提升100%。</p><h3 id="搜索工具：everything"><a href="#搜索工具：everything" class="headerlink" title="搜索工具：everything"></a>搜索工具：everything</h3><p>秒找电脑里的各种文件。与<code>WOX</code>完美集成。</p><h3 id="下载：IDM"><a href="#下载：IDM" class="headerlink" title="下载：IDM"></a>下载：IDM</h3><p>多线程下载HTTP类文件下载利器，杠杠的。Chrome 内的下载都托管给了IDM，可下载百度云离线文件，突破下载速度限制。<br>做不到的BT下载，使用迅雷下载或者<code>Aria2</code>来配合处理即可。</p><h3 id="截图：snipaste"><a href="#截图：snipaste" class="headerlink" title="截图：snipaste"></a>截图：snipaste</h3><p>开源、免费的国产截图神器。给我最大的感受是截图更方便，且比QQ截图工具清晰很多。</p><h3 id="预览工具：QuickLook"><a href="#预览工具：QuickLook" class="headerlink" title="预览工具：QuickLook"></a>预览工具：QuickLook</h3><p>按下空格即可快速预览文件，微软商店内的免费应用。<br>之前用的<code>seer</code>，发现<code>QuickLook</code>后，果断抛弃。</p><h3 id="剪切板工具：Ditto"><a href="#剪切板工具：Ditto" class="headerlink" title="剪切板工具：Ditto"></a>剪切板工具：Ditto</h3><p>再也不用担心刚才复制的内容找不到了。</p><h3 id="结构化笔记：workflowy"><a href="#结构化笔记：workflowy" class="headerlink" title="结构化笔记：workflowy"></a>结构化笔记：workflowy</h3><p><code>Make lists,not war.</code>我常用于记录工作中的各种待办事项。</p><p><img src="http://op7wplti1.bkt.clouddn.com/20180501224450.png" alt="workflowy"></p><h3 id="Markdown写作工具：Typora"><a href="#Markdown写作工具：Typora" class="headerlink" title="Markdown写作工具：Typora"></a>Markdown写作工具：Typora</h3><p>最好用的Markdown写作工具，所见即所得。</p><h3 id="贴图工具：PicGo"><a href="#贴图工具：PicGo" class="headerlink" title="贴图工具：PicGo"></a>贴图工具：PicGo</h3><p>支持多种图床，功能强大。</p><p><img src="http://op7wplti1.bkt.clouddn.com/20180501225020.png" alt="PicGo"></p><h3 id="看图工具：2345看图王"><a href="#看图工具：2345看图王" class="headerlink" title="看图工具：2345看图王"></a>看图工具：2345看图王</h3><p>虽然名字土鳖，国产软件，一贯的有流氓行为。但是看图是真好用，我能忍.</p><h3 id="压缩软件：BandZIP"><a href="#压缩软件：BandZIP" class="headerlink" title="压缩软件：BandZIP"></a>压缩软件：BandZIP</h3><h3 id="播放器：Splash"><a href="#播放器：Splash" class="headerlink" title="播放器：Splash"></a>播放器：Splash</h3><h3 id="录屏工具：LICEcap"><a href="#录屏工具：LICEcap" class="headerlink" title="录屏工具：LICEcap"></a>录屏工具：LICEcap</h3><p>比GifCam更好用。</p><h3 id="Chrome插件"><a href="#Chrome插件" class="headerlink" title="Chrome插件"></a>Chrome插件</h3><ul><li>1、Surfingkeys</li></ul><p>在Chrome上，可以摆脱掉烦人的鼠标了。Vimium 升级版，我的最爱。</p><ul><li>2、Tampermonkey</li></ul><p>一千个司机眼中有一千个油猴。<br>强大的脚本让你可以做很多很爽的事情。比如开车、百度网盘破解直接下载、VIP视频在线解析破解去广告等。</p><ul><li>3、沙拉查词-网页划词翻译</li></ul><p>全能网页划词翻译，开放源码、功能丰富、超多词典、清爽快速、支持个性化设置</p><p>详细信息删除。</p><p>找了很久才找到的划词翻译软件，而且双击Ctrl还可以弹出查询翻译页面。用起来很爽。</p><ul><li>4、掘金<br>新标签页托管给掘金，快速获得专业内容。掘金已成为一种习惯。</li></ul><p><img src="http://op7wplti1.bkt.clouddn.com/20180501221014.png" alt="掘金"></p><ul><li>5、Imagus<br>鼠标悬浮停留在图片上，自动弹出放大图片，不用再在新链接中打开看大图了。</li></ul><p>*6、oneTab<br>标签页打开太多的时候，占用内存而且怕关掉后回头找不到？oneTab完美解决这个问题。<br>主要是用来缩减窗口，保存浏览记录。<br>为了省内存？Chrome越来越吃内存？加内存条才是根本的解决办法。</p><ul><li><p>7、AutoPagerize<br>专门需要Google、百度，点击下一页很烦。AutoPagerize让我不再需要点下一页。</p></li><li><p>8、谷歌访问助手<br>如果你只要访问个谷歌或者上谷歌商店的话，不需要突破围墙的话，装这个插件可以满足基本使用了。免费而且速度还行。<br>在我的酸酸乳被严打封锁期间，我是靠着这个插件熬下来的，且行且珍惜。良民万岁。</p></li><li><p>9、Proxy SwitchyOmega<br>HTTP、SOCKS5代理插件，轻松快捷地管理和切换多个代理设置。用过段时间，挺好用的。</p></li><li><p>10、LastPass<br>省掉很多记密码的烦恼。</p></li><li><p>11、Insight.io for Github<br>IDE like code intelligence and code search for GitHub by Insight.io.<br>Github内看代码更方便，带高亮、跳转。</p></li><li><p>12、GitZip for github<br>It can make the sub-directories and files of github repository as zip and download it.<br>不想Clone整个项目，只想下载单个文件或者单个文件夹时，用这个。</p></li><li><p>13、Clear Cache<br>一键清除缓存，可以少点很多步。</p></li><li><p>14、User-Agent Switcher for Chrome<br>Chrome可以转换为别的浏览器进行访问，如IE、Safari、360甚至iOS、 Android等移动浏览器，方便用户进行测试。</p></li></ul><p><img src="http://op7wplti1.bkt.clouddn.com/20180501223907.png" alt="User-Agent Switcher for Chrome"></p><ul><li><p>15、Adblock Plus<br>网页去广告，不用uBlock Origin 的原因是它太强力，有时候把我博客的评论部分都杀掉了。</p></li><li><p>16、微博图床<br>一键将页面中的图片上传到微博，微博是个好图床。我一般用微博图床来拿HTTPS图片。</p></li><li><p>17、扩展管理器（Extension Manager）<br>一键管理所有扩展，快速开启/禁用、批量闪电管理，智能排序，右键卸载、锁定、选项配置，角标提醒，大小布局随心配。快捷、简单、安全。<br>当插件越来越多的时候，就需要个插件管理器了。这个管理器很方便，颜值不错。</p></li><li><p>18、IDM Integration Module<br>接管Chrome下载，使用IDM下载。一般在安装IDM的时候会自动安装Chrome的扩展。</p></li><li><p>19、惠惠购物助手<br>每逢剁手节的时候，都要打开这个看看历史价。</p></li><li><p>20、有道云网页剪报<br>一键保存网页内容，保存到有道云笔记里，我有时候将这个作为类似书签使用。</p></li></ul><h2 id="开发相关"><a href="#开发相关" class="headerlink" title="开发相关"></a>开发相关</h2><h3 id="IDE：IntelliJ-IDEA"><a href="#IDE：IntelliJ-IDEA" class="headerlink" title="IDE：IntelliJ IDEA"></a>IDE：IntelliJ IDEA</h3><p>用了有些年头了，高效、顺滑。也是因为从IDEA开始，让我意识到工具的重要性，在折腾工具的这条路上越走越远。</p><h3 id="IDEA插件私家珍藏"><a href="#IDEA插件私家珍藏" class="headerlink" title="IDEA插件私家珍藏"></a>IDEA插件私家珍藏</h3><ul><li><p>1、JRebel for IntelliJ<br>热部署插件，Java WEB 开发必备，节省生命。</p></li><li><p>2、Custom Postfix Templates<br>我的最爱。可以自定义Postfix模板，千言万语，不如一图。</p></li></ul><p><img src="http://op7wplti1.bkt.clouddn.com/201805012320_804.gif" alt="Custom Postfix Templates"></p><ul><li><p>3、Lombok Plugin<br>使用注解自动生成代码，码奴解放者。</p></li><li><p>4、RestfulToolkit<br>Java WEB开发必备，再也不用全局搜索RequestMapping了。</p></li></ul><p><img src="http://op7wplti1.bkt.clouddn.com/201805062124_169.gif" alt="RestfulToolkit1"></p><p><img src="http://op7wplti1.bkt.clouddn.com/201805062306_300.png" alt="RestfulToolkit2"></p><ul><li>5、Translation<br>翻译插件，很好用。</li></ul><p><img src="http://op7wplti1.bkt.clouddn.com/201805062310_661.png" alt="Translation"></p><ul><li>6、Grep Console<br>高亮log不同级别日志，看日志的时候一目了然。</li></ul><p><img src="http://op7wplti1.bkt.clouddn.com/201805062137_973.png" alt="Grep Console"></p><ul><li>7、GenerateSerialVersionUID<br><code>alt + Insert</code> 生成serialVersionUID</li></ul><p><img src="http://op7wplti1.bkt.clouddn.com/201805062139_237.gif" alt="GenerateSerialVersionUID"></p><ul><li><p>8、Git Flow Integration<br>Git Flow插件，与IDEA集成。</p></li><li><p>9、GsonFormat<br>JSON报文 –&gt; Java POJO 快速转换。</p></li></ul><p><img src="http://op7wplti1.bkt.clouddn.com/screenshot_15729.png" alt="GsonFormat"></p><ul><li><p>10、Material Theme UI<br>UI主题，有三款配色，看个人喜好。</p></li><li><p>11、String Manipulation<br>字符串格式风格快捷转换：大小写、驼峰、连接串等。</p></li><li><p>12、Alibaba Java Coding Guidelines<br>阿里巴巴Java开发规约扫描插件。</p></li><li><p>13、FindBugs<br>找到代码中潜在的问题。</p></li><li><p>14、Rainbow Brackets<br>彩虹括号。自动给代码块内花括号和括号加色，让视野更加注意在代码上。</p></li></ul><p><img src="http://op7wplti1.bkt.clouddn.com/201805062209_38.png" alt="Rainbow Brackets"></p><ul><li>15、Maven Helper<br>Maven插件，安装后可查看依赖以及冲突，一目了然。</li></ul><h3 id="文本编辑器：Sublime"><a href="#文本编辑器：Sublime" class="headerlink" title="文本编辑器：Sublime"></a>文本编辑器：Sublime</h3><p>对比Atom，Sublime主要是打开速度更快，感觉更清爽。</p><h3 id="数据库客户端：DataGrip"><a href="#数据库客户端：DataGrip" class="headerlink" title="数据库客户端：DataGrip"></a>数据库客户端：DataGrip</h3><p>一个客户端全搞定主流数据库。不用再装Navicat、plsql了。<br>ps:DataGrip其实只是IDEA里一个集成功能，被单独抽离出来成了一个独立产品。</p><h3 id="SSH客户端：MobaXterm"><a href="#SSH客户端：MobaXterm" class="headerlink" title="SSH客户端：MobaXterm"></a>SSH客户端：MobaXterm</h3><p>集成SSH、SFTP、FTP等，一个全搞定。还可分屏等功能，好用。</p><p><img src="http://op7wplti1.bkt.clouddn.com/201805062245_647.png" alt="MobaXterm"></p><h3 id="终端工具：Cmder"><a href="#终端工具：Cmder" class="headerlink" title="终端工具：Cmder"></a>终端工具：Cmder</h3><p>丢弃掉Windows自带cmd窗口吧。</p><p><img src="http://op7wplti1.bkt.clouddn.com/201805062247_127.png" alt="Cmder"></p><h3 id="API工具：Postman"><a href="#API工具：Postman" class="headerlink" title="API工具：Postman"></a>API工具：Postman</h3><p>强大的API调试、Http请求的工具 。可自动同步个人请求记录。</p><h3 id="API管理平台"><a href="#API管理平台" class="headerlink" title="API管理平台"></a>API管理平台</h3><ul><li>Hitchhiker</li><li>eoLinker</li><li>apidocjs</li></ul><blockquote><p>本文引用自：<a href="https://www.liutf.com/posts/3720794851.html" target="_blank" rel="noopener">https://www.liutf.com/posts/3720794851.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      常用工具整理，方便使用
    
    </summary>
    
      <category term="常用工具" scheme="http://xym-loveit.github.io/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="常用工具整理" scheme="http://xym-loveit.github.io/tags/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础-docker compose网络</title>
    <link href="http://xym-loveit.github.io/2018/04/26/Docker%E5%9F%BA%E7%A1%80-docker-compose%E7%BD%91%E7%BB%9C/"/>
    <id>http://xym-loveit.github.io/2018/04/26/Docker基础-docker-compose网络/</id>
    <published>2018-04-26T08:46:31.000Z</published>
    <updated>2018-04-26T16:37:46.772Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注意： 本文涉及的compose只适用于compose文件格式为version 2的版本，v1(旧的)不支持网络功能</p></blockquote><p>默认<code>compose</code>会为你的app配置一个单独的网络。服务中的每个容器加入到这个默认的网络且在这个网络的容器都能互相通信，它们也能通过与容器名称相同的主机名发现对方。</p><blockquote><p>注意： app的网络基于”项目名称”设置网络名称，这个项目名称基于项目所处的目录名。可以使用–project-name选项或COMPOSE_PROJECT_NAME环境变量来覆盖。</p></blockquote><p>例如，假设app在一个名为<code>myapp</code>的目录，<code>docker-compose.yml</code>内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8000:8000&quot;</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure><p>当执行<code>docker-compose up</code>时，网络部分设置如下： 1.创建了称之为myapp_default的网络 2.使用web的配置创建容器，然后这个容器加入到myapp_default网络 3.使用db的配置创建容器，这个容器加入到myapp_default网络</p><p>每个容器现在能直接查找主机名web或db来得到容器的IP地址。例如，web应用程序的代码可以连接URL postgres://db:5432并开始使用postgres数据库。 由于web明确的映射了一个端口，外部网络也就能通过在docker主机的网络接口的8000端口连接容器。</p><h2 id="容器更新"><a href="#容器更新" class="headerlink" title="容器更新"></a>容器更新</h2><p>如果更改了服务的配置并执行<code>docker-compose up</code>来更新它，将删除旧的容器并且新的容器会加入到相同的网络，分配到了不同的IP地址，不过主机名不变。运行中的容器应该能够查找主机名并连接到新的地址，不过旧的地址将失效。</p><p>如果任何一个容器与旧容器有连接，它们会被关闭掉。容器有责任检测这种情况然后重新查找旧容器的主机来重新连接。</p><h2 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h2><p>links可以为一个容器定义一个额外的别名。即使服务没有启动，它们也能进行通信。默认任何服务都可以通过该服务的名称访问其他的服务。例如：在web容器中可以通过db和database访问db容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    links:</span><br><span class="line">      - &quot;db:database&quot;</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure><h2 id="多主机网络"><a href="#多主机网络" class="headerlink" title="多主机网络"></a>多主机网络</h2><p>当在swarm集群中部署compose app的时候，你可以使用内置的overlaydriver来启用容器之间的多主机通信，这不会更改你的compose文件和app code。</p><p>请参阅Getting started with multi-host networking<a href="https://docs.docker.com/network/overlay-standalone.swarm/" target="_blank" rel="noopener">Getting started with multi-host networking</a>来了解怎么配置swarm集群。swarm默认是使用overlay网络驱动，当然你也可以自己自定义。详情在下一段</p><h2 id="指定自定义网络"><a href="#指定自定义网络" class="headerlink" title="指定自定义网络"></a>指定自定义网络</h2><p>除了使用默认的app网络之外，还可以使用最顶层的<code>networks</code>关键字来指定自定义的网络。这让你可以创建更复杂的网络并制定自定义网络驱动及其选项。也可以使用它将服务连接到不是有compose管理的外部网络。</p><p>每个服务都能指定由networks关键字配置的网络，可以配置service级别和top级的网络。</p><p>下面的示例compose文件定义了两个自定义网络。proxy服务与db服务隔离，因为它们没有指定相同的网络。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  proxy:</span><br><span class="line">    build: ./proxy</span><br><span class="line">    networks:</span><br><span class="line">      - front</span><br><span class="line">  app:</span><br><span class="line">    build: ./app</span><br><span class="line">    networks:</span><br><span class="line">      - front</span><br><span class="line">      - back</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line">    networks:</span><br><span class="line">      - back</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  front:</span><br><span class="line">    # Use a custom driver</span><br><span class="line">    driver: custom-driver-1</span><br><span class="line">  back:</span><br><span class="line">    # Use a custom driver which takes special options</span><br><span class="line">    driver: custom-driver-2</span><br><span class="line">    driver_opts:</span><br><span class="line">      foo: &quot;1&quot;</span><br><span class="line">      bar: &quot;2&quot;</span><br></pre></td></tr></table></figure><h2 id="配置默认网络"><a href="#配置默认网络" class="headerlink" title="配置默认网络"></a>配置默认网络</h2><p>除了指定你自己的网络之外，还可以通过在名为default的网络下定义一个条目来更改应用范围内的默认网络设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8000:8000&quot;</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    # Use a custom driver</span><br><span class="line">    driver: custom-driver-1</span><br></pre></td></tr></table></figure></p><h2 id="使用预先存在的网络"><a href="#使用预先存在的网络" class="headerlink" title="使用预先存在的网络"></a>使用预先存在的网络</h2><p>如果你希望你的容器加入一个预先存在的网络，使用external选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    external:</span><br><span class="line">      name: my-pre-existing-network</span><br></pre></td></tr></table></figure><p>compose检测到有external选项后，不会创建名为[PROJECTNAME]_default的网络，而是会查找一个名为my-pre-existing-network的网络，并将应用程序连接到它。</p>]]></content>
    
    <summary type="html">
    
      docker compose网络配置。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="compose网络" scheme="http://xym-loveit.github.io/tags/compose%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础-docker 容器日志命名</title>
    <link href="http://xym-loveit.github.io/2018/04/26/Docker%E5%9F%BA%E7%A1%80-docker-%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97%E5%91%BD%E5%90%8D/"/>
    <id>http://xym-loveit.github.io/2018/04/26/Docker基础-docker-容器日志命名/</id>
    <published>2018-04-26T08:22:19.000Z</published>
    <updated>2018-04-26T08:37:34.165Z</updated>
    
    <content type="html"><![CDATA[<p>tag 选项指定你该为容器的日志如何命名。默认是容器ID的前12个字符。要覆盖默认值，可指定一个tag选项:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --log-driver=fluentd --log-opt fluentd-address=myhost.local:24224 --log-opt tag=&quot;mailer&quot;</span><br></pre></td></tr></table></figure></p><p>docker支持一些特殊的标记模板，你可以在指定的时候使用</p><table><thead><tr><th>标记</th><th>描述</th></tr></thead><tbody><tr><td>{ { .ID } }</td><td>容器ID的前12个字符</td></tr><tr><td>{ { .FullID } }</td><td>容器的全部ID</td></tr><tr><td>{ { .Name } }</td><td>容器名</td></tr><tr><td>{ { .ImageID } }</td><td>Image ID 前12个字符</td></tr><tr><td>{ { .ImageFullID } }</td><td>全部的Image ID</td></tr><tr><td>{ { .ImageName } }</td><td>Image 名</td></tr><tr><td>{ { .DaemonName } }</td><td>docker 进程的名称</td></tr></tbody></table><p>例如：指定一个 <code>--log-opt tag=&quot;{ { .ImageName } }/{ { .Name } }/{ { .ID } }&quot;</code>,让其输出到syslog，那么最终他输出的内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aug  7 18:33:19 HOSTNAME docker/hello-world/foobar/5790672ab6a0[9103]: Hello from Docker</span><br></pre></td></tr></table></figure></p><p>在启动时，系统会在<code>tag</code>中设置<code>container_name</code> 字段和<code>{ { .name } }</code>字段，如果你使用<code>docker rename</code>重命名容器，新名称不会反映在日志消息中，这些消息会继续使用原来的容器名。</p><p>更高级的用法，可以去参考<a href="https://golang.org/pkg/text/template/" target="_blank" rel="noopener">go templates</a>和<a href="https://github.com/moby/moby/tree/master/daemon/logger" target="_blank" rel="noopener">container’s logging context</a></p><p>下面是一个syslog的例子，如果我们使用下面的内容,就会得到如下的日志内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm \</span><br><span class="line">    --log-driver syslog \</span><br><span class="line">    --log-opt tag=&quot;&#123; &#123;  (.ExtraAttributes nil).SOME_ENV_VAR  &#125; &#125;&quot; \</span><br><span class="line">    --log-opt env=SOME_ENV_VAR \</span><br><span class="line">    -e SOME_ENV_VAR=logtester.1234 \</span><br><span class="line">    flyinprogrammer/logtester</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Apr  1 15:22:17 ip-10-27-39-73 docker/logtester.1234[45499]: + exec app</span><br><span class="line">Apr  1 15:22:17 ip-10-27-39-73 docker/logtester.1234[45499]: 2016-04-01 15:22:17.075416751 +0000 UTC stderr msg: 1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Docker容器日志命名配置。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="docker容器日志" scheme="http://xym-loveit.github.io/tags/docker%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础-docker limit资源限制</title>
    <link href="http://xym-loveit.github.io/2018/04/26/Docker%E5%9F%BA%E7%A1%80-docker-limit%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6/"/>
    <id>http://xym-loveit.github.io/2018/04/26/Docker基础-docker-limit资源限制/</id>
    <published>2018-04-26T07:57:00.000Z</published>
    <updated>2018-04-26T08:21:00.975Z</updated>
    
    <content type="html"><![CDATA[<p>默认情况下，容器没有资源约束，可以使用与主机的内核调度程序允许的的资源一样多的资源。docker提供了在运行<code>docker run</code>指定选项来控制容器内存，cpu或IO的方法。这部分提供了有关何时应该设置这类限制以及设置这些限制可能有什么影响的详细信息。</p><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>Docker 可以强制执行硬内存限制，其允许容器使用不超过用户或系统给定的内存大小，或者软限制，允许容器在满足条件的情况下使用所需内存，例如,当内核检测到主机上的内存不足或有争抢。下面的选项单独使用或集中使用会有不同的效果。 这些选项中大部分都是采用正整数，后面跟一个后缀b,k,m,g，表示字节，千字节，兆字节，千兆字节。</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>-m or –memory=</td><td>容器可以使用的最大内存大小，如果你设置了这个选项，那么内存最小也要4m</td></tr><tr><td>–memory-swarp*</td><td>容器可以交换到硬盘的内存大小，可参考<a href="https://docs.docker.com/config/containers/resource_constraints/" target="_blank" rel="noopener">–memory-swap details</a></td></tr><tr><td>–memory-swappiness</td><td>默认情况下，主机内核可以交换容器使用的匿名页面的百分比，可以在0-100之间设置<code>--memory-swappiness</code>的百分比，可参考<a href="https://docs.docker.com/config/containers/resource_constraints/#--memory-swappiness-details" target="_blank" rel="noopener">–memory-swappiness details</a></td></tr><tr><td>–memory-reservation</td><td>允许你指定一个小于–memory的软限制，当docker在主机上检测到争用或低内存时激活该限制。如果使用–memory-reservation，则必须将其设置为低于–memory，以使其优先。因为它是一个软限制，不保证容器不会超过限制。</td></tr><tr><td>–kernel-memory</td><td>容器可以使用的最大内核内存，最小值是4m。因为内核内存无法交换出来，一个缺少内核内存的容器可能会阻塞主机资源，这会对主机和其他容器产生副作用</td></tr><tr><td>–oom-kill-disable</td><td>默认情况下，如果发生内存不足(OOM)错误，内核会杀死容器中的进程。我们可以使用–oom-kill-disable选项来改变设置，如果你设置了-m/–memory选项，那么容器会一直耗尽到-m限制的内存大小。而如果你没有设定-m，主机会尽可能的耗尽内存，内核可能需要杀死主机系统的进程以释放内存。</td></tr></tbody></table><h3 id="–memory-swap-details"><a href="#–memory-swap-details" class="headerlink" title="–memory-swap details"></a>–memory-swap details</h3><ul><li>如果没有设置–memory-swap，而设置了–memory，容器能够使用–memory值的两倍的swap。例如：–memory=300m,–memory-swap没有设置，那么容器能够使用300m内存和600m swap。</li><li>如果–memory和–memory-swap都设置了，–memory-swap表示能够使用内存和swap的总数，–memory控制非swap的内存大小。例如：–memory=300m,–memory-swap=1g，那么容器能够使用300m内存和700m的swap。</li><li>如果设置为-1(默认)，表示容器可以无限使用swap</li></ul><h3 id="–memory-swappiness-details"><a href="#–memory-swappiness-details" class="headerlink" title="–memory-swappiness details"></a>–memory-swappiness details</h3><ul><li>如果值为0，关闭匿名页面交换</li><li>值100，将所有匿名页面设置为可交换</li><li>默认情况下，如果不设置<code>--memory-swappiness</code>，容器将继承主机计算机的值</li></ul><h3 id="–kernel-memory-details"><a href="#–kernel-memory-details" class="headerlink" title="–kernel-memory details"></a>–kernel-memory details</h3><p>内核内存限制以分配给容器的总内存来表示，有以下几种场景：</p><ul><li>没有限制–memory，没有限制–kernel-memory： 这是默认值</li><li>没有限制–memory，有限制–kernel-memory: 当所有的cgroups所需的内存量超过主机实际拥有的内存量时，适合设置为这样子。你可以设置内核内存不超过主机可用内存，容器需要更多内存只能等待了。</li><li>有限制–memory，没有限制–kernel-memory：总内存是限制的，不过内核内存无限制</li><li>有限制–memory，有限制–kernel-memory：用户和内核限制都限制时，对调试内存相关问题会有帮助。如果一个容器用完了这两种内存之中的一种，它不会影响到其他的容器和主机。如果内核内存限制比用户内存低，使用完内核内存后，会导致容器长生OOM错误，反之，则不会。</li></ul><h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>默认情况下，所有容器获得CPU周期的比例相同，你可以通过下面的选项来对容器的CPU使用进行调整。</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>–cpu-shares</td><td>设置权重，修改默认的1024增大或者减小。当其他容器有空闲CPU时，其他容器可使用空闲CPU时间</td></tr><tr><td>–cpu-period</td><td>容器的一个逻辑CPU的调度周期。默认值是100000（100ms），当然我们也可以自己设置CPU周期，限制容器CPU用量，通常和<code>--cpu-quota</code>参数使用</td></tr><tr><td>–cpu-quota</td><td>在由<code>--cpu-period</code>设置的时间段内，容器可以调度的最大CPU使用量，默认是0，以为着允许容器获得1个CPU的100%的资源量。设置50000限制CPU资源的50%</td></tr><tr><td>–cpuset-cpus</td><td>定容器允许运行的CPU号(在多核心系统中)</td></tr></tbody></table><h2 id="Block-IO"><a href="#Block-IO" class="headerlink" title="Block IO"></a>Block IO</h2><p>有两个选项可用于调整容器对直连块IO设备的访问。你还可以按照每秒字节数或每秒IO操作来指定带宽限制。</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>blkio-weight</td><td>默认情况下，每个容器可以使用相同比例的IO带宽。默认权重是500，要提高或者降低，可以设置–blkio-weight来设置介于10-1000之间的值，此设置会平等的影响到所有块IO设备</td></tr><tr><td>blkio-weight-device</td><td>与<code>--blkio-weight</code>相同，但你可以使用<code>--blkio-weight-device=DEVICE_NAME:WEGITH</code>为每个设备设置权重。</td></tr><tr><td>–device-read-bps和–device-write-bps</td><td>根据大小限制设备读取或写入的速率，使用kb，mb或gb后缀</td></tr><tr><td>–device-read-iops和–device-write-iops</td><td>通过IO操作/秒限制设备读取或写入的速率</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      Docker资源限制配置参数（MEMORY/IO/CPU）详解。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker资源限制" scheme="http://xym-loveit.github.io/tags/Docker%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6/"/>
    
      <category term="Docker limit" scheme="http://xym-loveit.github.io/tags/Docker-limit/"/>
    
      <category term="Memory limit" scheme="http://xym-loveit.github.io/tags/Memory-limit/"/>
    
      <category term="CPU limit" scheme="http://xym-loveit.github.io/tags/CPU-limit/"/>
    
      <category term="IO limit" scheme="http://xym-loveit.github.io/tags/IO-limit/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础-当docker daemon停止时依然保持容器运行</title>
    <link href="http://xym-loveit.github.io/2018/04/26/Docker%E5%9F%BA%E7%A1%80-%E5%BD%93docker-daemon%E5%81%9C%E6%AD%A2%E6%97%B6%E4%BE%9D%E7%84%B6%E4%BF%9D%E6%8C%81%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C/"/>
    <id>http://xym-loveit.github.io/2018/04/26/Docker基础-当docker-daemon停止时依然保持容器运行/</id>
    <published>2018-04-26T07:45:28.000Z</published>
    <updated>2018-04-26T07:53:11.270Z</updated>
    
    <content type="html"><![CDATA[<p>默认情况下，当docker daemon停止，它会关闭所有正在运行的容器。从docker1.12起，你可以配置当docker daemon不可用时依然保持容器继续运行。<code>live restore</code>选项有助于减少由于docker daemon崩溃，中断或升级而导致的容器停机时间。</p><blockquote><p>Note: live restore不支持windows容器，但是它支持运行在windows上的linux容器。</p></blockquote><h2 id="开启live-restore选项"><a href="#开启live-restore选项" class="headerlink" title="开启live restore选项"></a>开启live restore选项</h2><p>有两种方式开启<code>live restore</code>:</p><ul><li>如果<code>docker daemon</code>正在运行并且你不想停止它，你可以添加配置到<code>docker daemon</code>的配置文件。例如：在linux系统上默认的配置文件是<code>/etc/docker/daemon.json</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;live-restore&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>你必须传递一个<code>SIGHUP</code>信号给daemon进程来重载配置。更多有关使用config.json来配置docker daemon的信息，可以参考<a href="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file" target="_blank" rel="noopener">daemon configuration file</a></p><ul><li>在使用dockerd启动时指定<code>--live-restore</code>选项<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dockerd --live-restore</span><br></pre></td></tr></table></figure></li></ul><h2 id="升级docker-daemon-时的Live-restore"><a href="#升级docker-daemon-时的Live-restore" class="headerlink" title="升级docker daemon 时的Live restore"></a>升级docker daemon 时的Live restore</h2><p><code>live restore</code>支持当升级<code>docker daemon</code>后，还原容器到docker</p><h2 id="重启时的live-restore"><a href="#重启时的live-restore" class="headerlink" title="重启时的live restore"></a>重启时的live restore</h2><p>live restore只支持还原到和原docker daemon一样的docker daemon。比如：如果新的docker daemon使用不同的网桥IP重新启动，则live restore不起作用。</p><h2 id="live-restore-对正在运行的容器的影响"><a href="#live-restore-对正在运行的容器的影响" class="headerlink" title="live restore 对正在运行的容器的影响"></a>live restore 对正在运行的容器的影响</h2><p>长时间缺少docker daemon可能会影响正在运行的容器。容器写入FIFO日志在daemon消耗时。如果daemon不能用于输出，缓冲区将填满并阻止对日志的进一步写入，因为阻塞该进程直到有更多的可用空间，默认缓冲区大小通常为64K。 你必须重启docker来刷新buffers 你可以修改<code>/proc/sys/fs/pipe-max-size</code>来修改内核buffer 大小</p><h2 id="live-restore-和-swarm-模式"><a href="#live-restore-和-swarm-模式" class="headerlink" title="live restore 和 swarm 模式"></a>live restore 和 swarm 模式</h2><p>live restore 和docker swarm模式不兼容。当docker 运行在swarm模式下时，是由编排功能来管理任务并使容器根据服务规范运行的。</p>]]></content>
    
    <summary type="html">
    
      Docker daemon的 live restore选项配置。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="live restore配置" scheme="http://xym-loveit.github.io/tags/live-restore%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础-docker 环境变量在compose文件中的使用</title>
    <link href="http://xym-loveit.github.io/2018/04/26/Docker%E5%9F%BA%E7%A1%80-docker-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%9C%A8compose%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://xym-loveit.github.io/2018/04/26/Docker基础-docker-环境变量在compose文件中的使用/</id>
    <published>2018-04-26T07:30:25.000Z</published>
    <updated>2018-04-26T07:43:18.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在compose文件中引用环境变量"><a href="#在compose文件中引用环境变量" class="headerlink" title="在compose文件中引用环境变量"></a>在compose文件中引用环境变量</h2><p>可以在compose文件中引用运行<code>docker-compose</code>所在的shell中的环境变量，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">web:</span><br><span class="line">  image: &quot;webapp:$&#123;TAG&#125;&quot;</span><br></pre></td></tr></table></figure></p><h2 id="在容器中设置环境变量"><a href="#在容器中设置环境变量" class="headerlink" title="在容器中设置环境变量"></a>在容器中设置环境变量</h2><p>可以在compose文件中的<code>environment</code>关键字下设置容器的环境变量，就像使用<code>docker run -e VARIABLE=VALUE</code>一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">web:</span><br><span class="line">  environment:</span><br><span class="line">    - DEBUG=1</span><br></pre></td></tr></table></figure></p><h2 id="将环境变量传递到容器"><a href="#将环境变量传递到容器" class="headerlink" title="将环境变量传递到容器"></a>将环境变量传递到容器</h2><p>可以在compose文件中的<code>environment</code>关键字下定义一个环境变量而不是直接赋值，就像是<code>docker run -e VARIABLE</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">web:</span><br><span class="line">  environment:</span><br><span class="line">    - DEBUG</span><br></pre></td></tr></table></figure></p><h2 id="env-file配置选项"><a href="#env-file配置选项" class="headerlink" title="env_file配置选项"></a>env_file配置选项</h2><p>可以使用compose文件中的<code>env_file</code>选项从一个外部文件传递多个环境变量到容器中，就像<code>docker run --env-file=FILE</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">web:</span><br><span class="line">  env_file:</span><br><span class="line">    - web-variables.env</span><br></pre></td></tr></table></figure><p>使用<code>docker-compose run</code>设置环境变量<br>就像<code>docker run -e</code>,可以使用<code>docker-compose run -e</code>为一次性容器设置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose run -e DEBUG=1 web python console.py</span><br></pre></td></tr></table></figure><p>也可以不赋值，直接从shell变量中取值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose run -e DEBUG web python console.py</span><br></pre></td></tr></table></figure></p><p>DEBUG的值是从执行compose文件所在的shell的同一个环境变量取得。</p><h2 id="env文件"><a href="#env文件" class="headerlink" title=".env文件"></a>.env文件</h2><p>可以在环境文件<code>.env</code>设置默认的环境变量，这些环境变量可以在compose文件中调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ cat .env</span><br><span class="line">TAG=v1.5</span><br><span class="line"></span><br><span class="line">$ cat docker-compose.yml</span><br><span class="line">version: &apos;2.0&apos;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: &quot;webapp:$&#123;TAG&#125;&quot;</span><br></pre></td></tr></table></figure></p><p>当执行<code>docker-compose up</code>命令时，上面定义的web服务将使用<code>webapp:v1.5</code>镜像，可以使用config命令来打印出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose config</span><br><span class="line">version: &apos;2.0&apos;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: &apos;webapp:v1.5&apos;</span><br></pre></td></tr></table></figure><p>在shell中的环境变量将比定义在<code>.env</code>文件中的环境变量优先。如果在shell中设置一个不同的TAG，镜像将优先使用shell中的定义，而不是.evn文件中的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ export TAG=v2.0</span><br><span class="line">$ docker-compose config</span><br><span class="line">version: &apos;2.0&apos;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: &apos;webapp:v2.0&apos;</span><br></pre></td></tr></table></figure><h2 id="使用环境变量来配置compose"><a href="#使用环境变量来配置compose" class="headerlink" title="使用环境变量来配置compose"></a>使用环境变量来配置compose</h2><p>某些环境变量可用来配置以改变<code>docker compose</code>的命令行特性，以<code>COMPOSE_</code>或<code>DOCKER_</code>开头，详细信息参考<a href="https://docs.docker.com/compose/reference/envvars/" target="_blank" rel="noopener">CLI Environment Variables</a></p>]]></content>
    
    <summary type="html">
    
      compose的环境变量的配置和使用。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="compose的环境变量" scheme="http://xym-loveit.github.io/tags/compose%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础-docker在各个平台的基本配置</title>
    <link href="http://xym-loveit.github.io/2018/04/26/Docker%E5%9F%BA%E7%A1%80-docker%E5%9C%A8%E5%90%84%E4%B8%AA%E5%B9%B3%E5%8F%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
    <id>http://xym-loveit.github.io/2018/04/26/Docker基础-docker在各个平台的基本配置/</id>
    <published>2018-04-26T06:13:36.000Z</published>
    <updated>2018-04-26T07:07:15.457Z</updated>
    
    <content type="html"><![CDATA[<p>在安装完<code>docker</code>之后，<code>docker daemon</code>会用默认的配置来运行。</p><p>在生产环境中，系统管理员通常会根据需求来配置<code>docker</code>，在大多数例子中，系统管理员配置会配置进程管理器，如：<code>sysvinit</code>,<code>upstart</code>或<code>systemd</code>来管理<code>docker</code>的启动和停止。</p><h2 id="直接运行docker-daemon"><a href="#直接运行docker-daemon" class="headerlink" title="直接运行docker daemon"></a>直接运行docker daemon</h2><p>我们可以直接用<code>dockerd</code>命令来直接运行<code>docker daemon</code>.默认是监听在<code>unix socket unix:///var/run/docker.sock</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ dockerd</span><br><span class="line"></span><br><span class="line">INFO[0000] +job init_networkdriver()</span><br><span class="line">INFO[0000] +job serveapi(unix:///var/run/docker.sock)</span><br><span class="line">INFO[0000] Listening for HTTP on unix (/var/run/docker.sock)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="直接配置docker-daemon"><a href="#直接配置docker-daemon" class="headerlink" title="直接配置docker daemon"></a>直接配置docker daemon</h2><p>如果你是直接运行<code>dockerd</code>命令，而非使用进程管理器(<code>systemctl start docker</code>)，你可以直接将配置选项附加到<code>docker run</code>命令。其他配置选项可传递给<code>docker daemon</code>来配置 配置选项如下：</p><p><code>| Flag | Description | | :—- | :——— | | -D,–debug=false |</code> 开启或关闭debug模式，默认是关闭的 <code>| | -H,–host=[] | Daemon socket[s]</code>连接到哪 <code>| | –tls=false |</code>开启或关闭TLS，默认是关闭的 | 这里有一个使用配置选项运行<code>docker daemon</code>的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ dockerd -D \</span><br><span class="line">--tls=true \</span><br><span class="line">--tlscert=/var/docker/server.pem \</span><br><span class="line">--tlskey=/var/docker/serverkey.pem \</span><br><span class="line">-H tcp://192.168.59.3:2376</span><br></pre></td></tr></table></figure><p>这些选项是：</p><ul><li>开启<code>debug</code>模式 -D</li><li>开启<code>tls</code>并指定证书 <code>--tlscert</code>和<code>--tlskey</code></li><li>监听连接<code>tcp://192.168.59.3:2376</code></li></ul><p>命令行可参考<a href="https://docs.docker.com/engine/reference/commandline/dockerd/" target="_blank" rel="noopener">complete list of daemon flags</a></p><h2 id="Daemon-debugging"><a href="#Daemon-debugging" class="headerlink" title="Daemon debugging"></a>Daemon debugging</h2><p>如上所诉，开启debug模式来允许管理员或操作者来获取docker daemon运行时的信息。如果面对一个没有响应的daemon，管理员可以通过向Docker daemon发送<code>SIGUSR1</code>信号来强制所有线程的完整堆栈跟踪添加到daemon的日志中。在linux上通常使用kill命令。例：<code>kill -USR1 &lt;daemon-pid&gt;</code>发送<code>SIGUSR1</code>到daemon，这会导致堆栈被添加到daemon日志中。</p><blockquote><p>Note: 日志级别至少是info及以上，默认日志界别是info</p></blockquote><p>在处理<code>SIGUSR1</code>信号并将堆栈跟踪转存到日志后，daemon将继续运行，堆栈跟踪可用于确定daemon所有线程和goroutines的状态</p><h2 id="在centos上配置docker"><a href="#在centos上配置docker" class="headerlink" title="在centos上配置docker"></a>在centos上配置docker</h2><p>在CENTOS 6.X和RHEL 6.X中，我们在<code>/etc/sysconfig/docker</code>文件中配置docker daemon，我们可以通过指定<code>other_args</code>变量来实现。短时间内，在Centos7.x 和RHEL 7.x我们使用<code>OPTIONS</code>变量值，不再推荐直接使用systemd。</p><p>1.登录到你的系统，使用<code>root</code>账户，或者使用<code>sudo</code></p><p>2.创建<code>/etc/systemd/system/docker.service.d</code>目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir /etc/systemd/system/docker.service.d</span><br></pre></td></tr></table></figure><p>3.创建<code>/etc/systemd/system/docker.service.d/docker.conf</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mkdir /etc/systemd/system/docker.service.d/docker.conf</span><br></pre></td></tr></table></figure></p><p>4.打开这个docker.conf文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/systemd/system/docker.service.d/docker.conf</span><br></pre></td></tr></table></figure></p><p>5.覆盖从<code>docker.service</code>文件复制过来的<code>ExecStart</code>，用以自定义<code>docker daemon</code>。要修改<code>ExecStart</code>配置，必须先指定一个空配置，然后再定义一个新配置，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// -D --tls=true --tlscert=/var/docker/server.pem --tlskey=/var/docker/serverkey.pem -H tcp://192.168.59.3:2376</span><br></pre></td></tr></table></figure><p>6.保存关闭文件 </p><p>7.重新载入改变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure></p><p>8.重启docker daemon<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure></p><p>9.检查docker daemon是否运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux | grep docker | grep -v grep</span><br></pre></td></tr></table></figure></p><h2 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h2><p>docker 在centos7.x上是将日志保存在<code>/var/log/messages</code> 中的，我们也可以使用<code>journalctl -u docker</code>来查看docker的日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@xym ~]# journalctl -u docker</span><br><span class="line">-- Logs begin at Wed 2018-04-18 13:46:33 CST, end at Thu 2018-04-26 15:01:01 CST. --</span><br><span class="line">Apr 18 13:46:43 xym systemd[1]: Starting Docker Application Container Engine...</span><br><span class="line">Apr 18 13:46:44 xym dockerd[1279]: time=&quot;2018-04-18T13:46:44.353903498+08:00&quot; level=info msg=&quot;libcontainerd: started new docker-containerd process&quot; pid=1364</span><br><span class="line">Apr 18 13:46:44 xym dockerd[1279]: time=&quot;2018-04-18T13:46:44+08:00&quot; level=info msg=&quot;starting containerd&quot; module=containerd revision=89623f28b87a6004d4b785663257362d1658a729 version=v1.0.0</span><br><span class="line">Apr 18 13:46:44 xym dockerd[1279]: time=&quot;2018-04-18T13:46:44+08:00&quot; level=info msg=&quot;setting subreaper...&quot; module=containerd</span><br><span class="line">Apr 18 13:46:44 xym dockerd[1279]: time=&quot;2018-04-18T13:46:44+08:00&quot; level=info msg=&quot;changing OOM score to -500&quot; module=containerd</span><br><span class="line">Apr 18 13:46:44 xym dockerd[1279]: time=&quot;2018-04-18T13:46:44+08:00&quot; level=info msg=&quot;loading plugin &quot;io.containerd.content.v1.content&quot;...&quot; module=containerd type=io.containerd.content.v1</span><br><span class="line">Apr 18 13:46:44 xym dockerd[1279]: time=&quot;2018-04-18T13:46:44+08:00&quot; level=info msg=&quot;loading plugin &quot;io.containerd.snapshotter.v1.btrfs&quot;...&quot; module=containerd type=io.containerd.snapshotter.</span><br><span class="line">Apr 18 13:46:44 xym dockerd[1279]: time=&quot;2018-04-18T13:46:44+08:00&quot; level=warning msg=&quot;failed to load plugin io.containerd.snapshotter.v1.btrfs&quot; error=&quot;path /var/lib/docker/containerd/daemo</span><br><span class="line">Apr 18 1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      docker daemon的生产环境配置注意事项。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="docker daemon配置" scheme="http://xym-loveit.github.io/tags/docker-daemon%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>Docker基础-docker常用命令</title>
    <link href="http://xym-loveit.github.io/2018/04/26/Docker%E5%9F%BA%E7%A1%80-docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://xym-loveit.github.io/2018/04/26/Docker基础-docker常用命令/</id>
    <published>2018-04-26T03:20:12.000Z</published>
    <updated>2018-04-26T03:58:22.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker-Command"><a href="#Docker-Command" class="headerlink" title="Docker Command"></a>Docker Command</h2><p>介绍一些docker常用的命令</p><h3 id="Docker-container-management"><a href="#Docker-container-management" class="headerlink" title="Docker container management"></a>Docker container management</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#运行容器</span><br><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">  -t 分配一个terminal窗口</span><br><span class="line">  -i 允许和容器进行交互</span><br><span class="line">  -d 后台运行一个容器</span><br><span class="line">  -P 将容器内部的所有exposed的端口映射为宿主机上的随意端口</span><br><span class="line">  -p 将容器内部的端口绑定到宿主机上指定的端口</span><br><span class="line">     后面跟&lt;port&gt; ：表示将容器内部的这个端口隐射到宿主机上的随意端口</span><br><span class="line">     后面跟&lt;port1&gt;:&lt;port2&gt; ：表示将&lt;port2容器内部端口&gt;隐射到&lt;port1宿主机端口&gt;</span><br><span class="line">  --name 为容器命名</span><br><span class="line">  --net 为容器指定网络</span><br><span class="line">  -v 为容器挂载卷组</span><br><span class="line">  --volume-driver 指定容器卷组的驱动</span><br><span class="line"></span><br><span class="line">$ docker run -d -P --name web -v /src/webapp:/webapp training/webapp python app.py</span><br><span class="line">$ docker run -d -P --name web training/webapp python app.py</span><br><span class="line">$ docker run -d -p 80:5000 trainning/webapp python app.py</span><br><span class="line">$ docker run ubuntu /bin/echo &quot;Hello world&quot;</span><br><span class="line">$ docker run -ti ubuntu /bin/bash</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#启动容器，可同时启动多个容器</span><br><span class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">$ docker start 215b04f73370</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#停止容器运行，可同时停止多个容器</span><br><span class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">$ docker stop 215b04f73370</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#重启重启，可同时重启多个容器</span><br><span class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">$ docker restart 215b04f73370</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#删除容器</span><br><span class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">  -f 强制删除一个正在运行的容器(实际上是先停止容器，然后再删除容器)</span><br><span class="line">  -v 删除和容器关联的卷</span><br><span class="line"></span><br><span class="line">$ docker rm -f 215b04f73370</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#列出容器清单</span><br><span class="line">docker ps [OPTIONS]</span><br><span class="line">  -a 列出所有容器,包括已经停止的容器</span><br><span class="line">  -q 值显示容器ID</span><br><span class="line">  -l 列出最近创建的容器</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#连接到一个正在运行的容器</span><br><span class="line">docker attach [OPTIONS] [CONTAINER]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#在一个已经运行的容器里运行命令</span><br><span class="line">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br><span class="line"></span><br><span class="line">$ docker exec -ti db1 /bin/bash</span><br></pre></td></tr></table></figure><h3 id="Docker-container-state-management"><a href="#Docker-container-state-management" class="headerlink" title="Docker container state management"></a>Docker container state management</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查看容器内部日志</span><br><span class="line">docker logs [OPTIONS] CONTAINER</span><br><span class="line">  -f 容器日志追踪</span><br><span class="line"></span><br><span class="line">$ docker logs grave_roentgen</span><br><span class="line">$ docker logs 20348fdf82e4</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查看容器内部运行的进程</span><br><span class="line">docker top CONTAINER</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#获取容器、images、task的配置信息和状态信息</span><br><span class="line">docker inspect [OPTIONS] CONTAINER|IMAGE|TASK [CONTAINER|IMAGE|TASK...]</span><br><span class="line">  -f 按照给定的模板来输出结果</span><br><span class="line"></span><br><span class="line">$ docker inspect -f &apos;&#123; &#123; range .NetworkSettings.Networks &#125; &#125;&#123; &#123; .IPAddress &#125; &#125;&#123; &#123; end &#125; &#125;&apos; romantic_mahavira</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查看容器内公开端口隐射在宿主机上的端口</span><br><span class="line">docker port CONTAINER [PRIVATE_PORT[/PROTO]]</span><br><span class="line"></span><br><span class="line">$ docker port 215b04f73370</span><br></pre></td></tr></table></figure><h3 id="Docker-images-management"><a href="#Docker-images-management" class="headerlink" title="Docker images management"></a>Docker images management</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#列出image清单</span><br><span class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br><span class="line">  -a 显示所有image</span><br><span class="line">  -q 只显示image ID</span><br><span class="line">  --digests 显示摘要信息</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#拉取image镜像</span><br><span class="line">docker pull [OPTIONS] IMAGENAME[:TAG|@DIGEST]</span><br><span class="line">  -a 将所有tag image下载下来</span><br><span class="line">  --disable-content-trust=true 取消检查image</span><br><span class="line"></span><br><span class="line">$ docker pull chinakevinguo/docker-whale:latest</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查找images</span><br><span class="line">docker search [OPTIONS] image</span><br><span class="line"></span><br><span class="line">$ docker search sinatra</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#登录到docke服务器</span><br><span class="line">docker login [OPTIONS] [SERVER]</span><br><span class="line">  -u 用户名</span><br><span class="line">  -p 密码</span><br><span class="line"></span><br><span class="line">$ docker login</span><br><span class="line">Username: chinakevinguo</span><br><span class="line">Password:</span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#将经过修改的容器构建成新的镜像，一般不推荐这种用法</span><br><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line">  -a 作者</span><br><span class="line">  -m 描述</span><br><span class="line"></span><br><span class="line">$ docker commit -m &quot;Added json gem&quot; -a &quot;Kevin Guo&quot; goofy_bohr chinakevinguo/sinatra:v2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#通过dockerfile构建镜像</span><br><span class="line">docker build [OPTIONS] PATH | URL</span><br><span class="line">  -t 指定image的REPOSITORY，可以指定多个REPOSITORY</span><br><span class="line">  -f 指定你的dockerfile的名称路径（默认是$PATH/Dockerfile）</span><br><span class="line"></span><br><span class="line">$ docker build -t chinakevinguo/sinatra:v3  ~/sinatra</span><br><span class="line">$ docker build -t chinakevinguo/sinatra:v3 -f ~/sinatra/mydockerfile .</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#为image打tag，也可以算是为images重命名</span><br><span class="line">docker tag IMAGE[:TAG] IMAGE[:TAG]</span><br><span class="line"></span><br><span class="line">$ docker tag chinakevinguo/sinatrasdfa:v3 chinakevinguo/sinatra:v5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#上传image到dockerHub上</span><br><span class="line">docker push [OPTIONS] NAME[:TAG]</span><br><span class="line"></span><br><span class="line">$ docker push chinakevinguo/docker-whale:latest</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#删除镜像</span><br><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line">  -f 强制删除镜像(实际上是先删除了基于该镜像创建的容器之后再删除的该镜像)</span><br><span class="line">$ docker rmi -f web1</span><br></pre></td></tr></table></figure><h3 id="Docker-network-management"><a href="#Docker-network-management" class="headerlink" title="Docker network management"></a>Docker network management</h3><ul><li>host模式：容器和宿主机共享network namespace</li><li>container模式：容器和另外一个容器共享network namespace。kubernetes中的pod就是多容器共享一个network namespace</li><li>none模式：容器有独立的network namespace，但没有对其进行任何的网络配置</li><li>bridge模式：docker默认模式，容器通过一个网桥获取ip，以NAT的方式和外界通信 </li></ul><p><img src="/assets/img/docker-bridge-module.png" alt="docker网络模型"></p><p>总结一下bridge网络就是：docker会在机器上自己维护一个网络，并通过<code>docker0</code>这个虚拟交换机和主机本身的网络连接在一起</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#docker网络管理</span><br><span class="line">docker network COMMAND</span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">  create       创建一个网络</span><br><span class="line">  connect      链接容器到网络</span><br><span class="line">  disconnect   将容器从网络断开</span><br><span class="line">  inspect      显示网络的详细信息</span><br><span class="line">  ls           列出网络</span><br><span class="line">  rm           删除一个或者更多网络</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#创建一个网络</span><br><span class="line">docker network create [OPTIONS] YOURNETWORK</span><br><span class="line">  -d 指定docker使用哪种模式的网络</span><br><span class="line"></span><br><span class="line">$ docker network create -d bridge my-bridge-network</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#将容器从网络断开</span><br><span class="line">docker network disconnect [OPTIONS] NETWORK CONTAINER</span><br><span class="line"></span><br><span class="line">$ docker network disconnect bridge web1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#将容器链接到网络</span><br><span class="line">docker network connect [OPTIONS] NETWORK CONTAINER</span><br><span class="line">  --ip   指定ip地址</span><br><span class="line">  --link 添加连接到其他容器</span><br><span class="line"></span><br><span class="line">$ docker network connect my-bridge-network web1</span><br></pre></td></tr></table></figure><h3 id="Docker-container-volume-management"><a href="#Docker-container-volume-management" class="headerlink" title="Docker container volume management"></a>Docker container volume management</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#docker volume 管理</span><br><span class="line">docker volume COMMAND</span><br><span class="line">  COMMANDS：</span><br><span class="line">    create    创建卷组</span><br><span class="line">    inspect   显示卷组详细信息</span><br><span class="line">    ls        列出卷组</span><br><span class="line">    rm        删除卷组</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#为容器挂载卷组</span><br><span class="line">$ docker run -d -P --name web -v /src/webapp:/webapp training/webapp python app.py</span><br></pre></td></tr></table></figure><p>这个命令是将宿主机上的/src/webapp挂载到容器的/webapp，如果/webapp存在，则/src/webapp会覆盖挂载，但是不会删除以前的内容，取消此次挂载后，以前的内容又可以访问了。 容器内部的目录必须指定绝对路径，而宿主机上的目录即可以是绝对路径，也可以仅仅是一个名字或者什么都不写，如果只是一个名字$NAME，则会默认挂载到<code>/var/lib/docker/volumes/$NAME/_data</code>，如果什么都不写，则会挂载到<code>/var/lib/docker/volumes/</code>下的一个随机生成的字符串下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#不指定名字，默认挂载</span><br><span class="line">$ docker run -d -P --name web -v /webapp training/webapp python app.py</span><br><span class="line"></span><br><span class="line">$ docker inspect web</span><br><span class="line">&quot;Name&quot;: &quot;fac362...80535&quot;,</span><br><span class="line">&quot;Source&quot;: &quot;/var/lib/docker/volumes/fac362...80535/_data&quot;,</span><br><span class="line">&quot;Destination&quot;: &quot;/webapp&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#仅仅指定名字</span><br><span class="line">$ docker run -d -P --name web -v webapp:/webapp training/webapp python app.py</span><br><span class="line"></span><br><span class="line">$ docker inspect web</span><br><span class="line">&quot;Name&quot;: &quot;webapp&quot;,</span><br><span class="line">&quot;Source&quot;: &quot;/var/lib/docker/volumes/webapp/_data&quot;,</span><br><span class="line">&quot;Destination&quot;: &quot;/webapp&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#指定绝对路径</span><br><span class="line">$ docker run -d -P --name web -v /src/webapp:/webapp training/webapp python app.py</span><br><span class="line"></span><br><span class="line">$ docker inspect web</span><br><span class="line">&quot;Source&quot;: &quot;/src/webapp&quot;,</span><br><span class="line">&quot;Destination&quot;: &quot;/webapp&quot;,</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#挂载共享卷组作为数据卷</span><br><span class="line">$ docker run -d -P --volume-driver=flocker -v my-named-volume:/webapp --name web training/webapp python app.py</span><br><span class="line"></span><br><span class="line">#先创建共享卷组，然后再进行挂载</span><br><span class="line">$ docker volume create -d flocker -o size-20GB my-named-volume</span><br><span class="line">$ docker run -d -P -v my-named-volume:/webapp --name web training/webapp python app.py</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#将容器作为卷组挂载进容器</span><br><span class="line"></span><br><span class="line">#创建一个卷组容器</span><br><span class="line">$ docker create -v /dbdata --name dbstore training/postgres /bin/true</span><br><span class="line"></span><br><span class="line">#使用--volumes-from 将dbdata挂载进其他容器</span><br><span class="line">$ docker run -d --volumes-from dbstore --name db1 training/postgres</span><br><span class="line">$ docker run -d --volumes-from dbstore --name db2 training/postgres</span><br></pre></td></tr></table></figure><h3 id="Backup，restore，migrate-data-volumes"><a href="#Backup，restore，migrate-data-volumes" class="headerlink" title="Backup，restore，migrate data volumes"></a>Backup，restore，migrate data volumes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#将卷组容器挂载到对应的容器之后，进行卷组数据备份</span><br><span class="line">$ docker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#数据恢复</span><br><span class="line">$ docker run -v /dbdata --name dbstore2 ubuntu /bin/bash</span><br><span class="line">$ docker run --rm --volumes-from dbstore2 -v $(pwd):/backup ubuntu bash -c &quot;cd /dbdata &amp;&amp; tar xvf /backup/backup.tar --strip 1&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在使用--rm的时候，会删除匿名卷组，而不会删除定义好的命名卷组</span><br><span class="line">$ docker run --rm -v /foo -v awesome:/bar busybox top</span><br></pre></td></tr></table></figure><p><strong>所谓匿名卷组：即那些指定了路径和那些没有指定命名的挂载项目</strong></p>]]></content>
    
    <summary type="html">
    
      docker常用命令详解。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="docker容器管理" scheme="http://xym-loveit.github.io/tags/docker%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/"/>
    
      <category term="docker容器状态" scheme="http://xym-loveit.github.io/tags/docker%E5%AE%B9%E5%99%A8%E7%8A%B6%E6%80%81/"/>
    
      <category term="docker镜像管理" scheme="http://xym-loveit.github.io/tags/docker%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/"/>
    
      <category term="docker网络管理" scheme="http://xym-loveit.github.io/tags/docker%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
    
      <category term="docker容器卷管理" scheme="http://xym-loveit.github.io/tags/docker%E5%AE%B9%E5%99%A8%E5%8D%B7%E7%AE%A1%E7%90%86/"/>
    
      <category term="docker数据备份及恢复" scheme="http://xym-loveit.github.io/tags/docker%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E5%8F%8A%E6%81%A2%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>使用 Docker 安装 Jenkins</title>
    <link href="http://xym-loveit.github.io/2018/04/25/%E4%BD%BF%E7%94%A8-Docker-%E5%AE%89%E8%A3%85-Jenkins/"/>
    <id>http://xym-loveit.github.io/2018/04/25/使用-Docker-安装-Jenkins/</id>
    <published>2018-04-25T03:14:57.000Z</published>
    <updated>2018-04-25T03:25:56.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>jenkins是一个用Java编写的开源自动化服务器,它是Hudson的一个分支project ; 它是一个持续集成软件(continuous integration),它以节点为单位,连接整个工作流, 通过各种类型插件支持构成具有个性化要求的项目持续集成, 通过各种各样的插件(plugin)来实现各个节点的功能, 它们共同完成持续集成(自动部署)/自动测试或者持续交付等工作.</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1、直接从 DockerHub 上pull 镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull jenkins</span><br></pre></td></tr></table></figure></p><p>2、由于 Jenkins 容器运行后，会自动在宿主计算机中挂在一个数据卷 <code>var/jenkins_home</code>，我们在主机中可以新建一个数据卷的文件夹，这里注意的是，有权限问题，不然会启动失败，有点坑这里，卡了半天，给宿主的这个挂载卷目录中加上下面的权限的就好了，改成为uid 1000的用户，具体参考阿里云<a href="https://yq.aliyun.com/articles/53990" target="_blank" rel="noopener">谈谈 Docker Volume 之权限管理（一）</a>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R 1000 /var/jenkins_home</span><br></pre></td></tr></table></figure></p><p>3、启动容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 7322:8080 -p 50000:50000 -v /var/jenkins_home/:/var/jenkins_home/  --name my_jenkins -d jenkins</span><br></pre></td></tr></table></figure></p><ul><li>8080 端口是访问 jenkins 网页的端口，如果你想在 80 端口访问，就改成 -p 80:8080</li><li>50000 端口与 slave 有关，主要作为master的jenkins用来连接slave的。</li></ul><p>可以更改挂载卷的目录，不过记得也要设置目录权限的问题。</p><p>使用 <code>docker ps</code> 查看运行的容器。</p><h2 id="配置和使用"><a href="#配置和使用" class="headerlink" title="配置和使用"></a>配置和使用</h2><p>1、使用 host + port 访问 jenkins，会进入第一个页面：</p><p><img src="http://op7wplti1.bkt.clouddn.com/install_Jenkins.png" alt="Jenkins安装"></p><p>因为我们将目录<code>/var/jenkins_home</code>已经挂载在宿主主机，可以直接去这个目录查看密码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> cat /var/jenkins_home/secrets/initialAdminPassword</span><br><span class="line">c49d4a7883e1410685c45092a6fabeac</span><br></pre></td></tr></table></figure></p><p>2、进入后就开始安装插件的过程，然后等待安装完成。</p><p>3、然后跳出一个页面设置账号和密码，这样就安装完成，后面学习使用 jenkins 运用到工作中。</p>]]></content>
    
    <summary type="html">
    
      Docker安装Jenkins简单步骤。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker安装Jenkins" scheme="http://xym-loveit.github.io/tags/Docker%E5%AE%89%E8%A3%85Jenkins/"/>
    
      <category term="Jenkins" scheme="http://xym-loveit.github.io/tags/Jenkins/"/>
    
  </entry>
  
  <entry>
    <title>为Docker镜像添加SSH服务</title>
    <link href="http://xym-loveit.github.io/2018/04/20/%E4%B8%BADocker%E9%95%9C%E5%83%8F%E6%B7%BB%E5%8A%A0SSH%E6%9C%8D%E5%8A%A1/"/>
    <id>http://xym-loveit.github.io/2018/04/20/为Docker镜像添加SSH服务/</id>
    <published>2018-04-20T08:01:19.000Z</published>
    <updated>2018-04-22T10:45:00.593Z</updated>
    
    <content type="html"><![CDATA[<p>一些进入容器的办法，比如<code>attach</code>、<code>exec</code>等命令，都无法解决远程管理容器的问题。因此，当我们需要远程登录到容器内进行一些操作的时候，就需要<code>SSH</code>的支持了。</p><p>有两种创建带有SSH服务的镜像：基于<code>Docker commit</code>命令创建和基于<code>Dockerfile</code>创建。</p><h2 id="基于commit命令创建"><a href="#基于commit命令创建" class="headerlink" title="基于commit命令创建"></a>基于commit命令创建</h2><p>Docker提供了<code>docker commit</code>命令，支持用户提交自己对制定容器的修改，并生产新的镜像。<br>命令格式：<code>docker commit CONTAINER[REPOSITORY:[:TAG]]</code></p><h3 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h3><p>首先，使用<code>ubuntu:14.04</code>镜像来创建容器：<br><code>docker run -it ubuntu:14.04 /bin/bash</code><br>更新<code>apt</code>缓存，并安装<code>openssh-server</code><br><code>apt-get update;apt-get install -y openssh-server</code></p><h3 id="2、安装和配置SSH服务"><a href="#2、安装和配置SSH服务" class="headerlink" title="2、安装和配置SSH服务"></a>2、安装和配置SSH服务</h3><p>如果需要正常启动SSH服务，则目录<code>/var/run/sshd</code>必须存在，手动创建它，并启动SSH服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /var/run/sshd</span><br><span class="line">/usr/sbin/sshd -D &amp;</span><br></pre></td></tr></table></figure></p><p>此时查看容器的22端口（ssh服务默认监听端口），可见此端口已经处于监听状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -tlnp</span><br><span class="line">//修改SSH服务的安全登录配置，取消pam登录限制</span><br><span class="line">sed -ri &apos;s/session required pam_loginuid.so/#session required pam_loginuid.so/g` /etc/pam.d/sshd</span><br></pre></td></tr></table></figure></p><p>在root用户目录下创建<code>.ssh</code>目录，并复制需要登录的公钥信息（一般为本地主机目录下的<code>.ssh/id_rsa.pub</code>文件，可由<code>ssh-keygen -t rsa</code>命令生成）到<code>authorized_keys</code>文件中。</p><p>创建自动启动SSH服务的可执行文件<code>run.sh</code>。并添加可执行权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /run.sh</span><br><span class="line">chmod +x run.sh</span><br></pre></td></tr></table></figure></p><p>其中，<code>run.sh</code>脚本内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">/usr/sbin/sshd -D</span><br></pre></td></tr></table></figure></p><p>最后，退出容器执行，<code>exit</code>命令。</p><h3 id="3、保存镜像"><a href="#3、保存镜像" class="headerlink" title="3、保存镜像"></a>3、保存镜像</h3><p><code>docker commit [OPTIONS]  CONTAINER [REPOSITORY[:TAG]]</code></p><h3 id="4、使用镜像"><a href="#4、使用镜像" class="headerlink" title="4、使用镜像"></a>4、使用镜像</h3><p>启动容器，并添加端口映射<code>10022--&gt;22</code>。其中10022是宿主主机的端口，22是容器的SSH服务端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//启动容器</span><br><span class="line">docker run -p 10022:22 -d sshd:ubuntu /run.sh </span><br><span class="line">//查看运行进程</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure></p><p>在宿主主机（<code>192.168.1.200</code>）或其他主机上，可以通过<code>SSH</code>访问10022端口来登录容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 192.168.1.200 -p 10022</span><br></pre></td></tr></table></figure></p><h2 id="使用Dockerfile创建"><a href="#使用Dockerfile创建" class="headerlink" title="使用Dockerfile创建"></a>使用Dockerfile创建</h2><h3 id="1、创建工作目录"><a href="#1、创建工作目录" class="headerlink" title="1、创建工作目录"></a>1、创建工作目录</h3><p>创建一个<code>ssh_ubuntu</code>目录,<code>mkdir ssh_ubuntu</code>,并在其中创建<code>Dockerfile</code>和<code>run.sh</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch Dockerfile run.sh</span><br></pre></td></tr></table></figure></p><h3 id="2、编写run-sh脚本和authorized-keys文件"><a href="#2、编写run-sh脚本和authorized-keys文件" class="headerlink" title="2、编写run.sh脚本和authorized_keys文件"></a>2、编写<code>run.sh</code>脚本和<code>authorized_keys</code>文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">/usr/sbin/sshd -D</span><br></pre></td></tr></table></figure><p>在宿主主机上生成SSH秘钥对，并创建<code>authorized_keys</code>文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt; authorized_keys</span><br></pre></td></tr></table></figure></p><h3 id="3、编写Dockerfile"><a href="#3、编写Dockerfile" class="headerlink" title="3、编写Dockerfile"></a>3、编写Dockerfile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#设置基础镜像</span><br><span class="line">FROM ubuntu:14.04</span><br><span class="line">#提供作者信息</span><br><span class="line">LABEL author=&quot;xym&quot; author_email=&quot;xym@126.com&quot;</span><br><span class="line">#更新命令</span><br><span class="line">RUN apt-get update</span><br><span class="line">#安装SSH服务</span><br><span class="line">RUN apt-get install -y openssh-server</span><br><span class="line">RUN mkdir -p /var/run/sshd</span><br><span class="line">RUN mkdir -p /root/.ssh</span><br><span class="line">#取消pam限制</span><br><span class="line">RUN sed -ri &apos;s/session required pam_loginuid.so/#session required pam_loginuid.so/g&apos; /etc/pam.d/sshd </span><br><span class="line">#复制配置文件到相应位置，并赋予脚本可执行权限</span><br><span class="line">ADD authorized_keys /root/.ssh/authorized_keys</span><br><span class="line">ADD run.sh /run.sh</span><br><span class="line">RUN chmod 755 run.sh</span><br><span class="line">#开放端口</span><br><span class="line">EXPOSE 22</span><br><span class="line">#设置自启动命令</span><br><span class="line">CMD [&quot;/run.sh&quot;]</span><br></pre></td></tr></table></figure><h3 id="4、创建镜像xd"><a href="#4、创建镜像xd" class="headerlink" title="4、创建镜像xd"></a>4、创建镜像xd</h3><p>在ssh_ubuntu目录下，使用<code>docker build</code>命令来创建镜像，这里注意还有一个”.”，表示使用当前目录中的<code>Dockerfile</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ssh_ubuntu</span><br><span class="line">docker build -t sshd:Dockerfile .</span><br></pre></td></tr></table></figure></p><h3 id="5、测试镜像，运行容器"><a href="#5、测试镜像，运行容器" class="headerlink" title="5、测试镜像，运行容器"></a>5、测试镜像，运行容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//启动镜像，映射容器22端口到本地的10122端口</span><br><span class="line">docker run -d -p 10122:22 sshd:Dockerfile</span><br><span class="line">//在宿主主机新打开一个终端，连接到新建的容器</span><br><span class="line">ssh 192.168.1.200 -p 10122</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Docker镜像添加SSH服务支持。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Dockerfile创建SSH服务" scheme="http://xym-loveit.github.io/tags/Dockerfile%E5%88%9B%E5%BB%BASSH%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Commit容器创建SSH服务" scheme="http://xym-loveit.github.io/tags/Commit%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BASSH%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>使用Dockerfile创建镜像</title>
    <link href="http://xym-loveit.github.io/2018/04/20/%E4%BD%BF%E7%94%A8Dockerfile%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/"/>
    <id>http://xym-loveit.github.io/2018/04/20/使用Dockerfile创建镜像/</id>
    <published>2018-04-20T02:18:05.000Z</published>
    <updated>2018-04-20T07:33:09.319Z</updated>
    
    <content type="html"><![CDATA[<p><code>Dockerfile</code>是一个文本格式的配置文件，用户可以使用<code>Dockerfile</code>来快速创建自定义的镜像。</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p><code>Dockerfile</code>由一行行命令语句组成，并且支持以<code>#</code>开头的注释行。<br>一般而言，<code>Dockerfile</code>分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#一个nginx dockerfile例子</span><br><span class="line">#基础镜像</span><br><span class="line">FROM ubuntu</span><br><span class="line">#维护者信息</span><br><span class="line">MAINTAINER xym xym@126.com</span><br><span class="line">#镜像操作指令</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y nginx</span><br><span class="line">RUN echo &quot;daemon off;&quot; &gt; /etc/nginx/nginx.conf</span><br><span class="line">#容器启动时执行指令</span><br><span class="line">CMD /usr/sbin/nginx</span><br></pre></td></tr></table></figure></p><p>其中一开始必须指明所基于的镜像名称，接下来一般是说明维护信息。后面则是镜像操作指令，例如RUN指令，RUN指令将对镜像执行跟随的命令。每运行一条RUN指令，镜像就添加新的一层，并提交。最后是CMD指令，用来指定运行容器时的操作命令。</p><h2 id="指令说明"><a href="#指令说明" class="headerlink" title="指令说明"></a>指令说明</h2><p>指令的一般格式为<code>INSTRUCTION arguments</code>，指令包括<code>FROM</code>、<code>MAINTAINER</code>、<code>RUN</code>等。</p><p><img src="http://op7wplti1.bkt.clouddn.com/1900654235_8b1-i_epub.jpg" alt="http://op7wplti1.bkt.clouddn.com/1900654235_8b1-i_epub.jpg"></p><p><img src="http://op7wplti1.bkt.clouddn.com/1900654235_8b1x-i_epub.jpg" alt="http://op7wplti1.bkt.clouddn.com/1900654235_8b1x-i_epub.jpg"></p><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>指定所创建镜像的基础镜像，如果本地不存在，则默认会去<code>Docker Hub</code>下载指定镜像。</p><p>命令格式：<code>FROM &lt;image&gt;</code> or <code>FROM &lt;image&gt;:&lt;tag&gt;</code> or <code>FROM &lt;image&gt;@&lt;digest&gt;</code></p><p>任何<code>Dockerfile</code>中的第一条指令必须为FROM指令。并且，如果在同一个<code>Dockerfile</code>中创建多个镜像，可以使用多个FROM指令（每个镜像一次）。 </p><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>指定维护者信息，格式为 <code>MAINTAINER &lt;name&gt;</code>。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER  image_creator@docker.com</span><br></pre></td></tr></table></figure></p><p>该信息会写入生成镜像的Author属性域中，可以使用 <code>docker inspect imageName/imageId</code>查看。 </p><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>运行指定命令，格式为：<code>RUN &lt;command&gt;</code> 或 <code>RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code>。注意，后一个指令会被解析为<code>json</code>数组，因此必须使用双引号。</p><p>前者默认将在<code>shell</code>终端中运行命令，即<code>/bin/sh-c</code>;后者则使用<code>exec</code>执行，不会启动shell环境。<br>指定使用其他终端类型可以使用第二种方式实现，例如：<code>RUN [&quot;bin/bash&quot;,&quot;-c&quot;,&quot;echo hello&quot;]</code>。</p><p>每条RUN指令将在当前镜像的基础上执行指定指令，并提交为新的镜像。当命令较长时可以使用”\”来换行。</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>CMD指令用来指定启动容器时默认执行的命令。它支持三种格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//使用exec执行，是推荐的使用方式</span><br><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line"></span><br><span class="line">//在/bin/sh中执行，提供给需要交互的应用</span><br><span class="line">CMD command param1 param2</span><br><span class="line"></span><br><span class="line">//提供给ENTRYPOINT的默认参数</span><br><span class="line">CMD [&quot;param1&quot;,&quot;param2&quot;]</span><br></pre></td></tr></table></figure></p><p>每个<code>Dockerfile</code>只能有一条CMD命令，如果指定了多条命令，只有最后一条会被执行。<br>如果用户启动容器时手动指定了运行的命令（作为run的参数），则会覆盖掉CMD指定的命令。</p><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>LABEL指令用来指定生成镜像的元数据标签信息。<br>命令格式：<code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt;...</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL author=&quot;xym&quot; author_email=xxx@126.com</span><br></pre></td></tr></table></figure></p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>声明镜像内的服务所监听的端口。</p><p>命令格式：<code>EXPOSE &lt;port&gt;[&lt;port&gt;...]</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 22 80 8443</span><br></pre></td></tr></table></figure></p><p>该命令只是起到声明作用，并不会自动完成端口映射。在启动容器时需要使用<code>-P</code>，Docker主机会自动分配一个宿主机的临时端口转发到指定的端口；使用<code>-p</code>，则可以具体指定哪个宿主机的本地端口会映射过来。</p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>指定环境变量，在镜像生成过程中会被后续RUN指令使用，在镜像启动的容器中也会存在。</p><p>命令格式：<code>ENV &lt;key&gt; &lt;value&gt;</code> or <code>ENV &lt;key&gt;=&lt;value&gt;</code></p><p>指令指定的环境变量在运行中可以被覆盖掉，如<code>docker run --env &lt;key&gt;=&lt;value&gt; built_image</code></p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>该命令将复制指定的<code>&lt;src&gt;</code>路径下的内容到容器中的<code>&lt;dest&gt;</code>路径下。</p><p>命令格式：<code>ADD &lt;src&gt; &lt;dest&gt;</code></p><p>其中<code>&lt;src&gt;</code>可以是<code>Dockerfile</code>所在目录的一个相对路径（文件或目录），也可以是一个URL，还可以是一个tar文件（如果为<code>tar</code>文件，会自动解压到<code>&lt;dest&gt;</code>路径下）。<code>&lt;dest&gt;</code>可以是镜像内的路径，或者相对于工作目录（<code>WORKDIR</code>）的相对路径。</p><p>路径支持正则格式：<code>ADD *.c /code/</code></p><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>格式为<code>COPY &lt;src&gt; &lt;dest&gt;</code></p><p>复制本地主机的<code>&lt;src&gt;</code>（为<code>Dockerfile</code>所在目录的相对路径、文件或者目录）下的内容到镜像中的<code>&lt;dest&gt;</code>下。目标路径不存在时，会自动创建。路径同样支持正则表达式。当使用本地目录为源目录时，推荐使用<code>COPY</code>。</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>指定镜像的默认入口命令，该入口命令会在启动容器时作为根命令执行，所有传入值作为该命令的参数。<br>支持两种格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]（exec调用执行）</span><br><span class="line">ENTRYPOINT command param1 param2（shell中执行）</span><br></pre></td></tr></table></figure></p><p>此时，<code>CMD</code>指令指定值将作为根命令的参数。<br>每个Dockerfile中只能有一个<code>ENTRYPOINT</code>，当指定多个时，只有最后一个有效。在运行时，可以被<code>--entrypoint</code>参数覆盖掉，如<code>docker run --entrypoint</code></p><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>创建一个数据卷挂载点。格式为<code>VOLUME [&quot;/data&quot;]</code>，可以从本地主机或其他容器挂载数据卷，一般用来存放数据库和需要保存的数据等。</p><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>指定运行容器时的用户名和UID，后续的RUN等指令也会使用指定的用户身份。<br>格式为：<code>USER daemon</code></p><p>当服务不需要管理员权限时，可以通过该命令指定运行用户，并且可以在之前创建所需要的用户。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres</span><br></pre></td></tr></table></figure></p><p>要临时获取管理员权限可以使用<code>gosu</code>或<code>sudo</code></p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>为后续的<code>RUN/CMD/ENTRYPOINT</code>指令配置工作目录。</p><p>格式为：<code>WORKDIR /path/to/workdir</code><br>可以使用多个<code>WORKDIR</code>指令，后续命令如果参数是相对路径，后续命令如果是相对路径，则会基于之前命令指定的路径。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure></p><p>则最终路径为<code>/a/b/c</code></p><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>指定一些镜像内使用的的参数（例如版本号信息等），这些参数在执行<code>docker build</code>命令时以<code>--build-arg&lt;varname&gt;=&lt;value&gt;</code>格式传入。格式为<code>ARG &lt;name&gt;=[&lt;default value&gt;]</code>，则可以用<code>docker build --build-arg &lt;name&gt;=&lt;value&gt; .</code>来指定参数值。</p><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>配置当所创建的镜像作为其他镜像的基础镜像时，所执行的创建操作指令。格式为：<code>ONBUILD [INSTRUCTION]</code></p><p>例如：Dockerfile使用了如下的内容创建了镜像<code>image-A</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[...]</span><br><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>如果基于<code>image-A</code>创建新的镜像时，新的Dockerfile中使用<code>FROM image-A</code>指定基础镜像，会自动执行<code>ONBUILD</code>指令的内容，等价于在后面添加了两条指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">FROM image-A</span><br><span class="line">#自动执行onbuild指定的命令</span><br><span class="line">ADD . /app/src</span><br><span class="line">RUN /usr/local/bin/python-build --dir /app/src</span><br></pre></td></tr></table></figure><p>使用<code>ONBUILD</code>指令的镜像，推荐在标签中注明，例如：<code>ruby:1.9-onbuild</code></p><h3 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h3><p>指定所创建镜像启动的容器接受退出的信号值，例如：<br><code>STOPSIGNAL signal</code></p><h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p>配置所启动容器如何进行健康检查（如何判断健康与否），自Docker1.12开始支持。</p><p>格式有两种：</p><p><code>HEALTHCHECK [OPTIONS] CMD command</code></p><p>根据所执行命令返回值是否为0来判断；<br><code>HEALTHCHECK NONE</code>禁止基础镜像中的健康检查。</p><p>OPTIONS支持：</p><ul><li>–interval=DURATION（默认为30s）：过多久检查一次；</li><li>–timeout=DURATION（默认为30s）：每次检查等待结果的超时；</li><li>–retries=N（默认为3）：如果失败了，重试几次才最终确定失败。</li></ul><h3 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h3><p>指定其他命令使用<code>shell</code>时的默认shell类型。默认值为<code>[&quot;/bin/sh&quot;,&quot;-c&quot;]</code></p><p>注意：对于<code>Windows</code>系统，建议在Dockerfile开头添加<code>#escape=</code>来指定转义信息。</p><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>编写完成<code>Dockerfile</code>之后，可以通过<code>docker build</code>命令来创建镜像。基本格式为<code>docker build [选项] 内容路径</code>，该命令将读取指定路径下（包括子目录）的Dockerfile，并将该路径下的所有内容发送给Docker服务端，由服务端来创建镜像。因此除非生成镜像需要，否则一般建议放置Dockerfile的目录为空目录。有两点经验：</p><ul><li>如果使用非内容路径下的Dockerfile，可以通过-f选项来指定其路径</li><li>要指定生成镜像的标签信息，可以使用-t选项</li></ul><p>例如，指定Dockerfile所在路径为<code>/tmp/docker_builder/</code>,并且希望生成镜像标签为<code>build_repo/first_image</code>,可以使用下面命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t build_repo/first_image /tmp/docker_builder/</span><br></pre></td></tr></table></figure></p><h2 id="使用-dockerignore文件"><a href="#使用-dockerignore文件" class="headerlink" title="使用.dockerignore文件"></a>使用.dockerignore文件</h2><p>可以通过<code>.dockerignore</code>文件（每一行添加一条匹配模式）来让<code>Docker</code>忽略匹配模式路径下的目录和文件。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#comment</span><br><span class="line">*/temp*</span><br><span class="line">*/*/temp*</span><br><span class="line">tmp?</span><br><span class="line">~*</span><br></pre></td></tr></table></figure></p><h2 id="编写Dockerfile的指导原则"><a href="#编写Dockerfile的指导原则" class="headerlink" title="编写Dockerfile的指导原则"></a>编写Dockerfile的指导原则</h2><ul><li>精简镜像用途：尽量让每个镜像的用途都比较集中、单一，避免构造大而复杂，多功能的镜像；</li><li>选用合适的基础镜像：过大的基础镜像会造成生成臃肿的镜像，一般推荐较为小巧的<code>debian</code>镜像；</li><li>提供足够清晰的命令注释和维护者信息：Dockerfile也是一种代码，需要考虑方便后续扩展和他人使用；</li><li>正确使用版本：使用明确的版本号信息，如：1.0，2.0而非latest，将避免内容不一致可能引发的惨案；</li><li>减少镜像层数：如果希望所生成镜像的层数尽量少，则要尽量合并指令，例如多个RUN指令可以合并为一条；</li><li>及时删除临时文件和缓存文件：特别是在执行apt-get指令后，/var/cache/apt/下面会缓存一些安装包；</li><li>提高生成速度：如合理使用缓存，减少内容目录下的文件，或使用<code>.dockerignore</code>文件指定等。</li><li>调整合理的指令顺序：在开启缓存的情况下，内容不变的指令尽量放在前面，这样可以尽量复用</li><li>减少外部源的干扰：如果确实要从外部引入数据，需要指定持久地址，并带有版本信息，让他人可以重复而不出错</li></ul><h2 id="优良的镜像"><a href="#优良的镜像" class="headerlink" title="优良的镜像"></a>优良的镜像</h2><h3 id="BUSYBOX"><a href="#BUSYBOX" class="headerlink" title="BUSYBOX"></a>BUSYBOX</h3><p>BusyBox是一个集成了100多个最常见的<code>Liunx</code>命令和工具（如：cat/echo/grep/mount/telnet等）的精简工具箱。它只有几MB的大小，很方便进行各种快速验证，被誉为“Linux系统的瑞士军刀”。BusyBox可以运行于多款POSIX环境的操作系统中，如Liunx（包括Andrid）、Hurd、FreeBSD等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//查询busybox镜像</span><br><span class="line">docker search busybox</span><br><span class="line"></span><br><span class="line">//下载busybox镜像</span><br><span class="line">docker pull busybox</span><br><span class="line"></span><br><span class="line">//使用busybox创建容器</span><br><span class="line">docker run -it --name my_busybox busybox</span><br></pre></td></tr></table></figure><h3 id="Alpine"><a href="#Alpine" class="headerlink" title="Alpine"></a>Alpine</h3><p>Alpine操作系统是一个面向安全的轻型Linux发行版。Alpine是由非商业组织维护的支持广泛场景的Linux发行版，它特别为资深/重度Liunx用户而优化，关注安全、性能和资源效能。Alpine镜像适用于更多常用场景，并且是一个优秀的可以适用于生产的基础环境。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//查询busybox镜像</span><br><span class="line">docker search alpine</span><br><span class="line"></span><br><span class="line">//下载busybox镜像</span><br><span class="line">docker pull alpine</span><br><span class="line"></span><br><span class="line">//使用busybox创建容器</span><br><span class="line">docker run -it --name my_alpine alpine</span><br></pre></td></tr></table></figure><h3 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian/Ubuntu"></a>Debian/Ubuntu</h3><h3 id="CentOS-Fedora"><a href="#CentOS-Fedora" class="headerlink" title="CentOS/Fedora"></a>CentOS/Fedora</h3>]]></content>
    
    <summary type="html">
    
      Dockerfile基础介绍。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Dockerfile命令" scheme="http://xym-loveit.github.io/tags/Dockerfile%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Docker镜像构建文件Dockerfile及相关命令介绍</title>
    <link href="http://xym-loveit.github.io/2018/04/19/Docker%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E6%96%87%E4%BB%B6Dockerfile%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/"/>
    <id>http://xym-loveit.github.io/2018/04/19/Docker镜像构建文件Dockerfile及相关命令介绍/</id>
    <published>2018-04-19T07:22:20.000Z</published>
    <updated>2018-04-19T08:41:24.476Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>docker build</code>命令或使用<code>Docker Hub</code>的自动构建功能构建Docker镜像时，都需要一个<code>Dockerfile</code>文件。<code>Dockerfile</code>文件是一个由一系列构建指令组成的文本文件，<code>docker build</code>命令会根据这些构建指令完成<code>Docker</code>镜像的构建。本文将会介绍<code>Dockerfile</code>文件，及其中使用的构建指令。</p><h2 id="Dockerfile文件使用"><a href="#Dockerfile文件使用" class="headerlink" title="Dockerfile文件使用"></a>Dockerfile文件使用</h2><p><code>docker build</code>命令会根据<code>Dockerfile</code>文件及上下文构建新<code>Docker镜像</code>。构建上下文是指Dockerfile所在的本地路径或一个URL（Git仓库地址）。构建上下文环境会被递归处理，所以，构建所指定的路径还包括了子目录，而URL还包括了其中指定的子模块。</p><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>将当前目录做为构建上下文时，可以像下面这样使用docker build命令构建镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build .</span><br><span class="line">Sending build context to Docker daemon  6.51 MB</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>说明：构建会在Docker后台守护进程（daemon）中执行，而不是<code>CLI</code>中。构建前，构建进程会将全部内容（递归）发送到守护进程。大多情况下，应该将一个空目录作为构建上下文环境，并将<code>Dockerfile</code>文件放在该目录下。</p><p>在构建上下文中使用的<code>Dockerfile</code>文件，是一个构建指令文件。为了提高构建性能，可以通过<code>.dockerignore</code>文件排除上下文目录下，不需要的文件和目录。</p><p><code>Dockerfile</code>一般位于构建上下文的根目录下，也可以通过<code>-f</code>指定该文件的位置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -f /path/to/a/Dockerfile .</span><br></pre></td></tr></table></figure><p>构建时，还可以通过-t参数指定构建成后，镜像的仓库、标签等：</p><h3 id="镜像标签"><a href="#镜像标签" class="headerlink" title="镜像标签"></a>镜像标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t shykes/myapp .</span><br></pre></td></tr></table></figure><p>如果存在多个仓库下，或使用多个镜像标签，就可以使用多个<code>-t</code>参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .</span><br></pre></td></tr></table></figure><p>在Docker守护进程执行<code>Dockerfile</code>中的指令前，首先会对<code>Dockerfile</code>进行语法检查，有语法错误时会返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t test/myapp .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Error response from daemon: Unknown instruction: RUNCMD</span><br></pre></td></tr></table></figure><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>Docker 守护进程会一条一条的执行<code>Dockerfile</code>中的指令，而且会在每一步提交并生成一个新镜像，最后会输出最终镜像的ID。生成完成后，Docker 守护进程会自动清理你发送的上下文。</p><p><code>Dockerfile</code>文件中的每条指令会被独立执行，并会创建一个新镜像，<code>RUN cd /tmp</code>等命令不会对下条指令产生影响。</p><p>Docker 会重用已生成的中间镜像，以加速<code>docker build</code>的构建速度。以下是一个使用了缓存镜像的执行过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t svendowideit/ambassador .</span><br><span class="line">Sending build context to Docker daemon 15.36 kB</span><br><span class="line">Step 1/4 : FROM alpine:3.2</span><br><span class="line"> ---&gt; 31f630c65071</span><br><span class="line">Step 2/4 : MAINTAINER SvenDowideit@home.org.au</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 2a1c91448f5f</span><br><span class="line">Step 3/4 : RUN apk update &amp;&amp;      apk add socat &amp;&amp;        rm -r /var/cache/</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 21ed6e7fbb73</span><br><span class="line">Step 4/4 : CMD env | grep _TCP= | (sed &apos;s/.*_PORT_\([0-9]*\)_TCP=tcp:\/\/\(.*\):\(.*\)/socat -t 100000000 TCP4-LISTEN:\1,fork,reuseaddr TCP4:\2:\3 \&amp;/&apos; &amp;&amp; echo wait) | sh</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 7ea8aef582cc</span><br><span class="line">Successfully built 7ea8aef582cc</span><br></pre></td></tr></table></figure><p>构建缓存仅会使用本地父生成链上的镜像。如果不想使用本地缓存的镜像，也可以通过<code>--cache-from</code>指定缓存。指定后将再不使用本地生成的镜像链，而是从镜像仓库中下载。</p><h3 id="寻找缓存的逻辑"><a href="#寻找缓存的逻辑" class="headerlink" title="寻找缓存的逻辑"></a>寻找缓存的逻辑</h3><p>Docker 寻找缓存的逻辑其实就是树型结构根据 <code>Dockerfile</code> 指令遍历子节点的过程。下图可以说明这个逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> FROM base_image:version           Dockerfile:</span><br><span class="line">           +----------+                FROM base_image:version</span><br><span class="line">           |base image|                RUN cmd1  --&gt; use cache because we found base image</span><br><span class="line">           +-----X----+                RUN cmd11 --&gt; use cache because we found cmd1</span><br><span class="line">                / \</span><br><span class="line">               /   \</span><br><span class="line">       RUN cmd1     RUN cmd2           Dockerfile:</span><br><span class="line">       +------+     +------+           FROM base_image:version</span><br><span class="line">       |image1|     |image2|           RUN cmd2  --&gt; use cache because we found base image</span><br><span class="line">       +---X--+     +------+           RUN cmd21 --&gt; not use cache because there&apos;s no child node</span><br><span class="line">          / \                                        running cmd21, so we build a new image here</span><br><span class="line">         /   \</span><br><span class="line">RUN cmd11     RUN cmd12</span><br><span class="line">+-------+     +-------+</span><br><span class="line">|image11|     |image12|</span><br><span class="line">+-------+     +-------+</span><br></pre></td></tr></table></figure><p>大部分指令可以根据上述逻辑去寻找缓存，除了 <code>ADD</code> 和 <code>COPY</code> 。这两个指令会复制文件内容到镜像内，除了指令相同以外，Docker 还会检查每个文件内容校验(不包括最后修改时间和最后访问时间)，如果校验不一致，则不会使用缓存。</p><p>除了这两个命令，Docker 并不会去检查容器内的文件内容，比如 <code>RUN apt-get -y update</code>，每次执行时文件可能都不一样，但是 Docker 认为命令一致，会继续使用缓存。这样一来，以后构建时都不会再重新运行<code>apt-get -y update</code>。</p><p>如果 Docker 没有找到当前指令的缓存，则会构建一个新的镜像，并且之后的所有指令都不会再去寻找缓存。</p><h2 id="Dockerfile文件格式"><a href="#Dockerfile文件格式" class="headerlink" title="Dockerfile文件格式"></a>Dockerfile文件格式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Comment</span><br><span class="line">INSTRUCTION arguments</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 注释</span><br><span class="line">指令 参数</span><br></pre></td></tr></table></figure><p><code>Dockerfile</code>文件中指令不区分大小写，但为了更易区分，约定使用<strong>大写</strong>形式。</p><p><code>Docker</code> 会依次执行<code>Dockerfile</code>中的指令，<strong>文件中的第一条指令必须是FROM，FROM指令用于指定一个基础镜像</strong>。</p><p>以#开头的行，Docker会认为是注释。但#出现在指令参数中时，则不是注释。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># Comment</span><br><span class="line">RUN echo &apos;we are running some # of cool things&apos;</span><br></pre></td></tr></table></figure><h2 id="Dockerfile中使用指令"><a href="#Dockerfile中使用指令" class="headerlink" title="Dockerfile中使用指令"></a>Dockerfile中使用指令</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p><code>FROM</code>指令用于指定其后构建新镜像所使用的基础镜像。FROM指令必是<code>Dockerfile</code>文件中的首条命令，启动构建流程后，Docker将会基于该镜像构建新镜像，<code>FROM</code>后的命令也会基于这个基础镜像。</p><p><code>FROM</code>语法格式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;digest&gt;</span><br></pre></td></tr></table></figure></p><p>通过<code>FROM</code>指定的镜像，可以是任何有效的基础镜像。FROM有以下限制：</p><ul><li>FROM必须是Dockerfile中第一条非注释命令</li><li>在一个Dockerfile文件中创建多个镜像时，FROM可以多次出现。只需在每个新命令FROM之前，记录提交上次的镜像ID。</li><li>tag或digest是可选的，如果不使用这两个值时，会使用latest版本的基础镜像</li></ul><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p><code>RUN</code>用于在镜像容器中执行命令，其有以下两种命令执行方式：</p><h4 id="shell执行"><a href="#shell执行" class="headerlink" title="shell执行"></a>shell执行</h4><p>在这种方式会在<code>shell</code>中执行命令，Linux下默认使用<code>/bin/sh -c</code>，Windows下使用<code>cmd /S /C</code>。</p><p>注意：通过<code>SHELL</code>命令修改RUN所使用的默认shell<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;command&gt;</span><br></pre></td></tr></table></figure></p><h4 id="exec执行"><a href="#exec执行" class="headerlink" title="exec执行"></a>exec执行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span><br></pre></td></tr></table></figure><p><code>RUN</code>可以执行任何命令，然后在当前镜像上创建一个新层并提交。提交后的结果镜像将会用在<code>Dockerfile</code>文件的下一步。</p><p>通过<code>RUN</code>执行多条命令时，可以通过<code>\</code>换行执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN /bin/bash -c &apos;source $HOME/.bashrc; \</span><br><span class="line">echo $HOME&apos;</span><br></pre></td></tr></table></figure><p>也可以在同一行中，通过分号分隔命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN /bin/bash -c &apos;source $HOME/.bashrc; echo $HOME&apos;</span><br></pre></td></tr></table></figure></p><p><code>RUN</code>指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定<code>--no-cache</code>参数，如：<code>docker build --no-cache</code>。</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p><code>CMD</code>用于指定在容器启动时所要执行的命令。<code>CMD</code>有以下三种格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">CMD [&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">CMD command param1 param2</span><br></pre></td></tr></table></figure></p><p><code>CMD</code>不同于<code>RUN</code>，<code>CMD</code>用于指定在容器启动时所要执行的命令，而<code>RUN</code>用于指定镜像构建时所要执行的命令。</p><p><code>CMD</code>与<code>RUN</code>在功能实现上也有相似之处。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker run -t -i itbilu/static_web_server /bin/true</span><br></pre></td></tr></table></figure></p><p>等价于：</p><p>cmd [“/bin/true”]</p><p>CMD在Dockerfile文件中仅可指定一次，指定多次时，会覆盖前的指令。</p><p>另外，<code>docker run</code>命令也会覆盖<code>Dockerfile</code>中CMD命令。如果<code>docker run</code>运行容器时，使用了<code>Dockerfile</code>中CMD相同的命令，就会覆盖<code>Dockerfile</code>中的CMD命令。</p><p>如，我们在构建镜像的<code>Dockerfile</code>文件中使用了如下指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;/bin/bash&quot;]</span><br></pre></td></tr></table></figure></p><p>使用<code>docker build</code>构建一个新镜像，镜像名为<code>itbilu/test</code>。构建完成后，使用这个镜像运行一个新容器，运行效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t itbilu/test</span><br><span class="line">root@e3597c81aef4:/#</span><br></pre></td></tr></table></figure><p>在使用<code>docker run</code>运行容器时，我们并没有在命令结尾指定会在容器中执行的命令，这时Docker就会执行在<code>Dockerfile</code>的CMD中指定的命令。</p><p>如果不想使用CMD中指定的命令，就可以在<code>docker run</code>命令的结尾指定所要运行的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t itbilu/test /bin/ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">    1 ?        00:00:00 ps</span><br></pre></td></tr></table></figure></p><p>这时，docker run结尾指定的<code>/bin/ps</code>命令覆盖了<code>Dockerfile</code>的CMD中指定的命令。</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p><code>ENTRYPOINT</code>用于给容器配置一个可执行程序。也就是说，每次使用镜像创建容器时，通过<code>ENTRYPOINT</code>指定的程序都会被设置为默认程序。<code>ENTRYPOINT</code>有以下两种形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span><br><span class="line">ENTRYPOINT command param1 param2</span><br></pre></td></tr></table></figure><p><code>ENTRYPOINT</code>与<code>CMD</code>非常类似，不同的是通过<code>docker run</code>执行的命令不会覆盖<code>ENTRYPOINT</code>，而<code>docker run</code>命令中指定的任何参数，都会被当做参数再次传递给<code>ENTRYPOINT</code>。<code>Dockerfile</code>中只允许有一个<code>ENTRYPOINT</code>命令，多指定时会覆盖前面的设置，而只执行最后的<code>ENTRYPOINT</code>指令。</p><p><code>docker run</code>运行容器时指定的参数都会被传递给<code>ENTRYPOINT</code>，且会覆盖CMD命令指定的参数。如，执行<code>docker run &lt;image&gt; -d</code>时，<code>-d</code>参数将被传递给入口点。</p><p>也可以通过<code>docker run --entrypoint</code>重写<code>ENTRYPOINT</code>入口点。</p><p>如：可以像下面这样指定一个容器执行程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;/usr/bin/nginx&quot;]</span><br></pre></td></tr></table></figure></p><p>完整构建代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Version: 0.0.3</span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line">MAINTAINER 何民三 &quot;cn.liuht@gmail.com&quot;</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y nginx</span><br><span class="line">RUN echo &apos;Hello World, 我是个容器&apos; \ </span><br><span class="line">   &gt; /var/www/html/index.html</span><br><span class="line">ENTRYPOINT [&quot;/usr/sbin/nginx&quot;]</span><br><span class="line">EXPOSE 8</span><br></pre></td></tr></table></figure><p>使用<code>docker build</code>构建镜像，并将镜像指定为<code>itbilu/test</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker build -t=&quot;itbilu/test&quot; .</span><br></pre></td></tr></table></figure></p><p>构建完成后，使用<code>itbilu/test</code>启动一个容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t  itbilu/test -g &quot;daemon off;&quot;</span><br></pre></td></tr></table></figure></p><p>在运行容器时，我们使用了<code>-g &quot;daemon off;&quot;</code>，这个参数将会被传递给<code>ENTRYPOINT</code>，最终在容器中执行的命令为<code>/usr/sbin/nginx -g &quot;daemon off;&quot;</code>。</p><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p><code>LABEL</code>用于为镜像添加元数据，元数以键值对的形式指定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure></p><p>使用<code>LABEL</code>指定元数据时，一条<code>LABEL</code>指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。推荐将所有的元数据通过一条<code>LABEL</code>指令指定，以免生成过多的中间镜像。</p><p>如，通过<code>LABEL</code>指定一些元数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL version=&quot;1.0&quot; description=&quot;这是一个Web服务器&quot; by=&quot;IT笔录&quot;</span><br></pre></td></tr></table></figure></p><p>指定后可以通过<code>docker inspect</code>查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$sudo docker inspect itbilu/test</span><br><span class="line">&quot;Labels&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;1.0&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;这是一个Web服务器&quot;,</span><br><span class="line">    &quot;by&quot;: &quot;IT笔录&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>注意：<code>Dockerfile</code>中还有个<code>MAINTAINER</code>命令，该命令用于指定镜像作者。但<code>MAINTAINER</code>并不推荐使用，更推荐使用<code>LABEL</code>来指定镜像作者。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LABEL maintainer=&quot;itbilu.com&quot;</span><br></pre></td></tr></table></figure></p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p><code>EXPOSE</code>用于指定容器在运行时监听的端口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br></pre></td></tr></table></figure></p><p><code>EXPOSE</code>并不会让容器的端口访问到主机。要使其可访问，需要在<code>docker run</code>运行容器时通过<code>-p</code>来发布这些端口，或通过<code>-P</code>参数来发布<code>EXPOSE</code>导出的所有端口。</p><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p><code>ENV</code>用于设置环境变量，其有以下两种设置形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure></p><p>如，通过<code>ENV</code>设置一个环境变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENV ITBILU_PATH /home/itbilu/</span><br></pre></td></tr></table></figure></p><p>设置后，这个环境变量在<code>ENV</code>命令后都可以使用。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKERDIR $ITBILU_PATH</span><br></pre></td></tr></table></figure></p><p>这些环境变量不仅可以构建镜像过程使用，使用该镜像创建的容器中也可以使用。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -i -t  itbilu/test </span><br><span class="line">root@196ca123c0c3:/# cd $ITBILU_PATH</span><br><span class="line">root@196ca123c0c3:/home/itbilu#</span><br></pre></td></tr></table></figure></p><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p><code>ADD</code>用于复制构建环境中的文件或目录到镜像中。其有以下两种使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">ADD [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure></p><p>通过<code>ADD</code>复制文件时，需要通过<code>&lt;src&gt;</code>指定源文件位置，并通过<code>&lt;dest&gt;</code>来指定目标位置。<code>&lt;src&gt;</code>可以是一个构建上下文中的文件或目录，也可以是一个<code>URL</code>，但不能访问构建上下文之外的文件或目录。</p><p>如，通过<code>ADD</code>复制一个网络文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD http://wordpress.org/latest.zip $ITBILU_PATH</span><br></pre></td></tr></table></figure></p><p>在上例中，<code>$ITBILU_PATH</code>是我们使用<code>ENV</code>指定的一个环境变量。</p><p>另外，如果使用的是本地归档文件（<code>gzip、bzip2、xz</code>）时，Docker会自动进行解包操作，类似使用<code>tar -x</code>。</p><h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p><code>COPY</code>同样用于复制构建环境中的文件或目录到镜像中。其有以下两种使用方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">COPY [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure></p><p><code>COPY</code>指令非常类似于<code>ADD</code>，不同点在于<code>COPY</code>只会复制构建目录下的文件，不能使用<code>URL</code>也不会进行解压操作。</p><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p><code>VOLUME</code>用于创建挂载点，即向基于所构建镜像创始的容器添加卷：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;/data&quot;]</span><br></pre></td></tr></table></figure></p><p>一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：</p><ul><li>卷可以容器间共享和重用</li><li>容器并不一定要和其它容器共享卷</li><li>修改卷后会立即生效</li><li>对卷的修改不会对镜像产生影响</li><li>卷会一直存在，直到没有任何容器在使用它</li></ul><p><code>VOLUME</code>让我们可以将源代码、数据或其它内容添加到镜像中，而又不并提交到镜像中，并使我们可以多个容器间共享这些内容。</p><p>如，通过<code>VOLUME</code>创建一个挂载点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV ITBILU_PATH /home/itbilu/</span><br><span class="line">VOLUME [$ITBILU_PATH]</span><br></pre></td></tr></table></figure></p><p>构建的镜像，并指定镜像名为<code>itbilu/test</code>。构建镜像后，使用新构建的运行一个容器。运行容器时，需<code>-v</code>参将能本地目录绑定到容器的卷（挂载点）上，以使容器可以访问宿主机的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -i -t -v ~/code/itbilu:/home/itbilu/  itbilu/test </span><br><span class="line">root@31b0fac536c4:/# cd /home/itbilu/</span><br><span class="line">root@31b0fac536c4:/home/itbilu# ls</span><br><span class="line">README.md  app.js  bin  config.js  controller  db  demo  document  lib  minify.js  node_modules  package.json  public  routes  test  views</span><br></pre></td></tr></table></figure></p><p>如上所示，我们已经可以容器的<code>/home/itbilu/</code>目录下访问到宿主机<code>~/code/itbilu</code>目录下的数据了。</p><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p><code>USER</code>用于指定运行镜像所使用的用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER daemon</span><br></pre></td></tr></table></figure></p><p>使用<code>USER</code>指定用户时，可以使用用户名、UID或GID，或是两者的组合。以下都是合法的指定试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">USER user</span><br><span class="line">USER user:group</span><br><span class="line">USER uid</span><br><span class="line">USER uid:gid</span><br><span class="line">USER user:gid</span><br><span class="line">USER uid:group</span><br></pre></td></tr></table></figure></p><p>使用<code>USER</code>指定用户后，<code>Dockerfile</code>中其后的命令<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>都将使用该用户。镜像构建完成后，通过<code>docker run</code>运行容器时，可以通过<code>-u</code>参数来覆盖所指定的用户。</p><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p><code>WORKDIR</code>用于在容器内设置一个工作目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /path/to/workdir</span><br></pre></td></tr></table></figure></p><p>通过<code>WORKDIR</code>设置工作目录后，<code>Dockerfile</code>中其后的命令<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>、<code>ADD</code>、<code>COPY</code>等命令都会在该目录下执行。</p><p>如，使用<code>WORKDIR</code>设置工作目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br></pre></td></tr></table></figure></p><p>在以上示例中，<code>pwd</code>最终将会在<code>/a/b/c</code>目录中执行。</p><p>在使用<code>docker run</code>运行容器时，可以通过<code>-w</code>参数覆盖构建时所设置的工作目录。</p><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p><code>ARG</code>用于指定传递给构建运行时的变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARG &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure></p><p>如，通过<code>ARG</code>指定两个变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARG site</span><br><span class="line">ARG build_user=IT笔录</span><br></pre></td></tr></table></figure></p><p>以上我们指定了<code>site</code>和<code>build_user</code>两个变量，其中<code>build_user</code>指定了默认值。在使用<code>docker build</code>构建镜像时，可以通过<code>--build-arg &lt;varname&gt;=&lt;value&gt;</code>参数来指定或重设置这些变量的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker build --build-arg site=itiblu.com -t itbilu/test .</span><br></pre></td></tr></table></figure></p><p>这样我们构建了<code>itbilu/test</code>镜像，其中<code>site</code>会被设置为<code>itbilu.com</code>，由于没有指定<code>build_user</code>，其值将是默认值IT笔录。</p><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p><code>ONBUILD</code>用于设置镜像触发器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD [INSTRUCTION]</span><br></pre></td></tr></table></figure></p><p>当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发。</p><p>如，当镜像被使用时，可能需要做一些处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure></p><h3 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h3><p><code>STOPSIGNAL</code>用于设置停止容器所要发送的系统调用信号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure></p><p>所使用的信号必须是内核系统调用表中的合法的值，如：<code>9</code>、<code>SIGKILL</code>。</p><h3 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h3><p><code>SHELL</code>用于设置执行命令（<code>shell</code>式）所使用的的默认shell类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHELL [&quot;executable&quot;, &quot;parameters&quot;]</span><br></pre></td></tr></table></figure></p><p><code>SHELL</code>在Windows环境下比较有用，Windows下通常会有cmd和powershell两种shell，可能还会有sh。这时就可以通过SHELL来指定所使用的shell类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM microsoft/windowsservercore</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C echo default</span><br><span class="line">RUN echo default</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C powershell -command Write-Host default</span><br><span class="line">RUN powershell -command Write-Host default</span><br><span class="line"></span><br><span class="line"># Executed as powershell -command Write-Host hello</span><br><span class="line">SHELL [&quot;powershell&quot;, &quot;-command&quot;]</span><br><span class="line">RUN Write-Host hello</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C echo hello</span><br><span class="line">SHELL [&quot;cmd&quot;, &quot;/S&quot;&quot;, &quot;/C&quot;]</span><br><span class="line">RUN echo hello</span><br></pre></td></tr></table></figure><blockquote><p>原文链接：<a href="https://itbilu.com/linux/docker/VyhM5wPuz.html" target="_blank" rel="noopener">https://itbilu.com/linux/docker/VyhM5wPuz.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      Dockerfile镜像构建文件命令详解，方便查阅。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Dockerfile命令" scheme="http://xym-loveit.github.io/tags/Dockerfile%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Dockerfile命令详解" scheme="http://xym-loveit.github.io/tags/Dockerfile%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    
      <category term="FROM命令" scheme="http://xym-loveit.github.io/tags/FROM%E5%91%BD%E4%BB%A4/"/>
    
      <category term="RUN命令" scheme="http://xym-loveit.github.io/tags/RUN%E5%91%BD%E4%BB%A4/"/>
    
      <category term="CMD命令" scheme="http://xym-loveit.github.io/tags/CMD%E5%91%BD%E4%BB%A4/"/>
    
      <category term="ADD命令" scheme="http://xym-loveit.github.io/tags/ADD%E5%91%BD%E4%BB%A4/"/>
    
      <category term="COPY命令" scheme="http://xym-loveit.github.io/tags/COPY%E5%91%BD%E4%BB%A4/"/>
    
      <category term="ENTRYPOINT命令" scheme="http://xym-loveit.github.io/tags/ENTRYPOINT%E5%91%BD%E4%BB%A4/"/>
    
      <category term="ENV命令" scheme="http://xym-loveit.github.io/tags/ENV%E5%91%BD%E4%BB%A4/"/>
    
      <category term="ONBUILD命令" scheme="http://xym-loveit.github.io/tags/ONBUILD%E5%91%BD%E4%BB%A4/"/>
    
      <category term="ARG命令" scheme="http://xym-loveit.github.io/tags/ARG%E5%91%BD%E4%BB%A4/"/>
    
      <category term="WORKDIR命令，LABEL命令" scheme="http://xym-loveit.github.io/tags/WORKDIR%E5%91%BD%E4%BB%A4%EF%BC%8CLABEL%E5%91%BD%E4%BB%A4/"/>
    
      <category term="EXPOSE命令" scheme="http://xym-loveit.github.io/tags/EXPOSE%E5%91%BD%E4%BB%A4/"/>
    
      <category term="VOLUME命令" scheme="http://xym-loveit.github.io/tags/VOLUME%E5%91%BD%E4%BB%A4/"/>
    
      <category term="USER命令" scheme="http://xym-loveit.github.io/tags/USER%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>Docker 配置加速器</title>
    <link href="http://xym-loveit.github.io/2018/04/19/Docker-%E9%85%8D%E7%BD%AE%E5%8A%A0%E9%80%9F%E5%99%A8/"/>
    <id>http://xym-loveit.github.io/2018/04/19/Docker-配置加速器/</id>
    <published>2018-04-19T01:51:10.000Z</published>
    <updated>2018-04-19T02:13:46.890Z</updated>
    
    <content type="html"><![CDATA[<p>在国内使用Docker Hub有个很大的问题就是速度太慢，pull一个image要很久，幸亏国内有个组织解决了这个问题——DaoCloud。在<a href="http://www.daocloud.io/#" target="_blank" rel="noopener">DaoCloud</a>上注册一个帐号，找到它的加速器页面，根据提示进行操作即可。</p><p>进入<a href="http://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">加速器</a>页面</p><p><img src="http://op7wplti1.bkt.clouddn.com/daocloud_%E5%8A%A0%E9%80%9F%E5%99%A8.png" alt="daocloud加速器"></p><p><img src="http://op7wplti1.bkt.clouddn.com/%E5%8A%A0%E9%80%9F%E9%85%8D%E7%BD%AE.png" alt="daocloud配置"></p>]]></content>
    
    <summary type="html">
    
      Docker加速器配置
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Docker加速器配置" scheme="http://xym-loveit.github.io/tags/Docker%E5%8A%A0%E9%80%9F%E5%99%A8%E9%85%8D%E7%BD%AE/"/>
    
      <category term="daocloud加速器" scheme="http://xym-loveit.github.io/tags/daocloud%E5%8A%A0%E9%80%9F%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hexo在遇到特殊符号时出现解析报错</title>
    <link href="http://xym-loveit.github.io/2018/04/17/Hexo%E5%9C%A8%E9%81%87%E5%88%B0%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7%E6%97%B6%E5%87%BA%E7%8E%B0%E8%A7%A3%E6%9E%90%E6%8A%A5%E9%94%99/"/>
    <id>http://xym-loveit.github.io/2018/04/17/Hexo在遇到特殊符号时出现解析报错/</id>
    <published>2018-04-16T16:00:35.000Z</published>
    <updated>2018-04-16T16:09:18.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo-在遇到-““-符号时出现解析报错"><a href="#hexo-在遇到-““-符号时出现解析报错" class="headerlink" title="hexo 在遇到 ““ 符号时出现解析报错"></a>hexo 在遇到 “{{“ 符号时出现解析报错</h2><p>最近在更新一篇文章后，无论是 hexo g 生成，还是 hexo s 预览都会报解析错误， 大致如下，后面还有很长的信息，就不贴了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html</span><br><span class="line">Template render error: unexpected token: .</span><br><span class="line">    at Object._prettifyError (D:\workspace\IdeaProjects\myHexo\node_modules\nunjucks\src\lib.js:35:11)</span><br><span class="line">    at Template.render (D:\workspace\IdeaProjects\myHexo\node_modules\nunjucks\src\environment.js:526:21)</span><br></pre></td></tr></table></figure><p>而把那篇文章移除后一切又是正常的。从错误上来看基本可以判断是模板解析错误，从 unexpected token: . 又看不出来具体是哪里出错，一直找不到原因。</p><p>今天查找资料发现有人遇到和我类似的问题，但报的是 <code>unexpected token: }}</code> 的错误。搜索一下我那篇文章，果然有好几处带有 <code>}}</code> 符号。尝试着把几处符号删除，果然正常了。看来问题真的出在 }} 上面。</p><p>直接说解决方案吧，参考别人的解决方法是在 }} 中间加一个空格，但因为我的是有部分教程含义的文章，所以并不想这样误导人。于是去 github 上找解决方案。</p><p>github 上给出的方法是在需要显示 }} 符号的地方加上 <code>{% raw %}{% endraw %}</code> 标签，标记这部分不需要解析。例如文章中可能会出现 <code></code> 的片段，写成 <code>{% raw %}{{ something }}{% endraw %}</code> 就可以了。</p><p>虽然有点麻烦，但也算临时解决了这个问题，这是个已知 bug ，希望后续的版本能修复吧，毕竟使用太多 hexo 专属的标签对博客以后的迁移、改版什么的来说还是很麻烦的。</p><p>本文链接: <a href="https://icewing.cc/post/hexo-bug-of-quot.html" target="_blank" rel="noopener">https://icewing.cc/post/hexo-bug-of-quot.html</a></p>]]></content>
    
    <summary type="html">
    
      Hexo使用解析问题
    
    </summary>
    
      <category term="hexo笔记" scheme="http://xym-loveit.github.io/categories/hexo%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="hexo小技巧" scheme="http://xym-loveit.github.io/tags/hexo%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Docker 端口映射与容器互联</title>
    <link href="http://xym-loveit.github.io/2018/04/16/Docker-%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94/"/>
    <id>http://xym-loveit.github.io/2018/04/16/Docker-端口映射与容器互联/</id>
    <published>2018-04-16T08:11:59.000Z</published>
    <updated>2018-04-16T15:56:45.507Z</updated>
    
    <content type="html"><![CDATA[<p>在实践中会经常碰到需要多个服务组件容器共同协作的情况，这往往需要多个容器之间能够互相访问到对方的服务。除了通过网络访问外，Docker还提供了两个很方便的功能来满足服务访问的基本需求：一是允许映射容器内应用的服务端口到本地宿主主机；另一个是互联机制实现多个容器间通过容器名来快速访问。</p><h2 id="端口映射实现访问容器"><a href="#端口映射实现访问容器" class="headerlink" title="端口映射实现访问容器"></a>端口映射实现访问容器</h2><h3 id="1、从外部访问容器应用"><a href="#1、从外部访问容器应用" class="headerlink" title="1、从外部访问容器应用"></a>1、从外部访问容器应用</h3><p>在启动容器的时候，如果不指定对应的参数，在容器外部是无法通过网络来访问容器内的网络应用和服务的。当容器中运行一些网络应用，要让外部访问这些应用时，可以通过<code>-p</code>或<code>-P</code>参数来指定端口映射。当使用<code>-P</code>（大写的）标记时，Docker会随机映射一个端口到内部容器开放的网络端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@xxx ~]# docker run -d -P training/webapp python app.py</span><br><span class="line">f2c1a06b94b49de281b403fa339d5975be5dd6fae662c664b300540c851c3565</span><br><span class="line"></span><br><span class="line">//ps命令后发现本地主机的32783被映射到了容器的5000端口。访问宿主主机的32783端口即可访问容器内的web应用</span><br><span class="line">[root@xxx ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                          PORTS                     NAMES</span><br><span class="line">f2c1a06b94b4        training/webapp     &quot;python app.py&quot;          3 seconds ago       Up 2 seconds                    0.0.0.0:32783-&gt;5000/tcp   inspiring_hawking</span><br><span class="line"></span><br><span class="line">//同样使用docker logs命令来查看应用信息</span><br><span class="line">[root@xxx ~]# docker logs -f  f2c</span><br><span class="line">Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)</span><br><span class="line">172.17.0.1 - - [14/Apr/2018 16:13:50] &quot;GET / HTTP/1.1&quot; 200 -</span><br></pre></td></tr></table></figure><p><code>-p</code>（小写的）可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IP:HostPort:ContainerPort|IP::ContainerPort|HostPort:ContainerPort</span><br></pre></td></tr></table></figure><h3 id="2、映射所有接口地址"><a href="#2、映射所有接口地址" class="headerlink" title="2、映射所有接口地址"></a>2、映射所有接口地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//使用HostPort:ContainerPort格式将本地的5000端口映射到容器的5000端口</span><br><span class="line">[root@xxx ~]# docker run -d -p 5000:5000 training/webapp python app.py</span><br><span class="line">22c0bc271d46033c16f9ebdbc60ebf78938a1a0710bcede98afd15f887a92968</span><br><span class="line"></span><br><span class="line">//查看容器，注意端口映射栏</span><br><span class="line">[root@xxx ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                    NAMES</span><br><span class="line">22c0bc271d46        training/webapp     &quot;python app.py&quot;          8 seconds ago       Up 7 seconds                0.0.0.0:5000-&gt;5000/tcp   confident_saha</span><br><span class="line"></span><br><span class="line">//多次使用-p标记可以绑定多个端口</span><br><span class="line">[root@xxx ~]# docker run -d -p 5000:5000 -p 8080:80  training/webapp python app.py</span><br><span class="line">c18177c0e1ec3a40c175cec0b7c165d8e0ff9576087c1734293e890357152919</span><br><span class="line"></span><br><span class="line">//查看容器，注意端口映射栏</span><br><span class="line">[root@xxx ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                                          NAMES</span><br><span class="line">c18177c0e1ec        training/webapp     &quot;python app.py&quot;          3 seconds ago       Up 2 seconds                0.0.0.0:5000-&gt;5000/tcp, 0.0.0.0:8080-&gt;80/tcp   suspicious_swartz</span><br></pre></td></tr></table></figure><h3 id="3、映射到指定地址的指定端口"><a href="#3、映射到指定地址的指定端口" class="headerlink" title="3、映射到指定地址的指定端口"></a>3、映射到指定地址的指定端口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//只有自己访问自己</span><br><span class="line">[root@xxx ~]# docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py </span><br><span class="line">4da1f3ed9ee27026b9929e2b96ebd422e2bf6ab212b07ab8fbb8339c322fef70</span><br><span class="line"></span><br><span class="line">[root@xxx ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                      NAMES</span><br><span class="line">4da1f3ed9ee2        training/webapp     &quot;python app.py&quot;          4 seconds ago       Up 4 seconds                127.0.0.1:5000-&gt;5000/tcp   affectionate_elion</span><br></pre></td></tr></table></figure><h3 id="4、映射到指定地址的任意端口"><a href="#4、映射到指定地址的任意端口" class="headerlink" title="4、映射到指定地址的任意端口"></a>4、映射到指定地址的任意端口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//使用IP::ContainerPort绑定localhost的任意端口到容器的5000端口，本地主机会自动分配一个端口</span><br><span class="line">[root@xxx ~]# docker run -d -p 127.0.0.1::5000 training/webapp python app.py</span><br><span class="line">ed9497ef017e2e90fac7e783c92ccde2f59c14f62d429190cb24c0dfa43eeefb</span><br><span class="line"></span><br><span class="line">[root@xxx ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                         PORTS                       NAMES</span><br><span class="line">ed9497ef017e        training/webapp     &quot;python app.py&quot;          5 seconds ago       Up 4 seconds                   127.0.0.1:32768-&gt;5000/tcp   wonderful_yonath</span><br><span class="line"></span><br><span class="line">//还可以使用udp标记来指定udp端口</span><br><span class="line">[root@xxx ~]# docker run -d -p 5000:5000/udp training/webapp python app.py</span><br><span class="line">4880a7d119f226591ad1b99ad0324d55d8e2caa98a399c9f426e6757fc7491c5</span><br><span class="line">[root@xym ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                         PORTS                              NAMES</span><br><span class="line">4880a7d119f2        training/webapp     &quot;python app.py&quot;          3 seconds ago       Up 3 seconds                   5000/tcp, 0.0.0.0:5000-&gt;5000/udp   gracious_williams</span><br><span class="line">b5257d2e</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 5、查看映射端口配置</span><br><span class="line"></span><br><span class="line">使用`docker port`命令来查看当前映射的端口配置，也可以查看到绑定的地址：</span><br></pre></td></tr></table></figure><p>[root@xxx ~]# docker port priceless_franklin 5000<br>0.0.0.0:5000</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 互联机制实现便捷互访</span><br><span class="line"></span><br><span class="line">容器的互联（linking）是一种让多个容器中应用进行快速交互的方式。它会在源和接受容器之间创建连接关系，接受容器可以通过容器名快速访问到源容器，而不用指定具体的IP地址。</span><br><span class="line"></span><br><span class="line">### 1、自定义容器命名</span><br><span class="line"></span><br><span class="line">连接系统依据容器名称来执行。因此，首先需要定义好一个好记的容器名字。虽然当创建容器的时候，系统默认会分配一个名字，但自定义容器名字有两个好处：</span><br><span class="line"></span><br><span class="line">* 自定义的名字比较好记，比如一个web应用容器，我们可以给它起个名字叫web ，一目了然。</span><br><span class="line">* 当要连接其他容器时，即便重启，也可以使用容器名而不用改变，比如连接web容器到db容器。</span><br></pre></td></tr></table></figure><p>//使用–name参数自定义容器名称<br>[root@xxx ~]# docker run -d -p 5000:5000 –name web training/webapp python app.py<br>757d2ee95be01e2c509426c52bf5b4176ff7199eb654b5854ddf0e9b8412c044</p><p>//查看运行容器，注意NAMES栏<br>[root@xxx ~]# docker ps -l<br>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES<br>757d2ee95be0        training/webapp     “python app.py”     5 seconds ago       Up 4 seconds        0.0.0.0:5000-&gt;5000/tcp   web</p><p>//还可使用inspect –format “{{.Name}}“获取容器名字<br>[root@xxx ~]# docker inspect –format “{{.Name}}“ 757d2ee95be<br>/web</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在执行`docker run`的时候如果添加了`--rm`标记，则容器在终止后会立即删除。注意`--rm`和`-d`参数不能同时使用。</span><br><span class="line"></span><br><span class="line">### 2、容器互联</span><br><span class="line"></span><br><span class="line">使用`--link`参数可以让容器之间安全地进行交互。</span><br></pre></td></tr></table></figure><p>//创建一个db容器<br>[root@xxx ~]# docker run -d –name db training/postgres<br>Unable to find image ‘training/postgres:latest’ locally<br>latest: Pulling from training/postgres<br>a3ed95caeb02: Pull complete<br>6e71c809542e: Pull complete<br>2978d9af87ba: Pull complete<br>e1bca35b062f: Pull complete<br>500b6decf741: Pull complete<br>74b14ef2151f: Pull complete<br>7afd5ed3826e: Pull complete<br>3c69bb244f5e: Pull complete<br>d86f9ec5aedf: Pull complete<br>010fabf20157: Pull complete<br>Digest: sha256:a945dc6dcfbc8d009c3d972931608344b76c2870ce796da00a827bd50791907e<br>Status: Downloaded newer image for training/postgres:latest<br>3b48a3a82a86a52244527112a4a03e98e951c8edcdaedb3b63bc1a0775ac0315</p><p>//删除原来的web容器<br>[root@xxx ~]# docker rm -f web<br>web</p><p>//重建web容器，并让它连接到db容器,–link参数的格式为–link name:alias，其中name是要连接的容器名称，alias是这个连接的别名<br>[root@xxx ~]# docker run -d -P –name web –link db:db training/webapp python app.py<br>ca82ea2a2e5ad9b407d5c80fcfd6cd01f7e03be46864e5058b539075e858c626</p><p>//查看运行容器<br>[root@xxx ~]# docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS              PORTS                     NAMES<br>ca82ea2a2e5a        training/webapp     “python app.py”          22 seconds ago       Up 21 seconds       0.0.0.0:32784-&gt;5000/tcp   web<br>3b48a3a82a86        training/postgres   “su postgres -c ‘/us…”   About a minute ago   Up About a minute   5432/tcp                  db</p><p>//查看接受容器(web)连接信息<br>[root@xxx ~]# docaker inspect –format “{{.HostConfig.Links}}“ web<br>[/db:/web/db]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Docker相当于在两个互联的容器之间创建了一个虚机通道，而且不用映射他们的端口在宿主主机上。在启动db容器的时候并没有使用`-p`和`-P`标记，从而避免了暴露数据库服务端口到外部网路上。</span><br><span class="line"></span><br><span class="line">Docker通过两种方式为容器公开连接信息：</span><br><span class="line"></span><br><span class="line">* 更新环境变量</span><br><span class="line">* 更新`/etc/hosts`文件</span><br><span class="line"></span><br><span class="line">使用env命令来查看web容器的环境变量：</span><br></pre></td></tr></table></figure><p>[root@xxx ~]# docker run –rm –name web2 –link db:db training/webapp env<br>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin<br>HOSTNAME=6f8232ea8d36<br>DB_PORT=tcp://172.17.0.3:5432<br>DB_PORT_5432_TCP=tcp://172.17.0.3:5432<br>DB_PORT_5432_TCP_ADDR=172.17.0.3<br>DB_PORT_5432_TCP_PORT=5432<br>DB_PORT_5432_TCP_PROTO=tcp<br>DB_NAME=/web2/db<br>DB_ENV_PG_VERSION=9.3<br>HOME=/root</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中`DB_`开头的环境变量时提供web容器连接db容器使用的，前缀采用大写的连接别名。除了环境变量之外，Docker还添加host信息到子容器的`/etc/hosts`文件，下面是子容器web的hosts文件：</span><br></pre></td></tr></table></figure><p>//创建容器，并进入bash<br>[root@xxx ~]# docker run -it –rm –link db:db training/webapp /bin/bash</p><p>//查看hosts配置<br>root@d64fd0fa99f0:/opt/webapp# cat /etc/hosts<br>172.17.0.3    db 3b48a3a82a86<br>172.17.0.4    d64fd0fa99f0</p><p>//查看db容器，发现其将容器id作为主机名<br>root@3b48a3a82a86:/# cat /etc/hosts<br>127.0.0.1    localhost<br>172.17.0.3    3b48a3a82a86</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里有两个hosts信息，第一个是db容器的IP、主机名和容器id，第二个是web容器，web容器使用自己的id作为默认主机名。</span><br></pre></td></tr></table></figure><p>//安装ping命令<br>root@d64fd0fa99f0:/opt/webapp# apt-get install inetutils-ping<br>Unpacking inetutils-ping (2:1.9.2-1) …<br>Setting up inetutils-ping (2:1.9.2-1) …</p><p>//执行ping命令，测试与db容器的连通性<br>root@d64fd0fa99f0:/opt/webapp# ping db<br>PING db (172.17.0.3): 56 data bytes<br>64 bytes from 172.17.0.3: icmp_seq=0 ttl=64 time=0.267 ms<br>64 bytes from 172.17.0.3: icmp_seq=1 ttl=64 time=0.314 ms<br>64 bytes from 172.17.0.3: icmp_seq=2 ttl=64 time=0.260 ms<br>64 bytes from 172.17.0.3: icmp_seq=3 ttl=64 time=0.131 ms</p><p><code>`</code></p>]]></content>
    
    <summary type="html">
    
      Docker入门指南,端口映射和容器互联。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="docker容器端口映射" scheme="http://xym-loveit.github.io/tags/docker%E5%AE%B9%E5%99%A8%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/"/>
    
      <category term="Pp命" scheme="http://xym-loveit.github.io/tags/Pp%E5%91%BD/"/>
    
      <category term="link选项" scheme="http://xym-loveit.github.io/tags/link%E9%80%89%E9%A1%B9/"/>
    
      <category term="容器互联原理" scheme="http://xym-loveit.github.io/tags/%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 跳过指定文件的渲染</title>
    <link href="http://xym-loveit.github.io/2018/04/16/Hexo-%E8%B7%B3%E8%BF%87%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93/"/>
    <id>http://xym-loveit.github.io/2018/04/16/Hexo-跳过指定文件的渲染/</id>
    <published>2018-04-16T06:52:03.000Z</published>
    <updated>2018-04-16T06:56:58.866Z</updated>
    
    <content type="html"><![CDATA[<p>关于hexo的<code>_config.yml</code>配置，官方文档中：</p><blockquote><p>skip_render：跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。</p></blockquote><p>但并没有说明具体该怎么配置，一番折腾后得以解决：</p><p>如果要跳过source文件夹下的<code>test.html</code>，可以这样配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip_render: test.html</span><br></pre></td></tr></table></figure></p><p>注意，千万不要手贱加上个<code>/</code>写成<code>/test.html</code>，这里只能填相对于source文件夹的相对路径。</p><p>如果要忽略source下的test文件夹下所有文件，可以这样配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip_render: test/*</span><br></pre></td></tr></table></figure></p><p>如果要忽略source下的test文件夹下<code>.html</code>文件，可以这样配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">skip_render: test/*.html</span><br></pre></td></tr></table></figure></p><p>如果要忽略source下的test文件夹下所有文件和目录，可以这样配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip_render: test/**</span><br></pre></td></tr></table></figure><p>如果要忽略多个路径的文件或目录，可以这样配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">skip_render:</span><br><span class="line">    - test.html</span><br><span class="line">    - test/*</span><br></pre></td></tr></table></figure><p><strong>Tips:</strong></p><p><a href="https://github.com/hexojs/hexo/issues/1146" target="_blank" rel="noopener">如何不处理source目录下某个子目录的所有文件，仅仅是将其copy到public目录中对应目录？</a></p>]]></content>
    
    <summary type="html">
    
      Hexo使用小技巧
    
    </summary>
    
      <category term="hexo笔记" scheme="http://xym-loveit.github.io/categories/hexo%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="hexo小技巧" scheme="http://xym-loveit.github.io/tags/hexo%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Docker 数据管理</title>
    <link href="http://xym-loveit.github.io/2018/04/15/Docker-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/"/>
    <id>http://xym-loveit.github.io/2018/04/15/Docker-数据管理/</id>
    <published>2018-04-15T11:04:53.000Z</published>
    <updated>2018-04-16T04:44:34.177Z</updated>
    
    <content type="html"><![CDATA[<p>在生产环境中使用Docker过程中，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享，这必然涉及到容器的数据管理操作。</p><p>容器中管理数据主要有两种方式：</p><p>数据卷（Data volumes）：容器内数据直接映射到本地主机环境；<br>数据卷容器（Data Volume Containers）：使用特定容器维护数据卷；</p><p>本文首先介绍如果在容器内创建数据卷，并且把本地的目录或文件挂载到容器内的数据卷中。接下来，会介绍如何使用数据卷容器，在容器和主机、容器和容器之间共享数据，并实现数据的备份和恢复。</p><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>数据卷是一个可供容器使用的特殊目录，它将主机操作系统目录直接映射进容器，类似于linux中的mount操作。</p><p>数据卷可以提供很多有用的特性：  </p><ul><li>数据卷可以在容器之间共享和重用，容器间传递数据将变得高效方便</li><li>对数据卷内数据的修改会立马生效，无论是容器内操作还是本机操作</li><li>对数据卷的更新不会影响镜像，解耦了应用和数据</li><li>卷会一直存在，直到没有容器使用，可以安全的卸载它</li></ul><h3 id="1、在容器内创建一个数据卷"><a href="#1、在容器内创建一个数据卷" class="headerlink" title="1、在容器内创建一个数据卷"></a>1、在容器内创建一个数据卷</h3><p>在用<code>docker run</code>命令的时候，使用-v标记可以在容器内创建一个数据卷。多次重复使用-v标记可以创建多个数据卷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//使用training/webapp镜像创建一个web（name参数指定容器名称）容器，并创建一个数据卷挂载到容器的/webapp目录（-v 指定创建的数据卷）</span><br><span class="line">// -P参数是将容器服务暴露的端口自动映射到本地主机的临时端口上，python app.py(为执行的命令COMMAND和其对应的参数ARG)</span><br><span class="line">[root@xxx ~]# docker run -d -P --name web -v /webapp training/webapp python app.py</span><br><span class="line">Unable to find image &apos;training/webapp:latest&apos; locally</span><br><span class="line">latest: Pulling from training/webapp</span><br><span class="line">e190868d63f8: Pull complete </span><br><span class="line">909cd34c6fd7: Pull complete </span><br><span class="line">0b9bfabab7c1: Pull complete </span><br><span class="line">a3ed95caeb02: Pull complete </span><br><span class="line">10bbbc0fc0ff: Pull complete </span><br><span class="line">fca59b508e9f: Pull complete </span><br><span class="line">e7ae2541b15b: Pull complete </span><br><span class="line">9dd97ef58ce9: Pull complete </span><br><span class="line">a4c1b0cb7af7: Pull complete </span><br><span class="line">Digest: sha256:06e9c1983bd6d5db5fba376ccd63bfa529e8d02f23d5079b8f74a616308fb11d</span><br><span class="line">Status: Downloaded newer image for training/webapp:latest</span><br><span class="line">e7816725b3d075b56410c9d64543a4febfe965e9a5d7cc1c8ea82c92c966f030</span><br><span class="line"></span><br><span class="line">//查看镜像</span><br><span class="line">[root@xxx ~]# docker images</span><br><span class="line">REPOSITORY                                        TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hub.c.163.com/public/ubuntu                       14.04               2fe5c4bba1f9        2 years ago         237MB</span><br><span class="line">training/webapp                                   latest              6fae60ef3446        2 years ago         349MB  </span><br><span class="line"></span><br><span class="line">//查看运行态的容器</span><br><span class="line">[root@xxx ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES</span><br><span class="line">e7816725b3d0        training/webapp     &quot;python app.py&quot;     21 seconds ago      Up 20 seconds       0.0.0.0:32768-&gt;5000/tcp   web</span><br></pre></td></tr></table></figure><h3 id="2、挂载一个主机目录作为数据卷"><a href="#2、挂载一个主机目录作为数据卷" class="headerlink" title="2、挂载一个主机目录作为数据卷"></a>2、挂载一个主机目录作为数据卷</h3><p>使用-v标记也可以指定挂载一个本地的已有目录到容器中去作为数据卷（推荐方式）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//使用-v /src/webapp:/opt/webapp 加载主机/src/webapp目录到容器的/opt/webapp目录，python为command命令，app.py为运行参数</span><br><span class="line">[root@xxx webapp]# docker run -d -P --name web -v /src/webapp:/opt/webapp training/webapp python app.py</span><br><span class="line">1e0d2372472f8697a65c7da879a8807cf048bc4601b7136e354e4b0c87a7126f</span><br><span class="line"></span><br><span class="line">//查看运行的容器</span><br><span class="line">[root@xxx webapp]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES</span><br><span class="line">1e0d2372472f        training/webapp     &quot;python app.py&quot;     4 seconds ago       Up 3 seconds        0.0.0.0:32781-&gt;5000/tcp   web</span><br></pre></td></tr></table></figure><p>这个功能在进行测试的时候非常方便，比如用户可以将一些程序或数据放到本地目录中，然后在容器中运行和使用。另外，本地目录的路径必须是绝对路径，如果目录不存在,Docker会自动创建</p><p>Docker挂载数据卷的默认权限是读写（rw），用户也可以通过<code>ro</code>指定为只读。加了<code>ro</code>之后，容器内对所挂载数据卷内的数据就无法修改了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@xxx ~]# docker run -d -P --name web -v /src/webapp:/opt/webapp:ro training/webapp python app.py</span><br><span class="line">f5d7d04aa46c50db6696efa8554a9d344bbd3f13eb077be3c680a1ac89d509a0</span><br></pre></td></tr></table></figure><h3 id="3、挂载一个本地主机文件作为数据卷"><a href="#3、挂载一个本地主机文件作为数据卷" class="headerlink" title="3、挂载一个本地主机文件作为数据卷"></a>3、挂载一个本地主机文件作为数据卷</h3><p><code>-v</code>参数，也可以从主机挂载单个文件到容器中作为数据卷（不推荐）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//使用-v ~/.bash_history:/.bash_history，这样就可以记录在容器中输入过的命令历史了</span><br><span class="line"></span><br><span class="line">[root@xxx ~]# docker run -it -v ~/.bash_history:/.bash_history ubuntu /bin/bash</span><br><span class="line">root@43e50ea02e35:/# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@43e50ea02e35:/# history </span><br><span class="line">    1  ls</span><br><span class="line">    2  history</span><br></pre></td></tr></table></figure><p>挂载文件引起的问题：使用文件编辑工具，包括<code>vi</code>或者<code>sed --in-place</code>的时候，可能会造成文件<code>inode</code>的改变，从Docker1.1.0起，这会导致报错误信息。所以推荐的方式是直接挂载文件所在目录。</p><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>如果用户需要在多个容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。数据卷容器也是一个容器，但是它的目的是专门用来提供数据卷供其他容器挂载。</p><p>首先创建一个数据卷容器<code>dbdata</code>,并在其中创建一个数据卷挂载到<code>/dbdata</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建一个数据卷容器</span><br><span class="line">[root@xxx ~]# docker run -it -v /dbdata --name dbdata ubuntu</span><br><span class="line"></span><br><span class="line">//查看目录</span><br><span class="line">root@d4bb57243d45:/# ls</span><br><span class="line">bin  boot  dbdata  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure></p><p>然后，可以在其他容器中使用<code>--volumes-from</code>来挂载<code>dbdata</code>容器中的数据卷，例如创建<code>db1</code>和<code>db2</code>两个容器，并从<code>dbdata</code>容器挂载数据卷：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 创建2个容器挂载dbdata容器中的数据卷</span><br><span class="line">[root@xxx ~]# docker run -it --volumes-from dbdata --name db1 ubuntu</span><br><span class="line">[root@xxx ~]# docker run -it --volumes-from dbdata --name db2 ubuntu</span><br></pre></td></tr></table></figure><p>此时，容器db1和容器db2都挂载同一个数据卷到相同的<code>dbdata</code>目录。三个容器任何一方在该目录下的写入，其他容器都可以看到。例如，在<code>dbdata</code>容器中创建一个<code>test</code>文件,在<code>db1</code>容器中可能查看到它：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//在dbdata容器的数据卷中创建文件a</span><br><span class="line">root@9e90f695bcb8:/dbdata# touch a</span><br><span class="line">root@9e90f695bcb8:/dbdata# ll</span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x.  2 root root   14 Apr 14 10:02 ./</span><br><span class="line">drwxr-xr-x. 22 root root 4096 Apr 14 10:01 ../</span><br><span class="line">-rw-r--r--.  1 root root    0 Apr 14 10:02 a</span><br><span class="line"></span><br><span class="line">//在db1容器中查看数据卷目录dbdata，也发现了文件a</span><br><span class="line">root@ab4426a23cb4:/dbdata# ll</span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x.  2 root root    6 Apr 14 10:01 ./</span><br><span class="line">drwxr-xr-x. 22 root root 4096 Apr 14 10:02 ../</span><br><span class="line">root@ab4426a23cb4:/dbdata# ls     </span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">//db2结果和db1一样</span><br><span class="line">root@b4bea0f56613:/# cd dbdata/</span><br><span class="line">root@b4bea0f56613:/dbdata# ll</span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x.  2 root root   14 Apr 14 10:02 ./</span><br><span class="line">drwxr-xr-x. 22 root root 4096 Apr 14 10:03 ../</span><br><span class="line">-rw-r--r--.  1 root root    0 Apr 14 10:02 a</span><br></pre></td></tr></table></figure><p>可以多次使用<code>--volumes-from</code>参数来从多个容器挂载多个数据卷。还可以从其他已经挂载了容器卷的容器来挂载数据卷。  </p><p>使用<code>--volumes-from</code>参数所挂载数据卷的容器自身并不需要保持在运行状态。如果删除了挂载容器（包括dbdata、db1和bd2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时显示使用<code>docker rm -v</code>命令来指定同时删除关联的数据卷。</p><h2 id="利用数据卷容器迁移数据"><a href="#利用数据卷容器迁移数据" class="headerlink" title="利用数据卷容器迁移数据"></a>利用数据卷容器迁移数据</h2><p>可以使用数据卷容器对其中的数据卷进行备份、恢复、以实现数据的迁移。</p><h3 id="1、备份"><a href="#1、备份" class="headerlink" title="1、备份"></a>1、备份</h3><p>使用如下命令来备份<code>dbdata</code>数据卷容器内的数据卷：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@xxx ~]# docker run --volumes-from dbdata -v $(pwd):/backup --name worker ubuntu tar -zcvf /backup/backup.tar /dbdata</span><br><span class="line">tar: Removing leading `/&apos; from member names</span><br><span class="line">/dbdata/</span><br><span class="line">/dbdata/a</span><br><span class="line"></span><br><span class="line">[root@xxx ~]#</span><br></pre></td></tr></table></figure><p>分析命令：  </p><ul><li>利用ubuntu镜像创建一个容器worker。对应命令参数：<code>docker run --name worker ubuntu</code></li><li>使用<code>--volumes-from dbdata</code>参数来让<code>worker</code>容器挂载<code>dbdata</code>容器的数据卷(即dbdata)。对应命令参数：<code>--volumes-from dbdata</code></li><li>使用 <code>-v $(pwd):/backup</code>参数来挂载本地的当前目录到<code>woker</code>容器的<code>/backup</code>目录。对应命令参数：<code>-v $(pwd):/backup</code></li><li><code>worker</code>容器启动后，使用<code>tar -zcvf /backup/backup.tar /dbdata</code>命令来将<code>/dbdata</code>下内容备份为容器内的<code>/backup/backup.tar</code>,即宿主主机当前目录下的<code>backup.tar</code>。</li></ul><h3 id="2、恢复"><a href="#2、恢复" class="headerlink" title="2、恢复"></a>2、恢复</h3><p>如果要将数据恢复到一个容器，可以按照下面步骤操作。首先创建一个带有数据卷的容器<code>dbdata2</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>然后创建另一个新的容器，挂载<code>dbdata2</code>的容器，并使用<code>untar</code>解压备份文件到所挂载的容器中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker run --volumes-from dbdata2 -v $(pwd):/backup busybox untar /backup/backup.tar</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Docker入门指南，通过数据卷（-v参数）和数据卷容器（--volumes-from参数）来做数据管理（使用数据卷容器做数据卷的备份和恢复）。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="docker数据管理" scheme="http://xym-loveit.github.io/tags/docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/"/>
    
      <category term="-v选项" scheme="http://xym-loveit.github.io/tags/v%E9%80%89%E9%A1%B9/"/>
    
      <category term="--volumes-from选项" scheme="http://xym-loveit.github.io/tags/volumes-from%E9%80%89%E9%A1%B9/"/>
    
      <category term="数据卷备份" scheme="http://xym-loveit.github.io/tags/%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%A4%87%E4%BB%BD/"/>
    
      <category term="数据卷恢复" scheme="http://xym-loveit.github.io/tags/%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%81%A2%E5%A4%8D/"/>
    
  </entry>
  
  <entry>
    <title>Docker 基本操作之仓库</title>
    <link href="http://xym-loveit.github.io/2018/04/15/Docker-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E4%B9%8B%E4%BB%93%E5%BA%93/"/>
    <id>http://xym-loveit.github.io/2018/04/15/Docker-基本操作之仓库/</id>
    <published>2018-04-15T07:43:29.000Z</published>
    <updated>2018-04-15T10:00:40.619Z</updated>
    
    <content type="html"><![CDATA[<p>仓库（Repository）是集中存放镜像的地方，分为公共仓库和私有仓库。一个容易与之混淆的概念是注册服务器（Registry）。实际上注册服务器是存放仓库的具体服务器，一个注册服务器上可以有多个仓库，而每个仓库下面可以有多个镜像。从这方面来说，可将仓库看做一个具体的项目或目录。例如对于仓库地址<code>private-docker.com/ubuntu</code>来说,<code>private-docker.com</code>是注册服务器地址，<code>ubuntu</code>是仓库名。</p><h2 id="Docker-Hub公共镜像"><a href="#Docker-Hub公共镜像" class="headerlink" title="Docker Hub公共镜像"></a>Docker Hub公共镜像</h2><p>访问地址：<a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a></p><h3 id="1、登录仓库"><a href="#1、登录仓库" class="headerlink" title="1、登录仓库"></a>1、登录仓库</h3><p>命令格式：<code>docker login [OPTIONS] [SERVER]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -p, --password string   Password</span><br><span class="line">      --password-stdin    Take the password from stdin</span><br><span class="line">  -u, --username string   Username</span><br><span class="line">  </span><br><span class="line">//通过存储的登录信息，直接确认登录  </span><br><span class="line">[root@xxx ~]# docker login</span><br><span class="line">Authenticating with existing credentials...</span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Are you sure you want to proceed? [y/N] y</span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure><h3 id="2、基本操作"><a href="#2、基本操作" class="headerlink" title="2、基本操作"></a>2、基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//查找官方仓库中的镜像，搜索关键词centos</span><br><span class="line">[root@xxx ~]# docker search centos</span><br><span class="line">NAME                               DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">centos                             The official build of CentOS.                   4188                [OK]                </span><br><span class="line">ansible/centos7-ansible            Ansible on Centos7                              108                                     [OK]</span><br><span class="line">jdeathe/centos-ssh                 CentOS-6 6.9 x86_64 / CentOS-7 7.4.1708 x86_…   94                                      [OK]</span><br><span class="line">consol/centos-xfce-vnc             Centos container with &quot;headless&quot; VNC session…   52                                      [OK]</span><br><span class="line">imagine10255/centos6-lnmp-php56    centos6-lnmp-php56                              40                                      [OK]</span><br><span class="line">tutum/centos                       Simple CentOS docker image with SSH access      38                                      </span><br><span class="line">gluster/gluster-centos             Official GlusterFS Image [ CentOS-7 +  Glust…   26                                      [OK]</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">//下载centos镜像</span><br><span class="line">[root@xxx ~]# docker pull centos</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/centos</span><br><span class="line">469cfcc7a4b3: Pull complete </span><br><span class="line">Digest: sha256:989b936d56b1ace20ddf855a301741e52abca38286382cba7f44443210e96d16</span><br><span class="line">Status: Downloaded newer image for centos:latest</span><br></pre></td></tr></table></figure><p>根据search结果，可将镜像资源分为两类。一种是类似centos这样的镜像，称为基础或根镜像。这些镜像是由docker公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。还有一种类型，比如<code>ansible/centos7-ansible</code>镜像，它是由docker用户ansible创建并维护的，带有用户名称前缀，表明是某用户下的某仓库。可以通过用户名称前缀<code>user_name/镜像名</code>来指定使用某个用户提供的镜像。另外，在查找的时候通过-s N参数可以指定仅显示评价为N星级以上的镜像。</p><h3 id="3、自动创建"><a href="#3、自动创建" class="headerlink" title="3、自动创建"></a>3、自动创建</h3><p>自动创建（Automated Builds）功能对于需要经常升级镜像内程序来说，十分方便。有时候，用户创建了镜像，安装了某个软件，如果软件发布新版本则需要手动更新镜像。而自动创建允许用户通过Docker Hub指定跟踪一个目标网站（目前支持Github或Bitbucket）上的项目，一旦项目发生新的提交，则自动执行创建。</p><p>要配置自动创建，包括如下步骤：</p><ul><li>1)创建并登陆Docker Hub，以及目标网站；在目标网站中连接账户到Docker Hub。</li><li>2)在Docker Hub中配置一个“自定创建”</li><li>3)选取一个目标网站中的项目（需要含Dockerfile）和分支；</li><li>4)指定Dockerfile位置，并提交创建</li></ul><p>之后，可以在Docker Hub的“自动创建”页面中跟踪每次创建的状态。</p><h2 id="国内时速云镜像"><a href="#国内时速云镜像" class="headerlink" title="国内时速云镜像"></a>国内时速云镜像</h2><p>访问地址：<a href="https://hub.tenxcloud.com/" target="_blank" rel="noopener">https://hub.tenxcloud.com/</a></p><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//下载镜像</span><br><span class="line">[root@xxx ~]# docker pull index.tenxcloud.com/tenxcloud/centos</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from tenxcloud/centos</span><br><span class="line">a3ed95caeb02: Pull complete </span><br><span class="line">5989106db7fb: Pull complete </span><br><span class="line">c9d12ea9fc45: Pull complete </span><br><span class="line">68317fcc0aa1: Pull complete </span><br><span class="line">83ef48200e63: Pull complete </span><br><span class="line">c6eb26bf54de: Pull complete </span><br><span class="line">1bcf3170bbc2: Pull complete </span><br><span class="line">Digest: sha256:190cbd5234c4aad993b852d5f118ecfba5499adc6f752026938bce0eca754b0c</span><br><span class="line">Status: Downloaded newer image for index.tenxcloud.com/tenxcloud/centos:latest</span><br><span class="line"></span><br><span class="line">//查看镜像</span><br><span class="line">[root@xxx ~]# docker images</span><br><span class="line">REPOSITORY                                        TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">xymtest                                           0.1                 8a758d16a99b        22 hours ago        113MB</span><br><span class="line">ubuntu                                            latest              c9d990395902        32 hours ago        113MB</span><br><span class="line">centos                                            latest              e934aafc2206        7 days ago          199MB</span><br><span class="line">registry                                          latest              d1fd7d86a825        3 months ago        33.3MB</span><br><span class="line">index.tenxcloud.com/tenxcloud/centos              latest              6e7516266d96        23 months ago       310MB</span><br></pre></td></tr></table></figure><h2 id="搭建本地私有仓库"><a href="#搭建本地私有仓库" class="headerlink" title="搭建本地私有仓库"></a>搭建本地私有仓库</h2><h3 id="1、使用registry镜像创建私有仓库"><a href="#1、使用registry镜像创建私有仓库" class="headerlink" title="1、使用registry镜像创建私有仓库"></a>1、使用registry镜像创建私有仓库</h3><p>安装Docker后，可以通过官方提供的<code>registry</code>镜像来简单搭建一套本地私有仓库环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//在本地启动registry镜像，作为私有服务器，监听5000端口</span><br><span class="line">[root@xxx ~]# docker run -d -p 5000:5000 registry</span><br><span class="line">Unable to find image &apos;registry:latest&apos; locally</span><br><span class="line">latest: Pulling from library/registry</span><br><span class="line">81033e7c1d6a: Pull complete </span><br><span class="line">b235084c2315: Pull complete </span><br><span class="line">c692f3a6894b: Pull complete </span><br><span class="line">ba2177f3a70e: Pull complete </span><br><span class="line">a8d793620947: Pull complete </span><br><span class="line">Digest: sha256:672d519d7fd7bbc7a448d17956ebeefe225d5eb27509d8dc5ce67ecb4a0bce54</span><br><span class="line">Status: Downloaded newer image for registry:latest</span><br><span class="line">67083c200be2f6a043377a9b4d69af24d0ba9c58a140b753634f5be4ede67464</span><br></pre></td></tr></table></figure><p>这将自动下载并启动一个<code>registry</code>容器，创建本地的私有仓库服务。默认情况下，会将仓库创建在容器的<code>/tmp/registry</code>目录下。可以通过-v参数来将镜像文件存放在本地的指定路径。例如以下实例将上传的镜像放到<code>/opt/data/registry</code>目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//在本地启动registry镜像，作为私有服务器，监听5000端口,并指定本地目录数据卷/opt/data/registry，映射容器内/tmp/registry目录</span><br><span class="line">[root@xxx ~]# docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry</span><br><span class="line">5b9a1ad53352c4e3a6f5bf7d70ef9a6d573cb4da064fb24f8f406444d125555c</span><br></pre></td></tr></table></figure><h3 id="2、管理私有仓库"><a href="#2、管理私有仓库" class="headerlink" title="2、管理私有仓库"></a>2、管理私有仓库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//标记镜像</span><br><span class="line">[root@xxx ~]# docker tag xymtest:0.1 192.168.206.128:5000/test</span><br><span class="line"></span><br><span class="line">//上传镜像</span><br><span class="line">[root@xxx ~]# docker push 192.168.206.128:5000/test</span><br><span class="line">The push refers to repository [192.168.206.128:5000/test]</span><br><span class="line">Get https://192.168.206.128:5000/v2/: http: server gave HTTP response to HTTPS client</span><br><span class="line"></span><br><span class="line">//编辑daemon.json,配置，&quot;insecure-registries&quot;:[&quot;192.168.206.128:5000&quot;]，表示信任这个私有仓库，不进行安全证书检查</span><br><span class="line">[root@xxx docker]# pwd</span><br><span class="line">/etc/docker</span><br><span class="line">[root@xxx docker]# cat daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  //表示信任这个私有仓库，不进行安全证书检查</span><br><span class="line">  &quot;insecure-registries&quot;:[&quot;192.168.206.128:5000&quot;],</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://4vehewku.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//重启docker 服务</span><br><span class="line">[root@xxx docker]# systemctl restart docker</span><br><span class="line"></span><br><span class="line">//推送本地镜像到私有仓库</span><br><span class="line">[root@xxx docker]# docker push 192.168.206.128:5000/test</span><br><span class="line">The push refers to repository [192.168.206.128:5000/test]</span><br><span class="line">6d7697f5e458: Pushed </span><br><span class="line">a8de0e025d94: Pushed </span><br><span class="line">a5e66470b281: Pushed </span><br><span class="line">ac7299292f8b: Pushed </span><br><span class="line">e1a9a6284d0d: Pushed </span><br><span class="line">fccbfa2912f0: Pushed </span><br><span class="line">latest: digest: sha256:46d25028e0eb194348b8b1256b1375238b44116a018de67f3318a1bb9954ee9d size: 1564</span><br><span class="line"></span><br><span class="line">//下载刚刚上传的，私有仓库镜像</span><br><span class="line">[root@xxx docker]# docker pull 192.168.206.128:5000/test</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from test</span><br><span class="line">Digest: sha256:46d25028e0eb194348b8b1256b1375238b44116a018de67f3318a1bb9954ee9d</span><br><span class="line">Status: Downloaded newer image for 192.168.206.128:5000/test:latest</span><br></pre></td></tr></table></figure><p>如果要使用安全证书，我们也可以从较知名的CA服务商（如<code>verisign</code>）申请公开的<code>SSL/TLS</code>证书，或者使用<code>openssl</code>等软件自行生成。</p>]]></content>
    
    <summary type="html">
    
      Docker入门指南，仓库概念及基本操作。
    
    </summary>
    
      <category term="Docker系列" scheme="http://xym-loveit.github.io/categories/Docker%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="pull命令" scheme="http://xym-loveit.github.io/tags/pull%E5%91%BD%E4%BB%A4/"/>
    
      <category term="search命令" scheme="http://xym-loveit.github.io/tags/search%E5%91%BD%E4%BB%A4/"/>
    
      <category term="docker仓库" scheme="http://xym-loveit.github.io/tags/docker%E4%BB%93%E5%BA%93/"/>
    
      <category term="login命令" scheme="http://xym-loveit.github.io/tags/login%E5%91%BD%E4%BB%A4/"/>
    
      <category term="本地搭建私有仓库配置" scheme="http://xym-loveit.github.io/tags/%E6%9C%AC%E5%9C%B0%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E9%85%8D%E7%BD%AE/"/>
    
      <category term="时速云镜像仓库" scheme="http://xym-loveit.github.io/tags/%E6%97%B6%E9%80%9F%E4%BA%91%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/"/>
    
  </entry>
  
</feed>
